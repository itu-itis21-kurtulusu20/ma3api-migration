package tr.gov.tubitak.uekae.esya.api.xmlsignature.model.xades.timestamp;

import tr.gov.tubitak.uekae.esya.api.xmlsignature.Context;
import tr.gov.tubitak.uekae.esya.api.xmlsignature.XMLSignatureException;
import tr.gov.tubitak.uekae.esya.api.xmlsignature.C14nMethod;
import static tr.gov.tubitak.uekae.esya.api.xmlsignature.core.Constants.*;
import tr.gov.tubitak.uekae.esya.api.xmlsignature.util.XmlUtil;
import tr.gov.tubitak.uekae.esya.api.xmlsignature.model.Any;
import tr.gov.tubitak.uekae.esya.api.xmlsignature.model.xades.XAdESBaseElement;
import org.w3c.dom.Element;

import java.util.List;
import java.util.ArrayList;

/**
 * The abstract base container type for time-stamp tokens specified by the
 * present document does have the following features:
 * <ul>
 * <li>It may contain encapsulated RFC 3161 [10] time-stamp tokens as well
 * as XML time-stamp tokens.
 * <li>It may contain more than one time-stamp token generated for the same
 * XAdES data objects (each one issued by different TSAs, for instance).
 * <li>It provides means for managing time-stamp tokens computed on
 * XAdES data objects (as for the aforementioned XAdES properties) or
 * time-stamp tokens computed on external data.
 * <li>It may use specific elements for identifying what is time-stamped and
 * how to generate the input data for the computation of the digest value
 * to be sent to the TSA. For certain XAdES data objects under certain
 * circumstances this information may be implicit.
 * </ul>
 *
 * <p>Below follows the schema definition for the data type.
 *
 * <pre>
 * &lt;xsd:complexType name="IncludeType"&gt;
 *   &lt;xsd:attribute name="URI" type="xsd:anyURI" use="required"/&gt;
 *   &lt;xsd:attribute name="referencedData" type="xsd:boolean" use="optional"/&gt;
 * &lt;/xsd:complexType&gt;
 *
 * &lt;xsd:element name="ReferenceInfo" type="ReferenceInfoType"/&gt;
 *
 * &lt;xsd:complexType name="ReferenceInfoType"&gt;
 *   &lt;xsd:sequence&gt;
 *     &lt;xsd:element ref="ds:DigestMethod"/&gt;
 *     &lt;xsd:element ref="ds:DigestValue"/&gt;
 *   &lt;/xsd:sequence&gt;
 *   &lt;xsd:attribute name="Id" type="xsd:ID" use="optional"/&gt;
 *   &lt;xsd:attribute name="URI" type="xsd:anyURI" use="optional"/&gt;
 * &lt;/xsd:complexType&gt;
 *
 * &lt;xsd:complexType name="GenericTimeStampType" abstract="true"&gt;
 *   &lt;xsd:sequence&gt;
 *     &lt;xsd:choice minOccurs="0"&gt;
 *       &lt;xsd:element ref="Include" minOccurs="0" maxOccurs="unbounded"/&gt;
 *       &lt;xsd:element ref="ReferenceInfo" maxOccurs="unbounded"/&gt;
 *     &lt;/xsd:choice&gt;
 *     &lt;xsd:element ref="ds:CanonicalizationMethod" minOccurs="0"/&gt;
 *     &lt;xsd:choice maxOccurs="unbounded"&gt;
 *       &lt;xsd:element name="EncapsulatedTimeStamp" type="EncapsulatedPKIDataType"/&gt;
 *       &lt;xsd:element name="XMLTimeStamp" type="AnyType"/&gt;
 *     &lt;/xsd:choice&gt;
 *   &lt;/xsd:sequence&gt;
 *   &lt;xsd:attribute name="Id" type="xsd:ID" use="optional"/&gt;
 * &lt;/xsd:complexType&gt;
 * </pre>
 *
 * <p>When present, the optional <code>ds:CanonicalizationMethod</code> element
 * will indicate the canonicalization method used for canonicalizing XML node
 * sets resulting after retrieving (and processing when required) the data
 * objects covered by the time-stamp token(s). When not present, the standard
 * canonicalization method as specified by XMLDSIG MUST be used.
 *
 * <p>The time-stamp token generated by the TSA can be either an ASN.1 data
 * object (as defined in [10], use <code>EncapsulatedTimeStamp</code>), or it
 * can be encoded as XML (use <code>XMLTimeStamp</code>).
 * 
 * @author ahmety
 * date: Sep 28, 2009
 */
public abstract class GenericTimeStamp extends XAdESBaseElement
{
    //
    protected List<Include> mIncludes = new ArrayList<Include>(0);
    protected List<ReferenceInfo> mReferenceInfos = new ArrayList<ReferenceInfo>(0);

    protected C14nMethod mCanonicalizationMethod;

    // either one of below
    protected List<EncapsulatedTimeStamp> mEncapsulatedTimeStamps = new ArrayList<EncapsulatedTimeStamp>(0);
    protected List<Any> mXMLTimeStamps = new ArrayList<Any>(0);


    protected GenericTimeStamp(Context aContext)
    {
        super(aContext);
        setId(aContext.getIdGenerator().uret(getLocalName()));
    }

    /**
     * Construct GenericTimeStamp from existing
     * @param aElement xml element
     * @param aContext according to context
     * @throws tr.gov.tubitak.uekae.esya.api.xmlsignature.XMLSignatureException
     *          when structure is invalid or can not be
     *          resolved appropriately
     */
    protected GenericTimeStamp(Element aElement, Context aContext)
            throws XMLSignatureException
    {
        super(aElement, aContext);

        Element[] includeElements = selectChildren(NS_XADES_1_3_2, TAGX_INCLUDE);
        if (includeElements!=null){
            for (Element includeElement : includeElements) {
                mIncludes.add(new Include(includeElement, mContext));
            }
        }
        Element[] referenceInfoElements = selectChildren(NS_XADES_1_3_2, TAGX_REFERENCEINFO);
        if (referenceInfoElements!=null){
            for (Element referenceInfoElement : referenceInfoElements) {
                mReferenceInfos.add(new ReferenceInfo(referenceInfoElement, mContext));
            }
        }

        Element c14nElement = selectChildElement(NS_XMLDSIG, TAG_C14NMETHOD);
        if (c14nElement!=null){
            String c14nAlg = getAttribute(c14nElement, ATTR_ALGORITHM);
            mCanonicalizationMethod = C14nMethod.resolve(c14nAlg);
        }

        Element[] encapsulatedTSElm = selectChildren(NS_XADES_1_3_2, TAGX_ENCAPSULATEDTIMESTAMP);
        if (encapsulatedTSElm!=null){
            for (Element anEncapsulatedTSElm : encapsulatedTSElm) {
                mEncapsulatedTimeStamps.add(new EncapsulatedTimeStamp(anEncapsulatedTSElm, this,  mContext));
            }
        }
        Element[] xmlTSElm = selectChildren(NS_XADES_1_3_2, TAGX_XMLTIMESTAMP);
        if (xmlTSElm!=null){
            for (Element aXmlTSElm : xmlTSElm) {
                mXMLTimeStamps.add(new XMLTimeStamp(aXmlTSElm, mContext));
            }
        }

        if (mId!=null){
            mElement.setAttributeNS(null, ATTR_ID, mId);
        }

    }

    private void setupChildren()
    {
        XmlUtil.removeChildren(mElement);

        addLineBreak();

        if (mIncludes != null){
            for (Include mInclude : mIncludes) {
                mElement.appendChild(mInclude.getElement());
                addLineBreak();
            }
        }
        if (mReferenceInfos != null){
            for (ReferenceInfo mReferenceInfo : mReferenceInfos) {
                mElement.appendChild(mReferenceInfo.getElement());
                addLineBreak();
            }
        }
        if (mCanonicalizationMethod != null){
            Element c14Element =  insertElement(NS_XMLDSIG, TAG_C14NMETHOD);
            c14Element.setAttributeNS(null, ATTR_ALGORITHM, mCanonicalizationMethod.getURL());
        }
        if (mEncapsulatedTimeStamps != null){
            for (EncapsulatedTimeStamp mEncapsulatedTimeStamp : mEncapsulatedTimeStamps) {
                mElement.appendChild(mEncapsulatedTimeStamp.getElement());
                addLineBreak();
            }
        }
        if (mXMLTimeStamps != null){
            for (Any mXMLTimeStamp : mXMLTimeStamps) {
                mElement.appendChild(mXMLTimeStamp.getElement());
                addLineBreak();
            }
        }
        if (mId!=null){
            mElement.setAttributeNS(null, ATTR_ID, mId);
        }
    }

    public int getIncludeCount(){
        return mIncludes.size();
    }

    public Include getInclude(int aIndex){
        return mIncludes.get(aIndex);
    }

    public void addInclude(Include aInclude){
        mIncludes.add(aInclude);
        setupChildren();
    }

    public int getReferenceInfoCount(){
        return mReferenceInfos.size();
    }

    public ReferenceInfo getReferenceInfo(int aIndex){
        return mReferenceInfos.get(aIndex);
    }

    public void addReferenceInfo(ReferenceInfo aReferenceInfo){
        mReferenceInfos.add(aReferenceInfo);
        setupChildren();
    }

    public C14nMethod getCanonicalizationMethod()
    {
        return mCanonicalizationMethod;
    }

    public void setCanonicalizationMethod(C14nMethod aCanonicalizationMethod)
    {
        mCanonicalizationMethod = aCanonicalizationMethod;
        setupChildren();
    }

    public int getEncapsulatedTimeStampCount(){
        return mEncapsulatedTimeStamps.size();
    }

    public EncapsulatedTimeStamp getEncapsulatedTimeStamp(int aIndex){
        return mEncapsulatedTimeStamps.get(aIndex);
    }

    public void addEncapsulatedTimeStamp(EncapsulatedTimeStamp aETS){
        mEncapsulatedTimeStamps.add(aETS);
        setupChildren();
    }


    public List<Any> getXMLTimeStamps()
    {
        return mXMLTimeStamps;
    }

    public void setXMLTimeStamps(List<Any> aXMLTimeStamps)
    {
        mXMLTimeStamps = aXMLTimeStamps;
        setupChildren();
    }

}
