/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.4, Date: 22-Sep-2017.
 */
package tr.gov.tubitak.uekae.esya.asn.passport;

import com.objsys.asn1j.runtime.*;

public class PassportCVCertificateBody extends Asn1Type {
   private static final long serialVersionUID = 55;
   public final static Asn1Tag TAG =
           new Asn1Tag (Asn1Tag.APPL, Asn1Tag.CONS, 78);

   static {
      setKey (_SelfCvcRtkey._rtkey);
   }

   public Asn1Integer cpi;
   public Asn1OctetString car;
   public ElcPuK puk;
   public Asn1OctetString chr;
   public Chat chat;
   public Asn1OctetString ced;  // optional
   public Asn1OctetString cxd;  // optional

   public PassportCVCertificateBody () {
      super();
      init();
   }

   /**
    * This constructor sets all elements to references to the
    * given objects
    */
   public PassportCVCertificateBody (
           Asn1Integer cpi_,
           Asn1OctetString car_,
           ElcPuK puk_,
           Asn1OctetString chr_,
           Chat chat_,
           Asn1OctetString ced_,
           Asn1OctetString cxd_
   ) {
      super();
      cpi = cpi_;
      car = car_;
      puk = puk_;
      chr = chr_;
      chat = chat_;
      ced = ced_;
      cxd = cxd_;
   }

   /**
    * This constructor is for required elements only.  It sets
    * all elements to references to the given objects
    */
   public PassportCVCertificateBody (
           Asn1Integer cpi_,
           Asn1OctetString car_,
           ElcPuK puk_,
           Asn1OctetString chr_,
           Chat chat_
   ) {
      super();
      cpi = cpi_;
      car = car_;
      puk = puk_;
      chr = chr_;
      chat = chat_;
   }

   /**
    * This constructor allows primitive data to be passed for all
    * primitive elements.  It will create new object wrappers for
    * the primitive data and set other elements to references to
    * the given objects
    */
   public PassportCVCertificateBody (long cpi_,
                                     byte[] car_,
                                     ElcPuK puk_,
                                     byte[] chr_,
                                     Chat chat_,
                                     byte[] ced_,
                                     byte[] cxd_
   ) {
      super();
      cpi = new Asn1Integer (cpi_);
      car = new Asn1OctetString (car_);
      puk = puk_;
      chr = new Asn1OctetString (chr_);
      chat = chat_;
      ced = new Asn1OctetString (ced_);
      cxd = new Asn1OctetString (cxd_);
   }

   /**
    * This constructor is for required elements only.  It allows
    * primitive data to be passed for all primitive elements.
    * It will create new object wrappers for the primitive data
    * and set other elements to references to the given objects.
    */
   public PassportCVCertificateBody (
           long cpi_,
           byte[] car_,
           ElcPuK puk_,
           byte[] chr_,
           Chat chat_
   ) {
      super();
      cpi = new Asn1Integer (cpi_);
      car = new Asn1OctetString (car_);
      puk = puk_;
      chr = new Asn1OctetString (chr_);
      chat = chat_;
   }

   public void init () {
      cpi = null;
      car = null;
      puk = null;
      chr = null;
      chat = null;
      ced = null;
      cxd = null;
   }

   public void decode
           (Asn1BerDecodeBuffer buffer, boolean explicit, int implicitLength)
           throws Asn1Exception, java.io.IOException
   {
      int llen = (explicit) ?
              matchTag (buffer, TAG) : implicitLength;

      init ();

      // decode SEQUENCE

      Asn1BerDecodeContext _context =
              new Asn1BerDecodeContext (buffer, llen);

      IntHolder elemLen = new IntHolder();

      // decode cpi

      if (_context.matchElemTag (Asn1Tag.APPL, Asn1Tag.PRIM, 41, elemLen, true)) {
         int offset = buffer.getByteCount();
         cpi = new Asn1Integer();
         cpi.decode (buffer, false, elemLen.value);

         int declen = buffer.getByteCount() - offset;
         if (declen != elemLen.value && elemLen.value != Asn1Status.INDEFLEN)
            throw new Asn1InvalidLengthException();

      }
      else throw new Asn1MissingRequiredException (buffer, "cpi");

      // decode car

      if (_context.matchElemTag (Asn1Tag.APPL, Asn1Tag.PRIM, 2, elemLen, true)) {
         int offset = buffer.getByteCount();
         car = new Asn1OctetString();
         car.decode (buffer, false, elemLen.value);
         if (!((car.getLength() >= 8 && car.getLength() <= 16))) {
            throw new Asn1ConsVioException ("car.getLength()", car.getLength());
         }

         int declen = buffer.getByteCount() - offset;
         if (declen != elemLen.value && elemLen.value != Asn1Status.INDEFLEN)
            throw new Asn1InvalidLengthException();

      }
      else throw new Asn1MissingRequiredException (buffer, "car");

      // decode puk

      if (_context.matchElemTag (Asn1Tag.APPL, Asn1Tag.CONS, 73, elemLen, false)) {
         puk = new ElcPuK();
         puk.decode (buffer, true, elemLen.value);
      }
      else throw new Asn1MissingRequiredException (buffer, "puk");

      // decode chr

      if (_context.matchElemTag (Asn1Tag.APPL, Asn1Tag.PRIM, 32, elemLen, true)) {
         int offset = buffer.getByteCount();
         chr = new Asn1OctetString();
         chr.decode (buffer, false, elemLen.value);

         int declen = buffer.getByteCount() - offset;
         if (declen != elemLen.value && elemLen.value != Asn1Status.INDEFLEN)
            throw new Asn1InvalidLengthException();

      }
      else throw new Asn1MissingRequiredException (buffer, "chr");

      // decode chat

      if (_context.matchElemTag (Asn1Tag.APPL, Asn1Tag.CONS, 76, elemLen, false)) {
         chat = new Chat();
         chat.decode (buffer, true, elemLen.value);
      }
      else throw new Asn1MissingRequiredException (buffer, "chat");

      // decode ced

      if (_context.matchElemTag (Asn1Tag.APPL, Asn1Tag.PRIM, 37, elemLen, true)) {
         int offset = buffer.getByteCount();
         ced = new Asn1OctetString();
         ced.decode (buffer, false, elemLen.value);

         int declen = buffer.getByteCount() - offset;
         if (declen != elemLen.value && elemLen.value != Asn1Status.INDEFLEN)
            throw new Asn1InvalidLengthException();

      }

      // decode cxd

      if (_context.matchElemTag (Asn1Tag.APPL, Asn1Tag.PRIM, 36, elemLen, true)) {
         int offset = buffer.getByteCount();
         cxd = new Asn1OctetString();
         cxd.decode (buffer, false, elemLen.value);

         int declen = buffer.getByteCount() - offset;
         if (declen != elemLen.value && elemLen.value != Asn1Status.INDEFLEN)
            throw new Asn1InvalidLengthException();

      }

      if (!_context.expired()) {
         Asn1Tag _tag = buffer.peekTag ();
         if (_tag.equals (Asn1Tag.APPL, Asn1Tag.PRIM, 41) ||
                 _tag.equals (Asn1Tag.APPL, Asn1Tag.PRIM, 2) ||
                 _tag.equals (Asn1Tag.APPL, Asn1Tag.CONS, 73) ||
                 _tag.equals (Asn1Tag.APPL, Asn1Tag.PRIM, 32) ||
                 _tag.equals (Asn1Tag.APPL, Asn1Tag.CONS, 76) ||
                 _tag.equals (Asn1Tag.APPL, Asn1Tag.PRIM, 37) ||
                 _tag.equals (Asn1Tag.APPL, Asn1Tag.PRIM, 36))
            throw new Asn1SeqOrderException ();

      }
      if (explicit && llen == Asn1Status.INDEFLEN) {
         matchTag (buffer, Asn1Tag.EOC);
      }
   }

   public int encode (Asn1BerEncodeBuffer buffer, boolean explicit)
           throws Asn1Exception
   {
      int _aal = 0, len;

      // encode cxd

      if (cxd != null) {
         len = cxd.encode (buffer, false);
         len += buffer.encodeTagAndLength (Asn1Tag.APPL, Asn1Tag.PRIM, 36, len);
         _aal += len;
      }

      // encode ced

      if (ced != null) {
         len = ced.encode (buffer, false);
         len += buffer.encodeTagAndLength (Asn1Tag.APPL, Asn1Tag.PRIM, 37, len);
         _aal += len;
      }

      // encode chat

      if (chat != null) {
         len = chat.encode (buffer, true);
         _aal += len;
      }
      else throw new Asn1MissingRequiredException ("chat");

      // encode chr

      if (chr != null) {
         len = chr.encode (buffer, false);
         len += buffer.encodeTagAndLength (Asn1Tag.APPL, Asn1Tag.PRIM, 32, len);
         _aal += len;
      }
      else throw new Asn1MissingRequiredException ("chr");

      // encode puk

      if (puk != null) {
         len = puk.encode (buffer, true);
         _aal += len;
      }
      else throw new Asn1MissingRequiredException ("puk");

      // encode car

      if (car != null) {
         if (!((car.getLength() >= 8 && car.getLength() <= 16))) {
            throw new Asn1ConsVioException ("car.getLength()", car.getLength());
         }

         len = car.encode (buffer, false);
         len += buffer.encodeTagAndLength (Asn1Tag.APPL, Asn1Tag.PRIM, 2, len);
         _aal += len;
      }
      else throw new Asn1MissingRequiredException ("car");

      // encode cpi

      if (cpi != null) {
         len = cpi.encode (buffer, false);
         len += buffer.encodeTagAndLength (Asn1Tag.APPL, Asn1Tag.PRIM, 41, len);
         _aal += len;
      }
      else throw new Asn1MissingRequiredException ("cpi");

      if (explicit) {
         _aal += buffer.encodeTagAndLength (TAG, _aal);
      }

      return (_aal);
   }

   public void print (java.io.PrintStream _out, String _varName, int _level)
   {
      indent (_out, _level);
      _out.println (_varName + " {");
      if (cpi != null) cpi.print (_out, "cpi", _level+1);
      if (car != null) car.print (_out, "car", _level+1);
      if (puk != null) puk.print (_out, "puk", _level+1);
      if (chr != null) chr.print (_out, "chr", _level+1);
      if (chat != null) chat.print (_out, "chat", _level+1);
      if (ced != null) ced.print (_out, "ced", _level+1);
      if (cxd != null) cxd.print (_out, "cxd", _level+1);
      indent (_out, _level);
      _out.println ("}");
   }
}
