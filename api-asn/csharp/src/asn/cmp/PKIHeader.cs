// 
// This file was generated by the Objective Systems ASN1C Compiler
// (http://www.obj-sys.com).  Version: 6.6.4, Date: 10-Oct-2013.
// 
using System;
using Com.Objsys.Asn1.Runtime;

namespace tr.gov.tubitak.uekae.esya.asn.cmp {

   using GeneralName = tr.gov.tubitak.uekae.esya.asn.x509.GeneralName;
   using AlgorithmIdentifier = tr.gov.tubitak.uekae.esya.asn.x509.AlgorithmIdentifier;

   public class PKIHeader : Asn1Type {
      public PKIHeader_pvno pvno;
      public GeneralName sender;
      public GeneralName recipient;
      public Asn1GeneralizedTime messageTime;  // optional
      public tr.gov.tubitak.uekae.esya.asn.x509.AlgorithmIdentifier protectionAlg;  // optional
      public Asn1OctetString senderKID;  // optional
      public Asn1OctetString recipKID;  // optional
      public Asn1OctetString transactionID;  // optional
      public Asn1OctetString senderNonce;  // optional
      public Asn1OctetString recipNonce;  // optional
      public PKIFreeText freeText;  // optional
      public PKIHeader_generalInfo generalInfo;  // optional

      static PKIHeader ()
      {
         Asn1Type.SetKey2 (_cmpValues._rtkey);
      }

      public PKIHeader () : base()
      {
         Init();
      }

      /// <summary>
      /// This constructor sets all elements to references to the 
      /// given objects
      /// </summary>
      public PKIHeader (
         PKIHeader_pvno pvno_,
         GeneralName sender_,
         GeneralName recipient_,
         Asn1GeneralizedTime messageTime_,
         tr.gov.tubitak.uekae.esya.asn.x509.AlgorithmIdentifier protectionAlg_,
         Asn1OctetString senderKID_,
         Asn1OctetString recipKID_,
         Asn1OctetString transactionID_,
         Asn1OctetString senderNonce_,
         Asn1OctetString recipNonce_,
         PKIFreeText freeText_,
         PKIHeader_generalInfo generalInfo_
      )
         : base ()
      {
         pvno = pvno_;
         sender = sender_;
         recipient = recipient_;
         messageTime = messageTime_;
         protectionAlg = protectionAlg_;
         senderKID = senderKID_;
         recipKID = recipKID_;
         transactionID = transactionID_;
         senderNonce = senderNonce_;
         recipNonce = recipNonce_;
         freeText = freeText_;
         generalInfo = generalInfo_;
      }

      /// <summary>
      /// This constructor is for required elements only.  It sets 
      /// all elements to references to the given objects
      /// </summary>
      public PKIHeader (
         PKIHeader_pvno pvno_,
         GeneralName sender_,
         GeneralName recipient_
      )
         : base ()
      {
         pvno = pvno_;
         sender = sender_;
         recipient = recipient_;
      }

      /// <summary>
      /// This constructor allows primitive data to be passed for all 
      /// primitive elements.  It will create new object wrappers for 
      /// the primitive data and set other elements to references to 
      /// the given objects 
      /// </summary>
      public PKIHeader (long pvno_,
         GeneralName sender_,
         GeneralName recipient_,
         string messageTime_,
         tr.gov.tubitak.uekae.esya.asn.x509.AlgorithmIdentifier protectionAlg_,
         byte[] senderKID_,
         byte[] recipKID_,
         byte[] transactionID_,
         byte[] senderNonce_,
         byte[] recipNonce_,
         PKIFreeText freeText_,
         PKIHeader_generalInfo generalInfo_
      )
         : base ()
      {
         pvno = new PKIHeader_pvno (pvno_);
         sender = sender_;
         recipient = recipient_;
         messageTime = new Asn1GeneralizedTime (messageTime_);
         protectionAlg = protectionAlg_;
         senderKID = new Asn1OctetString (senderKID_);
         recipKID = new Asn1OctetString (recipKID_);
         transactionID = new Asn1OctetString (transactionID_);
         senderNonce = new Asn1OctetString (senderNonce_);
         recipNonce = new Asn1OctetString (recipNonce_);
         freeText = freeText_;
         generalInfo = generalInfo_;
      }

      /// <summary>
      /// This constructor is for required elements only.  It allows 
      /// primitive data to be passed for all primitive elements.  
      /// It will create new object wrappers for the primitive data 
      /// and set other elements to references to the given objects. 
      /// </summary>
      public PKIHeader (
         long pvno_,
         GeneralName sender_,
         GeneralName recipient_
      )
         : base ()
      {
         pvno = new PKIHeader_pvno (pvno_);
         sender = sender_;
         recipient = recipient_;
      }

      public void Init () {
         pvno = null;
         sender = null;
         recipient = null;
         messageTime = null;
         protectionAlg = null;
         senderKID = null;
         recipKID = null;
         transactionID = null;
         senderNonce = null;
         recipNonce = null;
         freeText = null;
         generalInfo = null;
      }

      public override void Decode
         (Asn1BerDecodeBuffer buffer, bool explicitTagging, int implicitLength)
      {
         int llen = (explicitTagging) ?
            MatchTag (buffer, Asn1Tag.SEQUENCE) : implicitLength;

         Init ();

         // decode SEQUENCE

         Asn1BerDecodeContext _context =
            new Asn1BerDecodeContext (buffer, llen);

         IntHolder elemLen = new IntHolder();

         // decode pvno

         if (_context.MatchElemTag (Asn1Tag.UNIV, Asn1Tag.PRIM, 2, elemLen, false)) {
            pvno = new PKIHeader_pvno();
            pvno.Decode (buffer, true, elemLen.mValue);
         }
         else throw new Asn1MissingRequiredException (buffer);

         // decode sender

         if (!_context.Expired()) {
            Asn1Tag tag = buffer.PeekTag ();
            if (tag.Equals (Asn1Tag.CTXT, Asn1Tag.CONS, 0) ||
                tag.Equals (Asn1Tag.CTXT, Asn1Tag.PRIM, 1) ||
                tag.Equals (Asn1Tag.CTXT, Asn1Tag.PRIM, 2) ||
                tag.Equals (Asn1Tag.CTXT, Asn1Tag.CONS, 3) ||
                tag.Equals (Asn1Tag.CTXT, Asn1Tag.CONS, 4) ||
                tag.Equals (Asn1Tag.CTXT, Asn1Tag.CONS, 5) ||
                tag.Equals (Asn1Tag.CTXT, Asn1Tag.PRIM, 6) ||
                tag.Equals (Asn1Tag.CTXT, Asn1Tag.PRIM, 7) ||
                tag.Equals (Asn1Tag.CTXT, Asn1Tag.PRIM, 8))
            {
               sender = new GeneralName();
               sender.Decode (buffer, true, elemLen.mValue);
            }
            else throw new Asn1MissingRequiredException (buffer);
         }
         else throw new Asn1MissingRequiredException (buffer);

         // decode recipient

         if (!_context.Expired()) {
            Asn1Tag tag = buffer.PeekTag ();
            if (tag.Equals (Asn1Tag.CTXT, Asn1Tag.CONS, 0) ||
                tag.Equals (Asn1Tag.CTXT, Asn1Tag.PRIM, 1) ||
                tag.Equals (Asn1Tag.CTXT, Asn1Tag.PRIM, 2) ||
                tag.Equals (Asn1Tag.CTXT, Asn1Tag.CONS, 3) ||
                tag.Equals (Asn1Tag.CTXT, Asn1Tag.CONS, 4) ||
                tag.Equals (Asn1Tag.CTXT, Asn1Tag.CONS, 5) ||
                tag.Equals (Asn1Tag.CTXT, Asn1Tag.PRIM, 6) ||
                tag.Equals (Asn1Tag.CTXT, Asn1Tag.PRIM, 7) ||
                tag.Equals (Asn1Tag.CTXT, Asn1Tag.PRIM, 8))
            {
               recipient = new GeneralName();
               recipient.Decode (buffer, true, elemLen.mValue);
            }
            else throw new Asn1MissingRequiredException (buffer);
         }
         else throw new Asn1MissingRequiredException (buffer);

         // decode messageTime

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 0, elemLen, true)) {
            int offset = buffer.ByteCount;
            messageTime = new Asn1GeneralizedTime (true);
            messageTime.Decode (buffer, true, elemLen.mValue);
            int declen = buffer.ByteCount - offset;
            if (declen != elemLen.mValue && elemLen.mValue != Asn1Status.INDEFLEN)
               throw new Asn1InvalidLengthException();
         }

         // decode protectionAlg

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 1, elemLen, true)) {
            int offset = buffer.ByteCount;
            protectionAlg = new AlgorithmIdentifier();
            protectionAlg.Decode (buffer, true, elemLen.mValue);
            int declen = buffer.ByteCount - offset;
            if (declen != elemLen.mValue && elemLen.mValue != Asn1Status.INDEFLEN)
               throw new Asn1InvalidLengthException();
         }

         // decode senderKID

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 2, elemLen, true)) {
            senderKID = new Asn1OctetString();
            senderKID.Decode (buffer, true, elemLen.mValue);
         }

         // decode recipKID

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 3, elemLen, true)) {
            recipKID = new Asn1OctetString();
            recipKID.Decode (buffer, true, elemLen.mValue);
         }

         // decode transactionID

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 4, elemLen, true)) {
            int offset = buffer.ByteCount;
            transactionID = new Asn1OctetString();
            transactionID.Decode (buffer, true, elemLen.mValue);
            int declen = buffer.ByteCount - offset;
            if (declen != elemLen.mValue && elemLen.mValue != Asn1Status.INDEFLEN)
               throw new Asn1InvalidLengthException();
         }

         // decode senderNonce

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 5, elemLen, true)) {
            int offset = buffer.ByteCount;
            senderNonce = new Asn1OctetString();
            senderNonce.Decode (buffer, true, elemLen.mValue);
            int declen = buffer.ByteCount - offset;
            if (declen != elemLen.mValue && elemLen.mValue != Asn1Status.INDEFLEN)
               throw new Asn1InvalidLengthException();
         }

         // decode recipNonce

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 6, elemLen, true)) {
            int offset = buffer.ByteCount;
            recipNonce = new Asn1OctetString();
            recipNonce.Decode (buffer, true, elemLen.mValue);
            int declen = buffer.ByteCount - offset;
            if (declen != elemLen.mValue && elemLen.mValue != Asn1Status.INDEFLEN)
               throw new Asn1InvalidLengthException();
         }

         // decode freeText

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 7, elemLen, true)) {
            int offset = buffer.ByteCount;
            freeText = new PKIFreeText();
            freeText.Decode (buffer, true, elemLen.mValue);
            int declen = buffer.ByteCount - offset;
            if (declen != elemLen.mValue && elemLen.mValue != Asn1Status.INDEFLEN)
               throw new Asn1InvalidLengthException();
         }

         // decode generalInfo

         if (_context.MatchElemTag (Asn1Tag.CTXT, Asn1Tag.CONS, 8, elemLen, false)) {
            generalInfo = new PKIHeader_generalInfo();
            generalInfo.Decode (buffer, true, elemLen.mValue);
         }

      }

      public override int Encode (Asn1BerEncodeBuffer buffer, bool explicitTagging)
      {
         int _aal = 0, len;

         // encode generalInfo

         if (generalInfo != null) {
            len = generalInfo.Encode (buffer, true);
            _aal += len;
         }

         // encode freeText

         if (freeText != null) {
            len = freeText.Encode (buffer, true);
            len += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 7, len);
            _aal += len;
         }

         // encode recipNonce

         if (recipNonce != null) {
            len = recipNonce.Encode (buffer, true);
            len += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 6, len);
            _aal += len;
         }

         // encode senderNonce

         if (senderNonce != null) {
            len = senderNonce.Encode (buffer, true);
            len += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 5, len);
            _aal += len;
         }

         // encode transactionID

         if (transactionID != null) {
            len = transactionID.Encode (buffer, true);
            len += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 4, len);
            _aal += len;
         }

         // encode recipKID

         if (recipKID != null) {
            len = recipKID.Encode (buffer, true);
            len += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 3, len);
            _aal += len;
         }

         // encode senderKID

         if (senderKID != null) {
            len = senderKID.Encode (buffer, true);
            len += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 2, len);
            _aal += len;
         }

         // encode protectionAlg

         if (protectionAlg != null) {
            len = protectionAlg.Encode (buffer, true);
            len += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 1, len);
            _aal += len;
         }

         // encode messageTime

         if (messageTime != null) {
            len = messageTime.Encode (buffer, true);
            len += buffer.EncodeTagAndLength (Asn1Tag.CTXT, Asn1Tag.CONS, 0, len);
            _aal += len;
         }

         // encode recipient

         len = recipient.Encode (buffer, true);
         _aal += len;

         // encode sender

         len = sender.Encode (buffer, true);
         _aal += len;

         // encode pvno

         len = pvno.Encode (buffer, true);
         _aal += len;

         if (explicitTagging) {
            _aal += buffer.EncodeTagAndLength (Asn1Tag.SEQUENCE, _aal);
         }

         return (_aal);
      }

      public override void Print (System.IO.TextWriter _out, 
                                  string _varName, int _level)
      {
         Indent (_out, _level);
         _out.WriteLine (_varName + " {");
         if (pvno != null) pvno.Print (_out, "pvno", _level+1);
         if (sender != null) sender.Print (_out, "sender", _level+1);
         if (recipient != null) recipient.Print (_out, "recipient", _level+1);
         if (messageTime != null) messageTime.Print (_out, "messageTime", _level+1);
         if (protectionAlg != null) protectionAlg.Print (_out, "protectionAlg", _level+1);
         if (senderKID != null) senderKID.Print (_out, "senderKID", _level+1);
         if (recipKID != null) recipKID.Print (_out, "recipKID", _level+1);
         if (transactionID != null) transactionID.Print (_out, "transactionID", _level+1);
         if (senderNonce != null) senderNonce.Print (_out, "senderNonce", _level+1);
         if (recipNonce != null) recipNonce.Print (_out, "recipNonce", _level+1);
         if (freeText != null) freeText.Print (_out, "freeText", _level+1);
         if (generalInfo != null) generalInfo.Print (_out, "generalInfo", _level+1);
         Indent (_out, _level);
         _out.WriteLine ("}");
      }
   }
}
