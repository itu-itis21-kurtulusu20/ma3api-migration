/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 5.64, Date: 16-Dec-2004.
 */
package tr.gov.tubitak.uekae.esya.api.infra.crl.crlincache;

import com.objsys.asn1j.runtime.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import tr.gov.tubitak.uekae.esya.asn.util.UtilTime;
import tr.gov.tubitak.uekae.esya.asn.x509.*;

import java.io.IOException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

class CertificateList extends Asn1Type {
    private static final Logger logger = LoggerFactory.getLogger(CertificateList.class);

    private TBSCertList tbsCertList;
    private AlgorithmIdentifier signatureAlgorithm;
    private Asn1BitString signature;

    private ISignChecker signChecker;

    private List<Map.Entry<byte[], RevokedCertificateInfo>> revokedCertificateList;

    public CertificateList(ISignChecker signChecker) {
        super();
        this.signChecker = signChecker;
        this.revokedCertificateList = new ArrayList<Map.Entry<byte[], RevokedCertificateInfo>>();
    }


    public TBSCertList getTbsCertList() {
        return tbsCertList;
    }
   
    @Override
    public void decode(Asn1BerDecodeBuffer buffer, boolean explicit, int implicitLength)
            throws Asn1Exception, IOException {
        int llen = (explicit) ?
                matchTag(buffer, Asn1Tag.SEQUENCE) : implicitLength;

        // decode SEQUENCE

        Asn1BerDecodeContext context =
                new Asn1BerDecodeContext(buffer, llen);

        IntHolder elemLen = new IntHolder();

        // decode tbsCertList

        if (context.matchElemTag(Asn1Tag.UNIV, Asn1Tag.CONS, 16, elemLen, false)) {
            tbsCertList = new TBSCertList();
            decodeTBSCertList(buffer, true, elemLen.value);
        } else throw new Asn1MissingRequiredException(buffer);

        // decode signatureAlgorithm

        if (context.matchElemTag(Asn1Tag.UNIV, Asn1Tag.CONS, 16, elemLen, false)) {
            signatureAlgorithm = new AlgorithmIdentifier();
            signatureAlgorithm.decode(buffer, true, elemLen.value);
        } else throw new Asn1MissingRequiredException(buffer);

        // decode signature

        if (context.matchElemTag(Asn1Tag.UNIV, Asn1Tag.PRIM, 3, elemLen, false)) {
            signature = new Asn1BitString();
            signature.decode(buffer, true, elemLen.value);
        } else throw new Asn1MissingRequiredException(buffer);

    }

    private void collectTagForSign(int len) {
        Asn1DerEncodeBuffer enc = new Asn1DerEncodeBuffer();
        enc.encodeTagAndLength(Asn1Tag.SEQUENCE, len);
        byte[] encoded = enc.getMsgCopy();
        signChecker.collect(encoded);
    }

    private void collectTagForSign(Asn1Tag tag, int len) {
        Asn1DerEncodeBuffer enc = new Asn1DerEncodeBuffer();
        enc.encodeTagAndLength(tag, len);
        byte[] encoded = enc.getMsgCopy();
        signChecker.collect(encoded);
    }

    private void decodeTBSCertList
            (Asn1BerDecodeBuffer buffer, boolean explicit, int implicitLength)
            throws Asn1Exception, IOException {
        int llen = (explicit) ?
                matchTag(buffer, Asn1Tag.SEQUENCE) : implicitLength;

        collectTagForSign(llen);
        tbsCertList.init();

        // decode SEQUENCE

        Asn1BerDecodeContext context =
                new Asn1BerDecodeContext(buffer, llen);

        IntHolder elemLen = new IntHolder();

        // decode version

        if (context.matchElemTag(Asn1Tag.UNIV, Asn1Tag.PRIM, 2, elemLen, false)) {
            tbsCertList.version = new Version();
            tbsCertList.version.decode(buffer, true, elemLen.value);
            signChecker.collect(tbsCertList.version);
        }

        // decode signature

        if (context.matchElemTag(Asn1Tag.UNIV, Asn1Tag.CONS, 16, elemLen, false)) {
            tbsCertList.signature = new AlgorithmIdentifier();
            tbsCertList.signature.decode(buffer, true, elemLen.value);
            signChecker.collect(tbsCertList.signature);
        } else throw new Asn1MissingRequiredException(buffer);

        // decode issuer

        if (context.matchElemTag(Asn1Tag.UNIV, Asn1Tag.CONS, 16, elemLen, false)) {
            tbsCertList.issuer = new Name();
            tbsCertList.issuer.decode(buffer, true, elemLen.value);
            signChecker.collect(tbsCertList.issuer);
        } else throw new Asn1MissingRequiredException(buffer);

        // decode thisUpdate

        if (!context.expired()) {
            Asn1Tag tag = buffer.peekTag();
            if (tag.equals(Asn1Tag.UNIV, Asn1Tag.PRIM, 23) ||
                    tag.equals(Asn1Tag.UNIV, Asn1Tag.PRIM, 24)) {
                tbsCertList.thisUpdate = new Time();
                tbsCertList.thisUpdate.decode(buffer, true, elemLen.value);
                signChecker.collect(tbsCertList.thisUpdate);
            } else throw new Asn1MissingRequiredException(buffer);
        } else throw new Asn1MissingRequiredException(buffer);

        // decode nextUpdate

        if (!context.expired()) {
            Asn1Tag tag = buffer.peekTag();
            if (tag.equals(Asn1Tag.UNIV, Asn1Tag.PRIM, 23) ||
                    tag.equals(Asn1Tag.UNIV, Asn1Tag.PRIM, 24)) {
                tbsCertList.nextUpdate = new Time();
                tbsCertList.nextUpdate.decode(buffer, true, elemLen.value);
                signChecker.collect(tbsCertList.nextUpdate);
            }
        }

        // decode revokedCertificates

        if (context.matchElemTag(Asn1Tag.UNIV, Asn1Tag.CONS, 16, elemLen, false)) {
            tbsCertList.revokedCertificates = new _SeqOfTBSCertList_revokedCertificates_element();
            decode_SeqOfTBSCertList_revokedCertificates_element(buffer, true, elemLen.value);
        }

        // decode crlExtensions

//        if (context.matchElemTag(Asn1Tag.CTXT, Asn1Tag.CONS, 0, elemLen, true)) {
        Asn1Tag tag = buffer.peekTag();
        Asn1Tag extTag = new Asn1Tag(Asn1Tag.CTXT, Asn1Tag.CONS, 0);
        if ((tag != null) && (tag.equals(extTag))) {
            int lenExt = buffer.decodeTagAndLength(extTag);
            collectTagForSign(extTag, lenExt);
            tbsCertList.crlExtensions = new Extensions();
            tbsCertList.crlExtensions.decode(buffer);
            signChecker.collect(tbsCertList.crlExtensions);
        }

    }

    private void decode_SeqOfTBSCertList_revokedCertificates_element
            (Asn1BerDecodeBuffer buffer, boolean explicit, int implicitLength)
            throws Asn1Exception, IOException {
        int llen = (explicit) ?
                matchTag(buffer, Asn1Tag.SEQUENCE) : implicitLength;

        collectTagForSign(llen);

        // decode SEQUENCE OF or SET OF
        Asn1BerDecodeContext context = new Asn1BerDecodeContext(buffer, llen);

        TBSCertList_revokedCertificates_element element;
        int elemLen = 0;

        while (!context.expired()) {
//            element = new TBSCertList_revokedCertificates_element();
//            element.decode(buffer, true, elemLen);
//            signChecker.collect(element);
//            CRTree.put(element.userCertificate.value, 2113123L);
//            RevokedCertificateInfo info = new RevokedCertificateInfo(UtilTime.timeToDate(element.revocationDate).getTime(), (byte) 0);
//            AbstractMap.SimpleEntry<BigInteger, RevokedCertificateInfo> revokedListEntry =
//                    new AbstractMap.SimpleEntry<BigInteger, RevokedCertificateInfo>(element.userCertificate.value, info);
//            revokedCertificateList.add(revokedListEntry);
            revokedCertificateList.add(decodeTBSCertList_revokedCertificates_element(buffer));
//            CRTree.put(element.userCertificate.value, UtilTime.timeToDate(element.revocationDate).getTime());
//            list.add (element.userCertificate.value);
        }

//      tbsCertList.revokedCertificates.elements = new TBSCertList_revokedCertificates_element [llist.size()];
//      llist.toArray (tbsCertList.revokedCertificates.elements);

    }

    public Map.Entry<byte[], RevokedCertificateInfo> decodeTBSCertList_revokedCertificates_element
            (Asn1BerDecodeBuffer buffer)
            throws Asn1Exception, IOException {
        int llen = matchTag(buffer, Asn1Tag.SEQUENCE);

        // decode SEQUENCE
        collectTagForSign(llen);
        Asn1BerDecodeContext context =
                new Asn1BerDecodeContext(buffer, llen);
        byte[] serialNumber = null;
        IntHolder elemLen = new IntHolder();
        Asn1BigInteger userCertificate;
        Time revocationDate;
        Extensions crlEntryExtensions;

        // decode userCertificate
        if (context.matchElemTag(Asn1Tag.UNIV, Asn1Tag.PRIM, 2, elemLen, false)) {
            userCertificate = new Asn1BigInteger();
            userCertificate.decode(buffer, true, elemLen.value);
            serialNumber = userCertificate.value.toByteArray();
            signChecker.collect(userCertificate);
            
//            buffer.matchTag(Asn1Tag.UNIV, Asn1Tag.PRIM, 2, Asn1Tag.ENUM, elemLen);
//            serialNumber = new byte[elemLen.value];
//            byte[] col = new byte[elemLen.value + 2];
//            col[0] = 2;
//            col[1] = (byte) elemLen.value;
//            for (int i = 0; i < elemLen.value; i++) {
//                serialNumber[i] = (byte) buffer.readByte();
//                col[i + 2] = serialNumber[i];
//            }
//            signChecker.collect(col);

        } else throw new Asn1MissingRequiredException(buffer);

        // decode revocationDate

        if (!context.expired()) {
            Asn1Tag tag = buffer.peekTag();
            if (tag.equals(Asn1Tag.UNIV, Asn1Tag.PRIM, 23) ||
                    tag.equals(Asn1Tag.UNIV, Asn1Tag.PRIM, 24)) {
                revocationDate = new Time();
                revocationDate.decode(buffer, true, elemLen.value);
                signChecker.collect(revocationDate);
            } else throw new Asn1MissingRequiredException(buffer);
        } else throw new Asn1MissingRequiredException(buffer);

        // decode crlEntryExtensions
        byte crlReasonInByte = CRLReason._UNSPECIFIED;
        if (context.matchElemTag(Asn1Tag.UNIV, Asn1Tag.CONS, 16, elemLen, false)) {
            crlEntryExtensions = new Extensions();
            crlEntryExtensions.decode(buffer, true, elemLen.value);
            signChecker.collect(crlEntryExtensions);
            for (Extension extension : crlEntryExtensions.elements)
                if (Arrays.equals(extension.extnID.value, _ImplicitValues.id_ce_cRLReasons)) {
                    byte[] value = extension.extnValue.value;
                    Asn1DerDecodeBuffer dec = new Asn1DerDecodeBuffer(value);
                    crlReasonInByte = (byte) dec.decodeEnumValue(CRLReason.TAG, false, value.length);
                }
        }
        RevokedCertificateInfo info = new RevokedCertificateInfo(UtilTime.timeToDate(revocationDate).getTime(), crlReasonInByte);
        return new SimpleEntry<byte[], RevokedCertificateInfo>(serialNumber,info);
    }

    public int encode(Asn1BerEncodeBuffer buffer, boolean explicit)
            throws Asn1Exception {
        throw new UnsupportedOperationException("Bu yapıda Encode Tanımlanmadı");
    }

    public void print(PrintStream _out, String _varName, int _level) {
        throw new UnsupportedOperationException("Bu yapıda print Tanımlanmadı");
    }

    public List<Map.Entry<byte[], RevokedCertificateInfo>> getRevokedCertificateList() {
        return revokedCertificateList;
    }

   public static class SimpleEntry<K,V> implements Map.Entry<K,V> {
	K key;
	V value;

	public SimpleEntry(K key, V value) {
	    this.key   = key;
            this.value = value;
	}

	public SimpleEntry(Map.Entry<K,V> e) {
	    this.key   = e.getKey();
            this.value = e.getValue();
	}

	public K getKey() {
	    return key;
	}

	public V getValue() {
	    return value;
	}

	public V setValue(V value) {
	    V oldValue = this.value;
	    this.value = value;
	    return oldValue;
	}

	public boolean equals(Object o) {
	    if (!(o instanceof Map.Entry))
		return false;
	    Map.Entry e = (Map.Entry)o;
	    return eq(key, e.getKey()) && eq(value, e.getValue());
	}

	public int hashCode() {
	    return ((key   == null)   ? 0 :   key.hashCode()) ^
		   ((value == null)   ? 0 : value.hashCode());
	}

	public String toString() {
	    return key + "=" + value;
	}

        private static boolean eq(Object o1, Object o2) {
            return (o1 == null ? o2 == null : o1.equals(o2));
        }
    }
}