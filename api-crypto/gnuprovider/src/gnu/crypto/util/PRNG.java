package gnu.crypto.util;

// ----------------------------------------------------------------------------
// $Id: PRNG.java,v 1.10 2007/05/24 06:40:38 serdar Exp $
//
// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
//
// This file is part of GNU Crypto.
//
// GNU Crypto is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2, or (at your option)
// any later version.
//
// GNU Crypto is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; see the file COPYING.  If not, write to the
//
//    Free Software Foundation Inc.,
//    59 Temple Place - Suite 330,
//    Boston, MA 02111-1307
//    USA
//
// Linking this library statically or dynamically with other modules is
// making a combined work based on this library.  Thus, the terms and
// conditions of the GNU General Public License cover the whole
// combination.
//
// As a special exception, the copyright holders of this library give
// you permission to link this library with independent modules to
// produce an executable, regardless of the license terms of these
// independent modules, and to copy and distribute the resulting
// executable under terms of your choice, provided that you also meet,
// for each linked independent module, the terms and conditions of the
// license of that module.  An independent module is a module which is
// not derived from or based on this library.  If you modify this
// library, you may extend this exception to your version of the
// library, but you are not obligated to do so.  If you do not wish to
// do so, delete this exception statement from your version.
// ----------------------------------------------------------------------------

import gnu.crypto.Registry;
import gnu.crypto.prng.PRNGFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import tr.gov.tubitak.uekae.esya.api.common.crypto.IRandom;
import tr.gov.tubitak.uekae.esya.api.common.crypto.LimitReachedException;



/**
 * <p>A useful Singleton hash-based (SHA) pseudo-random number generator used
 * throughout this library.</p>
 * @version $Revision: 1.10 $
 * @see gnu.crypto.prng.MDGenerator
 */
public class PRNG
{
    private static final Logger logger = LoggerFactory.getLogger(PRNG.class);

    // Constants and variables
    // -------------------------------------------------------------------------
    private static IRandom singleton;
    private static final long maxRandCount = 22 * 1000 * 1000; // bir seed ile alinacak en fazla random byte miktari
    private static long curRandCount = 0;
    //TODO delete later on
    static  int murat =0;

    static
    {
        setDefaultPRNG();
    }

//    private static void initSingleton()
//    {
//        HashMap<String, Object> map = new HashMap<String, Object>();
//        map.put("SEED_GENERATOR", new MemorySeed());
//        singleton.init(map); 
//        curRandCount = 0;
//    }

    public static void setDefaultPRNG()
    {
        randBuffer = new byte[0];
        randBufferRemain = new byte[0];
        randBufferIndex = 0;

        try
        {
            singleton = PRNGFactory.getInstance(Registry.UEKAE_CRYPTO_CARD_PRNG);
            //singleton.init(null); // Zeldal: init was missing....
        }
        catch(Throwable aEx)
        {
            logger.debug("UEKAE Crypto Card does not exist:" + aEx.getMessage());
            singleton = PRNGFactory.getInstance(Registry.DGKGF_PRNG);
            //initSingleton();
        }

        singleton.init(null);
    }

    public static void setPRNG(IRandom aRandomGenerator)
    {
	    singleton = aRandomGenerator;
        randBuffer = new byte[0];
        randBufferRemain = new byte[0];
        randBufferIndex = 0;
    }

    // Constructor(s)
    // -------------------------------------------------------------------------

    /**
     * Trivial constructor to enforce Singleton pattern.
     */
    private PRNG()
    {
        super();
    }

    // Class methods
    // -------------------------------------------------------------------------

    /**
     * <p>Completely fills the designated <code>aBuffer</code> with random data
     * generated by the underlying singleton.</p>
     * @param aBuffer the place holder of random bytes generated by this PRNG
     *               singleton. On output, the contents of <code>aBuffer</code> are replaced
     *               with pseudo-random data, iff the <code>aBuffer</code> size is not zero.
     */
    public static synchronized void nextBytes(byte[] aBuffer)
    {
        if(singleton.isUseTRSU()){
            nextBytes(aBuffer, 0, aBuffer.length);
        }else{
            nextBytesWithoutTRSU(aBuffer, 0, aBuffer.length);
        }

    }


    private static byte[] randBuffer = new byte[0];
    private static byte[] randBufferRemain = new byte[0];
    private static int randBufferIndex = 0;

    public static synchronized void nextBytesWithoutTRSU(byte[] buffer, int offset, int length){
        int len = 0;
        while (true) {
            while ((randBufferIndex < randBuffer.length) && (len < length))
                buffer[offset + (len++)] = randBuffer[randBufferIndex++];
            if (len >= length)
                return;
            if (randBufferIndex >= randBuffer.length) {
                try {
                    randBuffer = _nextKaynakBytes();
                    if ((randBuffer == null) || (randBuffer.length <= 0))
                        throw new RuntimeException("Olmaz boyle bir sey");
                    randBufferIndex = 0;
                }
                catch (Exception ex) {
                    throw new RuntimeException("Error while Filling PRNG Buffer:"+ex.getMessage(), ex);
                }
            }
        }
    }


    /**
     * <p>Fills the designated <code>buffer</code>, starting from byte at
     * position <code>offset</code> with, at most, <code>length</code> bytes of
     * random data generated by the underlying singleton.</p>
     * @see tr.gov.tubitak.uekae.esya.api.common.crypto.IRandom#nextBytes
     */
    public static synchronized void nextBytes(byte[] buffer, int offset, int length)
    {
        int len = 0;
        while (true) {
            while ((randBufferIndex < randBuffer.length) && (len < length))
            {

                //it was done due to meet the requirements of crypto analysis
                //buffer[offset + (len++)] = randBuffer[randBufferIndex++];
                buffer[offset + (len++)] = randBuffer[randBufferIndex];
                randBuffer[randBufferIndex++] = (byte) 0xCC;
            }
            if (len >= length)
                return;
            if (randBufferIndex >= randBuffer.length) {
                try {
                    randBuffer = _nextKaynakBytes();
                    if ((randBuffer == null) || (randBuffer.length <= 0))
                        throw new RuntimeException("Olmaz boyle bir sey");

                    // trsu related
                    if ((randBufferRemain != null) && (randBufferRemain.length > 0)) {
                        // onceden artan veri varsa concat et
                        randBuffer = TRSUYardimci.concat(randBufferRemain, randBuffer);
                    }

                    TRSUYardimci yardimci = TRSUYardimci.getInstance();
                    // ticarilestirme prosesi
                    TRSUYardimci.RandomSonuc sonuc = yardimci.ticarilestir(randBuffer);
                    // yeni artan, bir dahaki sefere kullanilacak
                    randBufferRemain = sonuc.getmKalan();
                    randBuffer = sonuc.getmSonuc();

                    //randBufferLen = randBuffer.length;
                    randBufferIndex = 0;
                }
                catch (Exception ex) {
                    throw new RuntimeException("Error while Filling PRNG Buffer:"+ex.getMessage(), ex);
                }
            }
        }
    }

    public static void setKaynakUretimUzunluk(int uzunluk){
        //if(uzunluk>MINIMUM_KAYNAK_URETIM_UZUNLUK)
            kaynakUretimUzunluk = uzunluk;
        /*else
            kaynakUretimUzunluk = MINIMUM_KAYNAK_URETIM_UZUNLUK;*/
    }

    private static int MINIMUM_KAYNAK_URETIM_UZUNLUK = 2048;
    private static int kaynakUretimUzunluk = MINIMUM_KAYNAK_URETIM_UZUNLUK;

    private static byte[] _nextKaynakBytes() throws Exception
    {
    	 byte[] buffer = new byte[kaynakUretimUzunluk];
    	
            try {
                singleton.nextBytes(buffer, 0, kaynakUretimUzunluk);
//                curRandCount = curRandCount + kaynakUretimUzunluk;
//                if (cuÃ¶rRandCount > maxRandCount) {
//                    initSingleton();
//                }
            }
            catch (LimitReachedException x) { // re-initialise
                try {
//                    initSingleton();
                    singleton.nextBytes(buffer, 0, kaynakUretimUzunluk);
                }
                catch (Exception y) {
                    throw new ExceptionInInitializerError(y);
                }
            }
            
            return buffer;
        }


    public static void main(String[] args)
    {
//        byte[] r = new byte[32];
//        nextBytes(r);
//        TRSUYardimci.yazdir("",r);
//        nextBytes(r);
//        TRSUYardimci.yazdir("",r);
//        nextBytes(r);
//        TRSUYardimci.yazdir("",r);
//		mSC = new SmartCard(aCardType);
//		mSessionId = mSC.openSession(aSlot);
//        Map<String, Object> options = new HashMap<String, Object>();
//        KeyPair kp;
//        IKeyPairGenerator kpg;
//        kpg = KeyPairGeneratorFactory.getInstance(Registry.RSA_KPG);
//        options.put(RSAKeyPairGenerator.MODULUS_LENGTH, 2048);
//        options.put(RSAKeyPairGenerator.SOURCE_OF_RANDOMNESS, null);
//        kpg.setup(options);
//        kp = kpg.generate();
//        System.out.println(Arrays.toString((kp.getPrivate().getEncoded())));
        
    }

}

