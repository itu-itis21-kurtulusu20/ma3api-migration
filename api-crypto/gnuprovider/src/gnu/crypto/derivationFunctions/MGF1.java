package gnu.crypto.derivationFunctions;

import gnu.crypto.hash.IMessageDigest;


/**
 * <p>A mask generation function takes an octet string of variable length
 * and a desired output length as input, and outputs an octet string of the
 * desired length. There may be restrictions on the length of the input and
 * output octet strings, but such bounds are generally very large. Mask
 * generation functions are deterministic; the octet string output is
 * completely determined by the input octet string. The output of a mask
 * generation function should be pseudorandom, that is, it should be
 * infeasible to predict, given one part of the output but not the input,
 * another part of the output.</p>
 * @author orcun.ertugrul
 *
 */

public class MGF1 implements  DerivationFunction
{
	
	IMessageDigest hash;
	byte [] seed;
	
	/**
	 * @param hash the hash to be used as the source of generated bytes
	 */
	public MGF1(IMessageDigest hash)
	{
		this.hash = hash;
	}

	public void init(byte [] seed, DerivationFuncParams params)
	{
		this.seed = seed;
	}
	
	
	public byte[] generateBytes(int len) {
		int hLen = hash.hashSize();
		// 1. If l > (2**32).hLen, output 'mask too long' and stop.
		if (len < 1 || (len & 0xFFFFFFFFL) > ((hLen & 0xFFFFFFFFL) << 32L)) {
			throw new IllegalArgumentException("mask too long");
		}
		// 2. Let T be the empty octet string.
		byte[] result = new byte[len];
		// 3. For i = 0 to CEILING(l/hLen) ? 1, do
		int limit = ((len + hLen - 1) / hLen);
		
		IMessageDigest hashZ = null;
		hashZ = (IMessageDigest) hash.clone();
		hashZ.digest();
		hashZ.update(seed, 0, seed.length);
		
		IMessageDigest hashZC = null;
		byte[] t;
		int sofar = 0;
		int length;
		int i;
		byte[] C = new byte[4];
		for (i = 0; i < limit; i++) {
			//    3.1 Convert i to an octet string C of length 4 with the primitive
			//        I2OSP: C = I2OSP(i, 4).
			//    3.2 Concatenate the hash of the seed Z and C to the octet string T:
			//        T = T || Hash(Z || C)
			hashZC = (IMessageDigest) hashZ.clone();
			
			ItoOSP(i, C);
			hashZC.update(C, 0, C.length);

			t = hashZC.digest();
			length = len - sofar;
			length = (length > hLen ? hLen : length);
			System.arraycopy(t, 0, result, sofar, length);
			sofar += length;
		}
		if(sofar<len)
		{
			hashZC = (IMessageDigest) hash.clone();
			ItoOSP(i, C);
			hashZC.update(C, 0, C.length);
			t = hashZC.digest();
			System.arraycopy(t, 0, result, sofar, len-sofar);
		}
		// 4. Output the leading l octets of T as the octet string mask.
		return result;
	}
	
	private void ItoOSP(int i,byte[]  sp)
	{
		 sp[0] = (byte)(i >>> 24);
		 sp[1] = (byte)(i >>> 16);
		 sp[2] = (byte)(i >>> 8);
		 sp[3] = (byte)(i >>> 0);
	}
	
	
	static public byte[] generateBytes(byte[] seed, int l, IMessageDigest hash) {
		MGF1 maskGenerator = new MGF1(hash);
		maskGenerator.init(seed, null);
		return maskGenerator.generateBytes(l);
	}

}
