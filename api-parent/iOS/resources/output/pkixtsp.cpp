/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.6, Date: 20-Feb-2014.
 */
#include <new>
#include "pkixtsp.h"
#include "rtxsrc/rtxCommon.h"

ASN1OBJID TSP_id_ct_TSTInfo = {
   9,
   { 1, 2, 840, 113549, 1, 9, 16, 1, 4 }
} ;
ASN1OBJID TSP_id_esya_ts_reqex = {
   10,
   { 1, 3, 6, 1, 4, 1, 11311, 10, 2, 1 }
} ;
ASN1OBJID TSP_id_ts_policy = {
   11,
   { 2, 16, 792, 1, 2, 1, 1, 5, 7, 3, 1 }
} ;

ASN1T_TSP_BIGINTEGER* new_ASN1T_TSP_BIGINTEGER (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_TSP_BIGINTEGER));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_TSP_BIGINTEGER;
}

ASN1C_TSP_BIGINTEGER::ASN1C_TSP_BIGINTEGER (ASN1T_TSP_BIGINTEGER& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_TSP_BIGINTEGER::ASN1C_TSP_BIGINTEGER (OSRTMessageBufferIF& msgBuf
   , ASN1T_TSP_BIGINTEGER& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_TSP_BIGINTEGER::ASN1C_TSP_BIGINTEGER (OSRTContext &context
   , ASN1T_TSP_BIGINTEGER& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_TSP_BIGINTEGER::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_TSP_BIGINTEGER (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_TSP_BIGINTEGER::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_TSP_BIGINTEGER (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

ASN1T_TSP_TSAPolicyId* new_ASN1T_TSP_TSAPolicyId (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_TSP_TSAPolicyId));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_TSP_TSAPolicyId;
}

ASN1C_TSP_TSAPolicyId::ASN1C_TSP_TSAPolicyId (ASN1T_TSP_TSAPolicyId& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_TSP_TSAPolicyId::ASN1C_TSP_TSAPolicyId (OSRTMessageBufferIF& msgBuf
   , ASN1T_TSP_TSAPolicyId& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_TSP_TSAPolicyId::ASN1C_TSP_TSAPolicyId (OSRTContext &context
   , ASN1T_TSP_TSAPolicyId& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_TSP_TSAPolicyId::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_TSP_TSAPolicyId (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_TSP_TSAPolicyId::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_TSP_TSAPolicyId (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_TSP_TSAPolicyId (ASN1T_TSP_TSAPolicyId* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_TSP_TSAPolicyId;
}

ASN1T_TSP_PKIStatus* new_ASN1T_TSP_PKIStatus (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_TSP_PKIStatus));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_TSP_PKIStatus;
}

ASN1C_TSP_PKIStatus::ASN1C_TSP_PKIStatus (ASN1T_TSP_PKIStatus& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_TSP_PKIStatus::ASN1C_TSP_PKIStatus (OSRTMessageBufferIF& msgBuf
   , ASN1T_TSP_PKIStatus& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_TSP_PKIStatus::ASN1C_TSP_PKIStatus (OSRTContext &context
   , ASN1T_TSP_PKIStatus& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_TSP_PKIStatus::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_TSP_PKIStatus (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_TSP_PKIStatus::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_TSP_PKIStatus (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

ASN1T_TSP_PKIFailureInfo* new_ASN1T_TSP_PKIFailureInfo (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_TSP_PKIFailureInfo));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_TSP_PKIFailureInfo;
}

ASN1C_TSP_PKIFailureInfo::ASN1C_TSP_PKIFailureInfo
    (ASN1T_TSP_PKIFailureInfo& data) : ASN1CBitStr (data.data, data.numbits, 32
   ), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_TSP_PKIFailureInfo::ASN1C_TSP_PKIFailureInfo (OSRTMessageBufferIF& msgBuf
   , ASN1T_TSP_PKIFailureInfo& data) : ASN1CBitStr (msgBuf, data.data, 
   data.numbits, 32), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_TSP_PKIFailureInfo::ASN1C_TSP_PKIFailureInfo (OSRTContext &context
   , ASN1T_TSP_PKIFailureInfo& data) : ASN1CBitStr (context, data.data, 
   data.numbits, 32), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_TSP_PKIFailureInfo::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_TSP_PKIFailureInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_TSP_PKIFailureInfo::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_TSP_PKIFailureInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_TSP_PKIFailureInfo (ASN1T_TSP_PKIFailureInfo* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_TSP_PKIFailureInfo;
}

ASN1T_TSP_TimeStampToken* new_ASN1T_TSP_TimeStampToken (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_TSP_TimeStampToken));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_TSP_TimeStampToken;
}

ASN1C_TSP_TimeStampToken::ASN1C_TSP_TimeStampToken
    (ASN1T_TSP_TimeStampToken& data) : ASN1C_CMS_ContentInfo (data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_TSP_TimeStampToken::ASN1C_TSP_TimeStampToken (OSRTMessageBufferIF& msgBuf
   , ASN1T_TSP_TimeStampToken& data) : ASN1C_CMS_ContentInfo (msgBuf, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_TSP_TimeStampToken::ASN1C_TSP_TimeStampToken (OSRTContext &context
   , ASN1T_TSP_TimeStampToken& data) : ASN1C_CMS_ContentInfo (context, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_TSP_TimeStampToken::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_TSP_TimeStampToken (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_TSP_TimeStampToken::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_TSP_TimeStampToken;
   msgData.setContext (msgBuf.getContext());
   return asn1D_TSP_TimeStampToken (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_TSP_TimeStampToken (ASN1T_TSP_TimeStampToken* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_TSP_TimeStampToken;
}

void asn1Free_TSP_TimeStampToken (OSCTXT *pctxt, 
   ASN1T_TSP_TimeStampToken* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_CMS_ContentInfo (pctxt, pvalue);
}

void ASN1C_TSP_TimeStampToken::MemFree ()
{
   asn1Free_TSP_TimeStampToken (getCtxtPtr(), &msgData);
}

ASN1T_TSP_TimeStampReq_version* 
   new_ASN1T_TSP_TimeStampReq_version (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_TSP_TimeStampReq_version));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_TSP_TimeStampReq_version;
}

ASN1C_TSP_TimeStampReq_version::ASN1C_TSP_TimeStampReq_version
    (ASN1T_TSP_TimeStampReq_version& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_TSP_TimeStampReq_version::ASN1C_TSP_TimeStampReq_version (
   OSRTMessageBufferIF& msgBuf, ASN1T_TSP_TimeStampReq_version& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_TSP_TimeStampReq_version::ASN1C_TSP_TimeStampReq_version (
   OSRTContext &context, ASN1T_TSP_TimeStampReq_version& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_TSP_TimeStampReq_version::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_TSP_TimeStampReq_version (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_TSP_TimeStampReq_version::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_TSP_TimeStampReq_version (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

ASN1T_TSP_TSTInfo_version* new_ASN1T_TSP_TSTInfo_version (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_TSP_TSTInfo_version));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_TSP_TSTInfo_version;
}

ASN1C_TSP_TSTInfo_version::ASN1C_TSP_TSTInfo_version
    (ASN1T_TSP_TSTInfo_version& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_TSP_TSTInfo_version::ASN1C_TSP_TSTInfo_version (
   OSRTMessageBufferIF& msgBuf, ASN1T_TSP_TSTInfo_version& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_TSP_TSTInfo_version::ASN1C_TSP_TSTInfo_version (OSRTContext &context
   , ASN1T_TSP_TSTInfo_version& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_TSP_TSTInfo_version::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_TSP_TSTInfo_version (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_TSP_TSTInfo_version::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_TSP_TSTInfo_version (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

ASN1T_TSP_MessageImprint* new_ASN1T_TSP_MessageImprint (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_TSP_MessageImprint));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_TSP_MessageImprint;
}

ASN1C_TSP_MessageImprint::ASN1C_TSP_MessageImprint
    (ASN1T_TSP_MessageImprint& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_TSP_MessageImprint::ASN1C_TSP_MessageImprint (OSRTMessageBufferIF& msgBuf
   , ASN1T_TSP_MessageImprint& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_TSP_MessageImprint::ASN1C_TSP_MessageImprint (OSRTContext &context
   , ASN1T_TSP_MessageImprint& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_TSP_MessageImprint::ASN1T_TSP_MessageImprint ()
{
}

ASN1T_TSP_MessageImprint::~ASN1T_TSP_MessageImprint ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_TSP_MessageImprint (pctxt, this);
   }
}

int ASN1C_TSP_MessageImprint::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_TSP_MessageImprint (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_TSP_MessageImprint::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_TSP_MessageImprint;
   msgData.setContext (msgBuf.getContext());
   return asn1D_TSP_MessageImprint (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_TSP_MessageImprint (ASN1T_TSP_MessageImprint* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_TSP_MessageImprint;
}

void asn1Free_TSP_MessageImprint (OSCTXT *pctxt, 
   ASN1T_TSP_MessageImprint* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_EXP_AlgorithmIdentifier (pctxt, &pvalue->hashAlgorithm);
   if (pvalue->hashedMessage.numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->hashedMessage.data);
      pvalue->hashedMessage.numocts = 0;
      pvalue->hashedMessage.data = 0;
   }
}

void ASN1C_TSP_MessageImprint::MemFree ()
{
   asn1Free_TSP_MessageImprint (getCtxtPtr(), &msgData);
}

ASN1T_TSP_TimeStampReq* new_ASN1T_TSP_TimeStampReq (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_TSP_TimeStampReq));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_TSP_TimeStampReq;
}

ASN1C_TSP_TimeStampReq::ASN1C_TSP_TimeStampReq (ASN1T_TSP_TimeStampReq& data)
    : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_TSP_TimeStampReq::ASN1C_TSP_TimeStampReq (OSRTMessageBufferIF& msgBuf
   , ASN1T_TSP_TimeStampReq& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_TSP_TimeStampReq::ASN1C_TSP_TimeStampReq (OSRTContext &context
   , ASN1T_TSP_TimeStampReq& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_TSP_TimeStampReq::ASN1T_TSP_TimeStampReq ()
{
   m.reqPolicyPresent = 0;
   m.noncePresent = 0;
   certReq = FALSE;
   m.extensionsPresent = 0;
}

ASN1T_TSP_TimeStampReq::~ASN1T_TSP_TimeStampReq ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_TSP_TimeStampReq (pctxt, this);
   }
}

int ASN1C_TSP_TimeStampReq::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_TSP_TimeStampReq (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_TSP_TimeStampReq::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_TSP_TimeStampReq;
   msgData.setContext (msgBuf.getContext());
   return asn1D_TSP_TimeStampReq (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_TSP_TimeStampReq (ASN1T_TSP_TimeStampReq* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_TSP_TimeStampReq;
}

void asn1Free_TSP_TimeStampReq (OSCTXT *pctxt, ASN1T_TSP_TimeStampReq* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_TSP_MessageImprint (pctxt, &pvalue->messageImprint);
   if (pvalue->m.extensionsPresent) {
      asn1Free_EXP_Extensions (pctxt, &pvalue->extensions);
   }
}

void ASN1C_TSP_TimeStampReq::MemFree ()
{
   asn1Free_TSP_TimeStampReq (getCtxtPtr(), &msgData);
}

ASN1T_TSP_PKIStatusInfo* new_ASN1T_TSP_PKIStatusInfo (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_TSP_PKIStatusInfo));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_TSP_PKIStatusInfo;
}

ASN1C_TSP_PKIStatusInfo::ASN1C_TSP_PKIStatusInfo
    (ASN1T_TSP_PKIStatusInfo& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_TSP_PKIStatusInfo::ASN1C_TSP_PKIStatusInfo (OSRTMessageBufferIF& msgBuf
   , ASN1T_TSP_PKIStatusInfo& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_TSP_PKIStatusInfo::ASN1C_TSP_PKIStatusInfo (OSRTContext &context
   , ASN1T_TSP_PKIStatusInfo& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_TSP_PKIStatusInfo::ASN1T_TSP_PKIStatusInfo ()
{
   m.statusStringPresent = 0;
   m.failInfoPresent = 0;
}

ASN1T_TSP_PKIStatusInfo::~ASN1T_TSP_PKIStatusInfo ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_TSP_PKIStatusInfo (pctxt, this);
   }
}

int ASN1C_TSP_PKIStatusInfo::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_TSP_PKIStatusInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_TSP_PKIStatusInfo::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_TSP_PKIStatusInfo;
   msgData.setContext (msgBuf.getContext());
   return asn1D_TSP_PKIStatusInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_TSP_PKIStatusInfo (ASN1T_TSP_PKIStatusInfo* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_TSP_PKIStatusInfo;
}

void asn1Free_TSP_PKIStatusInfo (OSCTXT *pctxt, 
   ASN1T_TSP_PKIStatusInfo* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.statusStringPresent) {
      asn1Free_CMP_PKIFreeText (pctxt, &pvalue->statusString);
   }
}

void ASN1C_TSP_PKIStatusInfo::MemFree ()
{
   asn1Free_TSP_PKIStatusInfo (getCtxtPtr(), &msgData);
}

ASN1T_TSP_TimeStampResp* new_ASN1T_TSP_TimeStampResp (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_TSP_TimeStampResp));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_TSP_TimeStampResp;
}

ASN1C_TSP_TimeStampResp::ASN1C_TSP_TimeStampResp
    (ASN1T_TSP_TimeStampResp& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_TSP_TimeStampResp::ASN1C_TSP_TimeStampResp (OSRTMessageBufferIF& msgBuf
   , ASN1T_TSP_TimeStampResp& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_TSP_TimeStampResp::ASN1C_TSP_TimeStampResp (OSRTContext &context
   , ASN1T_TSP_TimeStampResp& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_TSP_TimeStampResp::ASN1T_TSP_TimeStampResp ()
{
   m.timeStampTokenPresent = 0;
}

ASN1T_TSP_TimeStampResp::~ASN1T_TSP_TimeStampResp ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_TSP_TimeStampResp (pctxt, this);
   }
}

int ASN1C_TSP_TimeStampResp::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_TSP_TimeStampResp (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_TSP_TimeStampResp::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_TSP_TimeStampResp;
   msgData.setContext (msgBuf.getContext());
   return asn1D_TSP_TimeStampResp (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_TSP_TimeStampResp (ASN1T_TSP_TimeStampResp* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_TSP_TimeStampResp;
}

void asn1Free_TSP_TimeStampResp (OSCTXT *pctxt, 
   ASN1T_TSP_TimeStampResp* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_TSP_PKIStatusInfo (pctxt, &pvalue->status);
   if (pvalue->m.timeStampTokenPresent) {
      asn1Free_TSP_TimeStampToken (pctxt, &pvalue->timeStampToken);
   }
}

void ASN1C_TSP_TimeStampResp::MemFree ()
{
   asn1Free_TSP_TimeStampResp (getCtxtPtr(), &msgData);
}

ASN1T_TSP_Accuracy* new_ASN1T_TSP_Accuracy (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_TSP_Accuracy));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_TSP_Accuracy;
}

ASN1C_TSP_Accuracy::ASN1C_TSP_Accuracy (ASN1T_TSP_Accuracy& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_TSP_Accuracy::ASN1C_TSP_Accuracy (OSRTMessageBufferIF& msgBuf
   , ASN1T_TSP_Accuracy& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_TSP_Accuracy::ASN1C_TSP_Accuracy (OSRTContext &context
   , ASN1T_TSP_Accuracy& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_TSP_Accuracy::ASN1T_TSP_Accuracy ()
{
   m.secondsPresent = 0;
   m.millisPresent = 0;
   m.microsPresent = 0;
}

int ASN1C_TSP_Accuracy::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_TSP_Accuracy (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_TSP_Accuracy::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_TSP_Accuracy;
   msgData.setContext (msgBuf.getContext());
   return asn1D_TSP_Accuracy (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_TSP_Accuracy (ASN1T_TSP_Accuracy* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_TSP_Accuracy;
}

ASN1T_TSP_TSTInfo* new_ASN1T_TSP_TSTInfo (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_TSP_TSTInfo));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_TSP_TSTInfo;
}

ASN1C_TSP_TSTInfo::ASN1C_TSP_TSTInfo (ASN1T_TSP_TSTInfo& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_TSP_TSTInfo::ASN1C_TSP_TSTInfo (OSRTMessageBufferIF& msgBuf
   , ASN1T_TSP_TSTInfo& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_TSP_TSTInfo::ASN1C_TSP_TSTInfo (OSRTContext &context
   , ASN1T_TSP_TSTInfo& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_TSP_TSTInfo::ASN1T_TSP_TSTInfo ()
{
   genTime = 0;
   m.accuracyPresent = 0;
   ordering = FALSE;
   m.noncePresent = 0;
   m.tsaPresent = 0;
   m.extensionsPresent = 0;
}

ASN1T_TSP_TSTInfo::~ASN1T_TSP_TSTInfo ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_TSP_TSTInfo (pctxt, this);
   }
}

int ASN1C_TSP_TSTInfo::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_TSP_TSTInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_TSP_TSTInfo::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_TSP_TSTInfo;
   msgData.setContext (msgBuf.getContext());
   return asn1D_TSP_TSTInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_TSP_TSTInfo (ASN1T_TSP_TSTInfo* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_TSP_TSTInfo;
}

void asn1Free_TSP_TSTInfo (OSCTXT *pctxt, ASN1T_TSP_TSTInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_TSP_MessageImprint (pctxt, &pvalue->messageImprint);
   rtxMemFreePtr (pctxt, (void*)pvalue->genTime);
   if (pvalue->m.tsaPresent) {
      asn1Free_IMP_GeneralName (pctxt, &pvalue->tsa);
   }
   if (pvalue->m.extensionsPresent) {
      asn1Free_EXP_Extensions (pctxt, &pvalue->extensions);
   }
}

void ASN1C_TSP_TSTInfo::MemFree ()
{
   asn1Free_TSP_TSTInfo (getCtxtPtr(), &msgData);
}

ASN1T_TSP_ESYAReqEx* new_ASN1T_TSP_ESYAReqEx (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_TSP_ESYAReqEx));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_TSP_ESYAReqEx;
}

ASN1C_TSP_ESYAReqEx::ASN1C_TSP_ESYAReqEx (ASN1T_TSP_ESYAReqEx& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_TSP_ESYAReqEx::ASN1C_TSP_ESYAReqEx (OSRTMessageBufferIF& msgBuf
   , ASN1T_TSP_ESYAReqEx& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_TSP_ESYAReqEx::ASN1C_TSP_ESYAReqEx (OSRTContext &context
   , ASN1T_TSP_ESYAReqEx& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_TSP_ESYAReqEx::ASN1T_TSP_ESYAReqEx ()
{
}

ASN1T_TSP_ESYAReqEx::~ASN1T_TSP_ESYAReqEx ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_TSP_ESYAReqEx (pctxt, this);
   }
}

int ASN1C_TSP_ESYAReqEx::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_TSP_ESYAReqEx (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_TSP_ESYAReqEx::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_TSP_ESYAReqEx;
   msgData.setContext (msgBuf.getContext());
   return asn1D_TSP_ESYAReqEx (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_TSP_ESYAReqEx (ASN1T_TSP_ESYAReqEx* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_TSP_ESYAReqEx;
}

void asn1Free_TSP_ESYAReqEx (OSCTXT *pctxt, ASN1T_TSP_ESYAReqEx* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->salt.numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->salt.data);
      pvalue->salt.numocts = 0;
      pvalue->salt.data = 0;
   }
   if (pvalue->iv.numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->iv.data);
      pvalue->iv.numocts = 0;
      pvalue->iv.data = 0;
   }
   if (pvalue->encryptedMessageImprint.numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->encryptedMessageImprint.data);
      pvalue->encryptedMessageImprint.numocts = 0;
      pvalue->encryptedMessageImprint.data = 0;
   }
}

void ASN1C_TSP_ESYAReqEx::MemFree ()
{
   asn1Free_TSP_ESYAReqEx (getCtxtPtr(), &msgData);
}

