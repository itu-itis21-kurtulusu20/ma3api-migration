/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.6, Date: 20-Feb-2014.
 */
#include "crmf.h"
#include "rtsrc/rtPrintToStream.h"
#include "rtxsrc/rtxCommon.h"

int asn1PrtToStrm_CRMF_SubsequentMessage (OSCTXT *pctxt, 
   const char* name, const ASN1T_CRMF_SubsequentMessage* pvalue)
{
   {
      char namebuf[512];
      OSBOOL printNamebuf = TRUE;

      rtPrintToStreamIndent (pctxt);
      rtxStrcpy (namebuf, 512, name);
      rtxStrcat (namebuf, 512, " = ");
      switch (*pvalue) {
         case 0: rtxStrcat (namebuf, 512, "encrCert\n");break;
         case 1: rtxStrcat (namebuf, 512, "challengeResp\n");break;
         default:
            rtPrintToStreamInteger (pctxt, name, *pvalue);
            printNamebuf = FALSE;
      }

      if (printNamebuf) rtxPrintToStream (pctxt, namebuf);
   }
   return 0;
}

int ASN1C_CRMF_SubsequentMessage::toStream (const char* name)

{
   asn1PrtToStrm_CRMF_SubsequentMessage (getCtxtPtr(), name, &msgData);
   return 0;
}

int ASN1C_CRMF_SubsequentMessage::setPrintStream
(rtxPrintCallback strmCallback, void * pStrmInfo)

{
   return rtxSetPrintStream (getCtxtPtr(), strmCallback, pStrmInfo);
}

int asn1PrtToStrm_CRMF_PKIPublicationInfo_action (OSCTXT *pctxt, 
   const char* name, const ASN1T_CRMF_PKIPublicationInfo_action* pvalue)
{
   {
      char namebuf[512];
      OSBOOL printNamebuf = TRUE;

      rtPrintToStreamIndent (pctxt);
      rtxStrcpy (namebuf, 512, name);
      rtxStrcat (namebuf, 512, " = ");
      switch (*pvalue) {
         case 0: rtxStrcat (namebuf, 512, "dontPublish\n");break;
         case 1: rtxStrcat (namebuf, 512, "pleasePublish\n");break;
         default:
            rtPrintToStreamInteger (pctxt, name, *pvalue);
            printNamebuf = FALSE;
      }

      if (printNamebuf) rtxPrintToStream (pctxt, namebuf);
   }
   return 0;
}

int ASN1C_CRMF_PKIPublicationInfo_action::toStream (const char* name)

{
   asn1PrtToStrm_CRMF_PKIPublicationInfo_action (getCtxtPtr(), name, &msgData);
   return 0;
}

int ASN1C_CRMF_PKIPublicationInfo_action::setPrintStream
(rtxPrintCallback strmCallback, void * pStrmInfo)

{
   return rtxSetPrintStream (getCtxtPtr(), strmCallback, pStrmInfo);
}

int asn1PrtToStrm_CRMF_SinglePubInfo_pubMethod (OSCTXT *pctxt, 
   const char* name, const ASN1T_CRMF_SinglePubInfo_pubMethod* pvalue)
{
   {
      char namebuf[512];
      OSBOOL printNamebuf = TRUE;

      rtPrintToStreamIndent (pctxt);
      rtxStrcpy (namebuf, 512, name);
      rtxStrcat (namebuf, 512, " = ");
      switch (*pvalue) {
         case 0: rtxStrcat (namebuf, 512, "dontCare\n");break;
         case 1: rtxStrcat (namebuf, 512, "x500\n");break;
         case 2: rtxStrcat (namebuf, 512, "web\n");break;
         case 3: rtxStrcat (namebuf, 512, "ldap\n");break;
         default:
            rtPrintToStreamInteger (pctxt, name, *pvalue);
            printNamebuf = FALSE;
      }

      if (printNamebuf) rtxPrintToStream (pctxt, namebuf);
   }
   return 0;
}

int ASN1C_CRMF_SinglePubInfo_pubMethod::toStream (const char* name)

{
   asn1PrtToStrm_CRMF_SinglePubInfo_pubMethod (getCtxtPtr(), name, &msgData);
   return 0;
}

int ASN1C_CRMF_SinglePubInfo_pubMethod::setPrintStream
(rtxPrintCallback strmCallback, void * pStrmInfo)

{
   return rtxSetPrintStream (getCtxtPtr(), strmCallback, pStrmInfo);
}

int asn1PrtToStrm_CRMF_OptionalValidity (OSCTXT *pctxt, 
   const char* name, const ASN1T_CRMF_OptionalValidity* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.notBeforePresent) {
      asn1PrtToStrm_EXP_Time (pctxt, "notBefore", &pvalue->notBefore);
   }

   if (pvalue->m.notAfterPresent) {
      asn1PrtToStrm_EXP_Time (pctxt, "notAfter", &pvalue->notAfter);
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int ASN1C_CRMF_OptionalValidity::toStream (const char* name)

{
   asn1PrtToStrm_CRMF_OptionalValidity (getCtxtPtr(), name, &msgData);
   return 0;
}

int ASN1C_CRMF_OptionalValidity::setPrintStream
(rtxPrintCallback strmCallback, void * pStrmInfo)

{
   return rtxSetPrintStream (getCtxtPtr(), strmCallback, pStrmInfo);
}

int asn1PrtToStrm_CRMF_CertTemplate (OSCTXT *pctxt, 
   const char* name, const ASN1T_CRMF_CertTemplate* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.versionPresent) {
      asn1PrtToStrm_EXP_Version (pctxt, "version", &pvalue->version);
   }

   if (pvalue->m.serialNumberPresent) {
      asn1PrtToStrm_EXP_CertificateSerialNumber (pctxt, "serialNumber", &pvalue->serialNumber);
   }

   if (pvalue->m.signingAlgPresent) {
      asn1PrtToStrm_EXP_AlgorithmIdentifier (pctxt, "signingAlg", &pvalue->signingAlg);
   }

   if (pvalue->m.issuerPresent) {
      asn1PrtToStrm_EXP_Name (pctxt, "issuer", &pvalue->issuer);
   }

   if (pvalue->m.validityPresent) {
      asn1PrtToStrm_CRMF_OptionalValidity (pctxt, "validity", &pvalue->validity);
   }

   if (pvalue->m.subjectPresent) {
      asn1PrtToStrm_EXP_Name (pctxt, "subject", &pvalue->subject);
   }

   if (pvalue->m.publicKeyPresent) {
      asn1PrtToStrm_EXP_SubjectPublicKeyInfo (pctxt, "publicKey", &pvalue->publicKey);
   }

   if (pvalue->m.issuerUIDPresent) {
      asn1PrtToStrm_EXP_UniqueIdentifier (pctxt, "issuerUID", &pvalue->issuerUID);
   }

   if (pvalue->m.subjectUIDPresent) {
      asn1PrtToStrm_EXP_UniqueIdentifier (pctxt, "subjectUID", &pvalue->subjectUID);
   }

   if (pvalue->m.extensionsPresent) {
      asn1PrtToStrm_EXP_Extensions (pctxt, "extensions", &pvalue->extensions);
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int ASN1C_CRMF_CertTemplate::toStream (const char* name)

{
   asn1PrtToStrm_CRMF_CertTemplate (getCtxtPtr(), name, &msgData);
   return 0;
}

int ASN1C_CRMF_CertTemplate::setPrintStream
(rtxPrintCallback strmCallback, void * pStrmInfo)

{
   return rtxSetPrintStream (getCtxtPtr(), strmCallback, pStrmInfo);
}

int asn1PrtToStrm_CRMF_SinglePubInfo (OSCTXT *pctxt, 
   const char* name, const ASN1T_CRMF_SinglePubInfo* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_CRMF_SinglePubInfo_pubMethod (pctxt, "pubMethod", &pvalue->pubMethod);

   if (pvalue->m.pubLocationPresent) {
      asn1PrtToStrm_IMP_GeneralName (pctxt, "pubLocation", &pvalue->pubLocation);
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int ASN1C_CRMF_SinglePubInfo::toStream (const char* name)

{
   asn1PrtToStrm_CRMF_SinglePubInfo (getCtxtPtr(), name, &msgData);
   return 0;
}

int ASN1C_CRMF_SinglePubInfo::setPrintStream
(rtxPrintCallback strmCallback, void * pStrmInfo)

{
   return rtxSetPrintStream (getCtxtPtr(), strmCallback, pStrmInfo);
}

int asn1PrtToStrm_CRMF_PKIPublicationInfo_pubInfos (OSCTXT *pctxt, 
   const char* name, const ASN1T_CRMF_PKIPublicationInfo_pubInfos* pvalue)
{
   ASN1T_CRMF_SinglePubInfo* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512], numbuf[32];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata0 = (ASN1T_CRMF_SinglePubInfo*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_CRMF_SinglePubInfo (pctxt, namebuf, pdata0);
      pnode = pnode->next;
   }
   return 0;
}

int ASN1C_CRMF_PKIPublicationInfo_pubInfos::toStream (const char* name)

{
   asn1PrtToStrm_CRMF_PKIPublicationInfo_pubInfos (getCtxtPtr(), name, &msgData);
   return 0;
}

int ASN1C_CRMF_PKIPublicationInfo_pubInfos::setPrintStream
(rtxPrintCallback strmCallback, void * pStrmInfo)

{
   return rtxSetPrintStream (getCtxtPtr(), strmCallback, pStrmInfo);
}

int asn1PrtToStrm_CRMF_PKIPublicationInfo (OSCTXT *pctxt, 
   const char* name, const ASN1T_CRMF_PKIPublicationInfo* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_CRMF_PKIPublicationInfo_action (pctxt, "action", &pvalue->action);

   if (pvalue->m.pubInfosPresent) {
      asn1PrtToStrm_CRMF_PKIPublicationInfo_pubInfos (pctxt, "pubInfos", &pvalue->pubInfos);
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int ASN1C_CRMF_PKIPublicationInfo::toStream (const char* name)

{
   asn1PrtToStrm_CRMF_PKIPublicationInfo (getCtxtPtr(), name, &msgData);
   return 0;
}

int ASN1C_CRMF_PKIPublicationInfo::setPrintStream
(rtxPrintCallback strmCallback, void * pStrmInfo)

{
   return rtxSetPrintStream (getCtxtPtr(), strmCallback, pStrmInfo);
}

int asn1PrtToStrm_CRMF_EncryptedValue (OSCTXT *pctxt, 
   const char* name, const ASN1T_CRMF_EncryptedValue* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.intendedAlgPresent) {
      asn1PrtToStrm_EXP_AlgorithmIdentifier (pctxt, "intendedAlg", &pvalue->intendedAlg);
   }

   if (pvalue->m.symmAlgPresent) {
      asn1PrtToStrm_EXP_AlgorithmIdentifier (pctxt, "symmAlg", &pvalue->symmAlg);
   }

   if (pvalue->m.encSymmKeyPresent) {
      rtPrintToStreamIndent (pctxt);
      rtPrintToStreamBitStrBraceText (pctxt, "encSymmKey", pvalue->encSymmKey.numbits, pvalue->encSymmKey.data);
   }

   if (pvalue->m.keyAlgPresent) {
      asn1PrtToStrm_EXP_AlgorithmIdentifier (pctxt, "keyAlg", &pvalue->keyAlg);
   }

   if (pvalue->m.valueHintPresent) {
      rtPrintToStreamIndent (pctxt);
      rtPrintToStreamHexStr (pctxt, "valueHint", pvalue->valueHint.numocts, pvalue->valueHint.data);
   }

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceText (pctxt, "encValue", pvalue->encValue.numbits, pvalue->encValue.data);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int ASN1C_CRMF_EncryptedValue::toStream (const char* name)

{
   asn1PrtToStrm_CRMF_EncryptedValue (getCtxtPtr(), name, &msgData);
   return 0;
}

int ASN1C_CRMF_EncryptedValue::setPrintStream
(rtxPrintCallback strmCallback, void * pStrmInfo)

{
   return rtxSetPrintStream (getCtxtPtr(), strmCallback, pStrmInfo);
}

int asn1PrtToStrm_CRMF_CertId (OSCTXT *pctxt, 
   const char* name, const ASN1T_CRMF_CertId* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_IMP_GeneralName (pctxt, "issuer", &pvalue->issuer);

   asn1PrtToStrm_EXP_CertificateSerialNumber (pctxt, "serialNumber", &pvalue->serialNumber);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int ASN1C_CRMF_CertId::toStream (const char* name)

{
   asn1PrtToStrm_CRMF_CertId (getCtxtPtr(), name, &msgData);
   return 0;
}

int ASN1C_CRMF_CertId::setPrintStream
(rtxPrintCallback strmCallback, void * pStrmInfo)

{
   return rtxSetPrintStream (getCtxtPtr(), strmCallback, pStrmInfo);
}

int asn1PrtToStrm_CRMF_Controls (OSCTXT *pctxt, 
   const char* name, const ASN1T_CRMF_Controls* pvalue)
{
   ASN1T_EXP_AttributeTypeAndValue* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512], numbuf[32];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata0 = (ASN1T_EXP_AttributeTypeAndValue*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_EXP_AttributeTypeAndValue (pctxt, namebuf, pdata0);
      pnode = pnode->next;
   }
   return 0;
}

int ASN1C_CRMF_Controls::toStream (const char* name)

{
   asn1PrtToStrm_CRMF_Controls (getCtxtPtr(), name, &msgData);
   return 0;
}

int ASN1C_CRMF_Controls::setPrintStream
(rtxPrintCallback strmCallback, void * pStrmInfo)

{
   return rtxSetPrintStream (getCtxtPtr(), strmCallback, pStrmInfo);
}

int asn1PrtToStrm_CRMF_CertRequest (OSCTXT *pctxt, 
   const char* name, const ASN1T_CRMF_CertRequest* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamInteger (pctxt, "certReqId", pvalue->certReqId);

   asn1PrtToStrm_CRMF_CertTemplate (pctxt, "certTemplate", &pvalue->certTemplate);

   if (pvalue->m.controlsPresent) {
      asn1PrtToStrm_CRMF_Controls (pctxt, "controls", &pvalue->controls);
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int ASN1C_CRMF_CertRequest::toStream (const char* name)

{
   asn1PrtToStrm_CRMF_CertRequest (getCtxtPtr(), name, &msgData);
   return 0;
}

int ASN1C_CRMF_CertRequest::setPrintStream
(rtxPrintCallback strmCallback, void * pStrmInfo)

{
   return rtxSetPrintStream (getCtxtPtr(), strmCallback, pStrmInfo);
}

int asn1PrtToStrm_CRMF_PKMACValue (OSCTXT *pctxt, 
   const char* name, const ASN1T_CRMF_PKMACValue* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_EXP_AlgorithmIdentifier (pctxt, "algId", &pvalue->algId);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceText (pctxt, "value", pvalue->value.numbits, pvalue->value.data);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int ASN1C_CRMF_PKMACValue::toStream (const char* name)

{
   asn1PrtToStrm_CRMF_PKMACValue (getCtxtPtr(), name, &msgData);
   return 0;
}

int ASN1C_CRMF_PKMACValue::setPrintStream
(rtxPrintCallback strmCallback, void * pStrmInfo)

{
   return rtxSetPrintStream (getCtxtPtr(), strmCallback, pStrmInfo);
}

int asn1PrtToStrm_CRMF_POPOSigningKeyInput_authInfo (OSCTXT *pctxt, 
   const char* name, const ASN1T_CRMF_POPOSigningKeyInput_authInfo* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* publicKeyMAC */
      case 1:
      {
         asn1PrtToStrm_CRMF_PKMACValue (pctxt, "publicKeyMAC", pvalue->u.publicKeyMAC);
         break;
      }
      /* sender */
      case 2:
      {
         asn1PrtToStrm_IMP_GeneralName (pctxt, "sender", pvalue->u.sender);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int ASN1C_CRMF_POPOSigningKeyInput_authInfo::toStream (const char* name)

{
   asn1PrtToStrm_CRMF_POPOSigningKeyInput_authInfo (getCtxtPtr(), name, &msgData);
   return 0;
}

int ASN1C_CRMF_POPOSigningKeyInput_authInfo::setPrintStream
(rtxPrintCallback strmCallback, void * pStrmInfo)

{
   return rtxSetPrintStream (getCtxtPtr(), strmCallback, pStrmInfo);
}

int asn1PrtToStrm_CRMF_POPOSigningKeyInput (OSCTXT *pctxt, 
   const char* name, const ASN1T_CRMF_POPOSigningKeyInput* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_CRMF_POPOSigningKeyInput_authInfo (pctxt, "authInfo", &pvalue->authInfo);

   asn1PrtToStrm_EXP_SubjectPublicKeyInfo (pctxt, "publicKey", &pvalue->publicKey);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int ASN1C_CRMF_POPOSigningKeyInput::toStream (const char* name)

{
   asn1PrtToStrm_CRMF_POPOSigningKeyInput (getCtxtPtr(), name, &msgData);
   return 0;
}

int ASN1C_CRMF_POPOSigningKeyInput::setPrintStream
(rtxPrintCallback strmCallback, void * pStrmInfo)

{
   return rtxSetPrintStream (getCtxtPtr(), strmCallback, pStrmInfo);
}

int asn1PrtToStrm_CRMF_POPOSigningKey (OSCTXT *pctxt, 
   const char* name, const ASN1T_CRMF_POPOSigningKey* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   if (pvalue->m.poposkInputPresent) {
      asn1PrtToStrm_CRMF_POPOSigningKeyInput (pctxt, "poposkInput", &pvalue->poposkInput);
   }

   asn1PrtToStrm_EXP_AlgorithmIdentifier (pctxt, "algorithmIdentifier", &pvalue->algorithmIdentifier);

   rtPrintToStreamIndent (pctxt);
   rtPrintToStreamBitStrBraceText (pctxt, "signature_", pvalue->signature_.numbits, pvalue->signature_.data);

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int ASN1C_CRMF_POPOSigningKey::toStream (const char* name)

{
   asn1PrtToStrm_CRMF_POPOSigningKey (getCtxtPtr(), name, &msgData);
   return 0;
}

int ASN1C_CRMF_POPOSigningKey::setPrintStream
(rtxPrintCallback strmCallback, void * pStrmInfo)

{
   return rtxSetPrintStream (getCtxtPtr(), strmCallback, pStrmInfo);
}

int asn1PrtToStrm_CRMF_POPOPrivKey (OSCTXT *pctxt, 
   const char* name, const ASN1T_CRMF_POPOPrivKey* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* thisMessage */
      case 1:
      {
         rtPrintToStreamIndent (pctxt);
         rtPrintToStreamBitStrBraceText (pctxt, "thisMessage", pvalue->u.thisMessage->numbits, pvalue->u.thisMessage->data);
         break;
      }
      /* subsequentMessage */
      case 2:
      {
         asn1PrtToStrm_CRMF_SubsequentMessage (pctxt, "subsequentMessage", &pvalue->u.subsequentMessage);
         break;
      }
      /* dhMAC */
      case 3:
      {
         rtPrintToStreamIndent (pctxt);
         rtPrintToStreamBitStrBraceText (pctxt, "dhMAC", pvalue->u.dhMAC->numbits, pvalue->u.dhMAC->data);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int ASN1C_CRMF_POPOPrivKey::toStream (const char* name)

{
   asn1PrtToStrm_CRMF_POPOPrivKey (getCtxtPtr(), name, &msgData);
   return 0;
}

int ASN1C_CRMF_POPOPrivKey::setPrintStream
(rtxPrintCallback strmCallback, void * pStrmInfo)

{
   return rtxSetPrintStream (getCtxtPtr(), strmCallback, pStrmInfo);
}

int asn1PrtToStrm_CRMF_ProofOfPossession (OSCTXT *pctxt, 
   const char* name, const ASN1T_CRMF_ProofOfPossession* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   switch (pvalue->t)
   {
      /* raVerified */
      case 1:
      {
         rtPrintToStreamIndent (pctxt);
         rtxPrintToStreamNull (pctxt, "raVerified");
         break;
      }
      /* signature */
      case 2:
      {
         asn1PrtToStrm_CRMF_POPOSigningKey (pctxt, "signature", pvalue->u.signature_);
         break;
      }
      /* keyEncipherment */
      case 3:
      {
         asn1PrtToStrm_CRMF_POPOPrivKey (pctxt, "keyEncipherment", pvalue->u.keyEncipherment);
         break;
      }
      /* keyAgreement */
      case 4:
      {
         asn1PrtToStrm_CRMF_POPOPrivKey (pctxt, "keyAgreement", pvalue->u.keyAgreement);
         break;
      }
      default:;
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int ASN1C_CRMF_ProofOfPossession::toStream (const char* name)

{
   asn1PrtToStrm_CRMF_ProofOfPossession (getCtxtPtr(), name, &msgData);
   return 0;
}

int ASN1C_CRMF_ProofOfPossession::setPrintStream
(rtxPrintCallback strmCallback, void * pStrmInfo)

{
   return rtxSetPrintStream (getCtxtPtr(), strmCallback, pStrmInfo);
}

int asn1PrtToStrm_CRMF_CertReqMsg_regInfo (OSCTXT *pctxt, 
   const char* name, const ASN1T_CRMF_CertReqMsg_regInfo* pvalue)
{
   ASN1T_EXP_AttributeTypeAndValue* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512], numbuf[32];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata0 = (ASN1T_EXP_AttributeTypeAndValue*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_EXP_AttributeTypeAndValue (pctxt, namebuf, pdata0);
      pnode = pnode->next;
   }
   return 0;
}

int ASN1C_CRMF_CertReqMsg_regInfo::toStream (const char* name)

{
   asn1PrtToStrm_CRMF_CertReqMsg_regInfo (getCtxtPtr(), name, &msgData);
   return 0;
}

int ASN1C_CRMF_CertReqMsg_regInfo::setPrintStream
(rtxPrintCallback strmCallback, void * pStrmInfo)

{
   return rtxSetPrintStream (getCtxtPtr(), strmCallback, pStrmInfo);
}

int asn1PrtToStrm_CRMF_CertReqMsg (OSCTXT *pctxt, 
   const char* name, const ASN1T_CRMF_CertReqMsg* pvalue)
{
   rtPrintToStreamOpenBrace (pctxt, name);

   asn1PrtToStrm_CRMF_CertRequest (pctxt, "certReq", &pvalue->certReq);

   if (pvalue->m.popPresent) {
      asn1PrtToStrm_CRMF_ProofOfPossession (pctxt, "pop", &pvalue->pop);
   }

   if (pvalue->m.regInfoPresent) {
      asn1PrtToStrm_CRMF_CertReqMsg_regInfo (pctxt, "regInfo", &pvalue->regInfo);
   }

   rtPrintToStreamCloseBrace (pctxt);
   return 0;
}

int ASN1C_CRMF_CertReqMsg::toStream (const char* name)

{
   asn1PrtToStrm_CRMF_CertReqMsg (getCtxtPtr(), name, &msgData);
   return 0;
}

int ASN1C_CRMF_CertReqMsg::setPrintStream
(rtxPrintCallback strmCallback, void * pStrmInfo)

{
   return rtxSetPrintStream (getCtxtPtr(), strmCallback, pStrmInfo);
}

int asn1PrtToStrm_CRMF_CertReqMessages (OSCTXT *pctxt, 
   const char* name, const ASN1T_CRMF_CertReqMessages* pvalue)
{
   ASN1T_CRMF_CertReqMsg* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512], numbuf[32];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      pdata0 = (ASN1T_CRMF_CertReqMsg*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1PrtToStrm_CRMF_CertReqMsg (pctxt, namebuf, pdata0);
      pnode = pnode->next;
   }
   return 0;
}

int ASN1C_CRMF_CertReqMessages::toStream (const char* name)

{
   asn1PrtToStrm_CRMF_CertReqMessages (getCtxtPtr(), name, &msgData);
   return 0;
}

int ASN1C_CRMF_CertReqMessages::setPrintStream
(rtxPrintCallback strmCallback, void * pStrmInfo)

{
   return rtxSetPrintStream (getCtxtPtr(), strmCallback, pStrmInfo);
}

