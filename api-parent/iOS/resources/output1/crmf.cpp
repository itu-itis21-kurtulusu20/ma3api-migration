/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.6, Date: 20-Feb-2014.
 */
#include <new>
#include "crmf.h"
#include "rtxsrc/rtxCommon.h"

ASN1OBJID CRMF_id_pkix = {
   7,
   { 1, 3, 6, 1, 5, 5, 7 }
} ;
ASN1OBJID CRMF_id_pkip = {
   8,
   { 1, 3, 6, 1, 5, 5, 7, 5 }
} ;
ASN1OBJID CRMF_id_regCtrl = {
   9,
   { 1, 3, 6, 1, 5, 5, 7, 5, 1 }
} ;
ASN1OBJID CRMF_id_regCtrl_protocolEncrKey = {
   10,
   { 1, 3, 6, 1, 5, 5, 7, 5, 1, 6 }
} ;

ASN1T_CRMF_SubsequentMessage* 
   new_ASN1T_CRMF_SubsequentMessage (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CRMF_SubsequentMessage));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CRMF_SubsequentMessage;
}

ASN1C_CRMF_SubsequentMessage::ASN1C_CRMF_SubsequentMessage
    (ASN1T_CRMF_SubsequentMessage& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CRMF_SubsequentMessage::ASN1C_CRMF_SubsequentMessage (
   OSRTMessageBufferIF& msgBuf, ASN1T_CRMF_SubsequentMessage& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CRMF_SubsequentMessage::ASN1C_CRMF_SubsequentMessage (
   OSRTContext &context, ASN1T_CRMF_SubsequentMessage& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_CRMF_SubsequentMessage::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CRMF_SubsequentMessage (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CRMF_SubsequentMessage::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_CRMF_SubsequentMessage (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

ASN1T_CRMF_PKIPublicationInfo_action* 
   new_ASN1T_CRMF_PKIPublicationInfo_action (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CRMF_PKIPublicationInfo_action));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CRMF_PKIPublicationInfo_action;
}

ASN1C_CRMF_PKIPublicationInfo_action::ASN1C_CRMF_PKIPublicationInfo_action
    (ASN1T_CRMF_PKIPublicationInfo_action& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CRMF_PKIPublicationInfo_action::ASN1C_CRMF_PKIPublicationInfo_action (
   OSRTMessageBufferIF& msgBuf, ASN1T_CRMF_PKIPublicationInfo_action& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CRMF_PKIPublicationInfo_action::ASN1C_CRMF_PKIPublicationInfo_action (
   OSRTContext &context, ASN1T_CRMF_PKIPublicationInfo_action& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_CRMF_PKIPublicationInfo_action::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CRMF_PKIPublicationInfo_action (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CRMF_PKIPublicationInfo_action::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_CRMF_PKIPublicationInfo_action (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

ASN1T_CRMF_SinglePubInfo_pubMethod* 
   new_ASN1T_CRMF_SinglePubInfo_pubMethod (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CRMF_SinglePubInfo_pubMethod));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CRMF_SinglePubInfo_pubMethod;
}

ASN1C_CRMF_SinglePubInfo_pubMethod::ASN1C_CRMF_SinglePubInfo_pubMethod
    (ASN1T_CRMF_SinglePubInfo_pubMethod& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CRMF_SinglePubInfo_pubMethod::ASN1C_CRMF_SinglePubInfo_pubMethod (
   OSRTMessageBufferIF& msgBuf, ASN1T_CRMF_SinglePubInfo_pubMethod& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CRMF_SinglePubInfo_pubMethod::ASN1C_CRMF_SinglePubInfo_pubMethod (
   OSRTContext &context, ASN1T_CRMF_SinglePubInfo_pubMethod& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_CRMF_SinglePubInfo_pubMethod::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CRMF_SinglePubInfo_pubMethod (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CRMF_SinglePubInfo_pubMethod::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_CRMF_SinglePubInfo_pubMethod (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

ASN1T_CRMF_OptionalValidity* new_ASN1T_CRMF_OptionalValidity (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CRMF_OptionalValidity));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CRMF_OptionalValidity;
}

ASN1C_CRMF_OptionalValidity::ASN1C_CRMF_OptionalValidity
    (ASN1T_CRMF_OptionalValidity& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CRMF_OptionalValidity::ASN1C_CRMF_OptionalValidity (
   OSRTMessageBufferIF& msgBuf, ASN1T_CRMF_OptionalValidity& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CRMF_OptionalValidity::ASN1C_CRMF_OptionalValidity (OSRTContext &context
   , ASN1T_CRMF_OptionalValidity& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CRMF_OptionalValidity::ASN1T_CRMF_OptionalValidity ()
{
   m.notBeforePresent = 0;
   m.notAfterPresent = 0;
}

ASN1T_CRMF_OptionalValidity::~ASN1T_CRMF_OptionalValidity ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CRMF_OptionalValidity (pctxt, this);
   }
}

int ASN1C_CRMF_OptionalValidity::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CRMF_OptionalValidity (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CRMF_OptionalValidity::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CRMF_OptionalValidity;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CRMF_OptionalValidity (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CRMF_OptionalValidity (ASN1T_CRMF_OptionalValidity* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CRMF_OptionalValidity;
}

void asn1Free_CRMF_OptionalValidity (OSCTXT *pctxt, 
   ASN1T_CRMF_OptionalValidity* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.notBeforePresent) {
      asn1Free_EXP_Time (pctxt, &pvalue->notBefore);
   }
   if (pvalue->m.notAfterPresent) {
      asn1Free_EXP_Time (pctxt, &pvalue->notAfter);
   }
}

void ASN1C_CRMF_OptionalValidity::MemFree ()
{
   asn1Free_CRMF_OptionalValidity (getCtxtPtr(), &msgData);
}

ASN1T_CRMF_CertTemplate* new_ASN1T_CRMF_CertTemplate (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CRMF_CertTemplate));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CRMF_CertTemplate;
}

ASN1C_CRMF_CertTemplate::ASN1C_CRMF_CertTemplate
    (ASN1T_CRMF_CertTemplate& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CRMF_CertTemplate::ASN1C_CRMF_CertTemplate (OSRTMessageBufferIF& msgBuf
   , ASN1T_CRMF_CertTemplate& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CRMF_CertTemplate::ASN1C_CRMF_CertTemplate (OSRTContext &context
   , ASN1T_CRMF_CertTemplate& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CRMF_CertTemplate::ASN1T_CRMF_CertTemplate ()
{
   m.versionPresent = 0;
   m.serialNumberPresent = 0;
   m.signingAlgPresent = 0;
   m.issuerPresent = 0;
   m.validityPresent = 0;
   m.subjectPresent = 0;
   m.publicKeyPresent = 0;
   m.issuerUIDPresent = 0;
   m.subjectUIDPresent = 0;
   m.extensionsPresent = 0;
}

ASN1T_CRMF_CertTemplate::~ASN1T_CRMF_CertTemplate ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CRMF_CertTemplate (pctxt, this);
   }
}

int ASN1C_CRMF_CertTemplate::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CRMF_CertTemplate (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CRMF_CertTemplate::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CRMF_CertTemplate;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CRMF_CertTemplate (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CRMF_CertTemplate (ASN1T_CRMF_CertTemplate* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CRMF_CertTemplate;
}

void asn1Free_CRMF_CertTemplate (OSCTXT *pctxt, 
   ASN1T_CRMF_CertTemplate* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.signingAlgPresent) {
      asn1Free_EXP_AlgorithmIdentifier (pctxt, &pvalue->signingAlg);
   }
   if (pvalue->m.issuerPresent) {
      asn1Free_EXP_Name (pctxt, &pvalue->issuer);
   }
   if (pvalue->m.validityPresent) {
      asn1Free_CRMF_OptionalValidity (pctxt, &pvalue->validity);
   }
   if (pvalue->m.subjectPresent) {
      asn1Free_EXP_Name (pctxt, &pvalue->subject);
   }
   if (pvalue->m.publicKeyPresent) {
      asn1Free_EXP_SubjectPublicKeyInfo (pctxt, &pvalue->publicKey);
   }
   if (pvalue->m.issuerUIDPresent) {
      asn1Free_EXP_UniqueIdentifier (pctxt, &pvalue->issuerUID);
   }
   if (pvalue->m.subjectUIDPresent) {
      asn1Free_EXP_UniqueIdentifier (pctxt, &pvalue->subjectUID);
   }
   if (pvalue->m.extensionsPresent) {
      asn1Free_EXP_Extensions (pctxt, &pvalue->extensions);
   }
}

void ASN1C_CRMF_CertTemplate::MemFree ()
{
   asn1Free_CRMF_CertTemplate (getCtxtPtr(), &msgData);
}

ASN1T_CRMF_SinglePubInfo* new_ASN1T_CRMF_SinglePubInfo (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CRMF_SinglePubInfo));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CRMF_SinglePubInfo;
}

ASN1C_CRMF_SinglePubInfo::ASN1C_CRMF_SinglePubInfo
    (ASN1T_CRMF_SinglePubInfo& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CRMF_SinglePubInfo::ASN1C_CRMF_SinglePubInfo (OSRTMessageBufferIF& msgBuf
   , ASN1T_CRMF_SinglePubInfo& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CRMF_SinglePubInfo::ASN1C_CRMF_SinglePubInfo (OSRTContext &context
   , ASN1T_CRMF_SinglePubInfo& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CRMF_SinglePubInfo::ASN1T_CRMF_SinglePubInfo ()
{
   m.pubLocationPresent = 0;
}

ASN1T_CRMF_SinglePubInfo::~ASN1T_CRMF_SinglePubInfo ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CRMF_SinglePubInfo (pctxt, this);
   }
}

int ASN1C_CRMF_SinglePubInfo::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CRMF_SinglePubInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CRMF_SinglePubInfo::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CRMF_SinglePubInfo;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CRMF_SinglePubInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CRMF_SinglePubInfo (ASN1T_CRMF_SinglePubInfo* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CRMF_SinglePubInfo;
}

void asn1Free_CRMF_SinglePubInfo (OSCTXT *pctxt, 
   ASN1T_CRMF_SinglePubInfo* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.pubLocationPresent) {
      asn1Free_IMP_GeneralName (pctxt, &pvalue->pubLocation);
   }
}

void ASN1C_CRMF_SinglePubInfo::MemFree ()
{
   asn1Free_CRMF_SinglePubInfo (getCtxtPtr(), &msgData);
}

ASN1C_CRMF_PKIPublicationInfo_pubInfos::ASN1C_CRMF_PKIPublicationInfo_pubInfos
    (ASN1T_CRMF_PKIPublicationInfo_pubInfos& data) : ASN1CSeqOfList(data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CRMF_PKIPublicationInfo_pubInfos::
   ASN1C_CRMF_PKIPublicationInfo_pubInfos (OSRTMessageBufferIF& msgBuf
   , ASN1T_CRMF_PKIPublicationInfo_pubInfos& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CRMF_PKIPublicationInfo_pubInfos::
   ASN1C_CRMF_PKIPublicationInfo_pubInfos (OSRTContext &context
   , ASN1T_CRMF_PKIPublicationInfo_pubInfos& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CRMF_PKIPublicationInfo_pubInfos::
   ASN1C_CRMF_PKIPublicationInfo_pubInfos (ASN1CType& ccobj
   , ASN1T_CRMF_PKIPublicationInfo_pubInfos& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CRMF_PKIPublicationInfo_pubInfos::Append (ASN1T_CRMF_SinglePubInfo* elem)
{
   append ((void*)elem);
}

ASN1T_CRMF_SinglePubInfo* ASN1C_CRMF_PKIPublicationInfo_pubInfos::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_CRMF_SinglePubInfo));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CRMF_SinglePubInfo;
}

ASN1T_CRMF_SinglePubInfo* ASN1C_CRMF_PKIPublicationInfo_pubInfos::AppendNewElement ()
{
   ASN1T_CRMF_SinglePubInfo* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CRMF_PKIPublicationInfo_pubInfos::~ASN1T_CRMF_PKIPublicationInfo_pubInfos ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CRMF_PKIPublicationInfo_pubInfos (pctxt, this);
   }
}

int ASN1C_CRMF_PKIPublicationInfo_pubInfos::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CRMF_PKIPublicationInfo_pubInfos (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CRMF_PKIPublicationInfo_pubInfos::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CRMF_PKIPublicationInfo_pubInfos;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CRMF_PKIPublicationInfo_pubInfos (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CRMF_PKIPublicationInfo_pubInfos (
   ASN1T_CRMF_PKIPublicationInfo_pubInfos* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CRMF_PKIPublicationInfo_pubInfos;
   rtxDListFastInit (pvalue);
}

void asn1Free_CRMF_PKIPublicationInfo_pubInfos (OSCTXT *pctxt, 
   ASN1T_CRMF_PKIPublicationInfo_pubInfos* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_CRMF_SinglePubInfo* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_CRMF_SinglePubInfo*)pnode->data;
      asn1Free_CRMF_SinglePubInfo (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CRMF_PKIPublicationInfo_pubInfos::MemFree ()
{
   asn1Free_CRMF_PKIPublicationInfo_pubInfos (getCtxtPtr(), &msgData);
}

ASN1T_CRMF_PKIPublicationInfo* 
   new_ASN1T_CRMF_PKIPublicationInfo (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CRMF_PKIPublicationInfo));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CRMF_PKIPublicationInfo;
}

ASN1C_CRMF_PKIPublicationInfo::ASN1C_CRMF_PKIPublicationInfo
    (ASN1T_CRMF_PKIPublicationInfo& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CRMF_PKIPublicationInfo::ASN1C_CRMF_PKIPublicationInfo (
   OSRTMessageBufferIF& msgBuf, ASN1T_CRMF_PKIPublicationInfo& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CRMF_PKIPublicationInfo::ASN1C_CRMF_PKIPublicationInfo (
   OSRTContext &context, ASN1T_CRMF_PKIPublicationInfo& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CRMF_PKIPublicationInfo::ASN1T_CRMF_PKIPublicationInfo ()
{
   m.pubInfosPresent = 0;
}

ASN1T_CRMF_PKIPublicationInfo::~ASN1T_CRMF_PKIPublicationInfo ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CRMF_PKIPublicationInfo (pctxt, this);
   }
}

int ASN1C_CRMF_PKIPublicationInfo::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CRMF_PKIPublicationInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CRMF_PKIPublicationInfo::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CRMF_PKIPublicationInfo;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CRMF_PKIPublicationInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CRMF_PKIPublicationInfo (ASN1T_CRMF_PKIPublicationInfo* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CRMF_PKIPublicationInfo;
}

void asn1Free_CRMF_PKIPublicationInfo (OSCTXT *pctxt, 
   ASN1T_CRMF_PKIPublicationInfo* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.pubInfosPresent) {
      asn1Free_CRMF_PKIPublicationInfo_pubInfos (pctxt, &pvalue->pubInfos);
   }
}

void ASN1C_CRMF_PKIPublicationInfo::MemFree ()
{
   asn1Free_CRMF_PKIPublicationInfo (getCtxtPtr(), &msgData);
}

ASN1T_CRMF_EncryptedValue* new_ASN1T_CRMF_EncryptedValue (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CRMF_EncryptedValue));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CRMF_EncryptedValue;
}

ASN1C_CRMF_EncryptedValue::ASN1C_CRMF_EncryptedValue
    (ASN1T_CRMF_EncryptedValue& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CRMF_EncryptedValue::ASN1C_CRMF_EncryptedValue (
   OSRTMessageBufferIF& msgBuf, ASN1T_CRMF_EncryptedValue& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CRMF_EncryptedValue::ASN1C_CRMF_EncryptedValue (OSRTContext &context
   , ASN1T_CRMF_EncryptedValue& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CRMF_EncryptedValue::ASN1T_CRMF_EncryptedValue ()
{
   m.intendedAlgPresent = 0;
   m.symmAlgPresent = 0;
   m.encSymmKeyPresent = 0;
   m.keyAlgPresent = 0;
   m.valueHintPresent = 0;
}

ASN1T_CRMF_EncryptedValue::~ASN1T_CRMF_EncryptedValue ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CRMF_EncryptedValue (pctxt, this);
   }
}

int ASN1C_CRMF_EncryptedValue::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CRMF_EncryptedValue (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CRMF_EncryptedValue::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CRMF_EncryptedValue;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CRMF_EncryptedValue (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CRMF_EncryptedValue (ASN1T_CRMF_EncryptedValue* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CRMF_EncryptedValue;
}

void asn1Free_CRMF_EncryptedValue (OSCTXT *pctxt, 
   ASN1T_CRMF_EncryptedValue* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.intendedAlgPresent) {
      asn1Free_EXP_AlgorithmIdentifier (pctxt, &pvalue->intendedAlg);
   }
   if (pvalue->m.symmAlgPresent) {
      asn1Free_EXP_AlgorithmIdentifier (pctxt, &pvalue->symmAlg);
   }
   if (pvalue->m.encSymmKeyPresent) {
      if (pvalue->encSymmKey.numbits > 0) {
         rtxMemFreePtr (pctxt, (void*)pvalue->encSymmKey.data);
         pvalue->encSymmKey.numbits = 0;
         pvalue->encSymmKey.data = 0;
      }
   }
   if (pvalue->m.keyAlgPresent) {
      asn1Free_EXP_AlgorithmIdentifier (pctxt, &pvalue->keyAlg);
   }
   if (pvalue->m.valueHintPresent) {
      if (pvalue->valueHint.numocts > 0) {
         rtxMemFreePtr (pctxt, (void*)pvalue->valueHint.data);
         pvalue->valueHint.numocts = 0;
         pvalue->valueHint.data = 0;
      }
   }
   if (pvalue->encValue.numbits > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->encValue.data);
      pvalue->encValue.numbits = 0;
      pvalue->encValue.data = 0;
   }
}

void ASN1C_CRMF_EncryptedValue::MemFree ()
{
   asn1Free_CRMF_EncryptedValue (getCtxtPtr(), &msgData);
}

ASN1T_CRMF_CertId* new_ASN1T_CRMF_CertId (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CRMF_CertId));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CRMF_CertId;
}

ASN1C_CRMF_CertId::ASN1C_CRMF_CertId (ASN1T_CRMF_CertId& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CRMF_CertId::ASN1C_CRMF_CertId (OSRTMessageBufferIF& msgBuf
   , ASN1T_CRMF_CertId& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CRMF_CertId::ASN1C_CRMF_CertId (OSRTContext &context
   , ASN1T_CRMF_CertId& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CRMF_CertId::ASN1T_CRMF_CertId ()
{
}

ASN1T_CRMF_CertId::~ASN1T_CRMF_CertId ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CRMF_CertId (pctxt, this);
   }
}

int ASN1C_CRMF_CertId::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CRMF_CertId (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CRMF_CertId::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CRMF_CertId;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CRMF_CertId (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CRMF_CertId (ASN1T_CRMF_CertId* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CRMF_CertId;
}

void asn1Free_CRMF_CertId (OSCTXT *pctxt, ASN1T_CRMF_CertId* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_IMP_GeneralName (pctxt, &pvalue->issuer);
}

void ASN1C_CRMF_CertId::MemFree ()
{
   asn1Free_CRMF_CertId (getCtxtPtr(), &msgData);
}

ASN1C_CRMF_Controls::ASN1C_CRMF_Controls (ASN1T_CRMF_Controls& data) : 
   ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CRMF_Controls::ASN1C_CRMF_Controls (OSRTMessageBufferIF& msgBuf
   , ASN1T_CRMF_Controls& data) : ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CRMF_Controls::ASN1C_CRMF_Controls (OSRTContext &context
   , ASN1T_CRMF_Controls& data) : ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CRMF_Controls::ASN1C_CRMF_Controls (ASN1CType& ccobj
   , ASN1T_CRMF_Controls& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CRMF_Controls::Append (ASN1T_EXP_AttributeTypeAndValue* elem)
{
   append ((void*)elem);
}

ASN1T_EXP_AttributeTypeAndValue* ASN1C_CRMF_Controls::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_EXP_AttributeTypeAndValue));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_EXP_AttributeTypeAndValue;
}

ASN1T_EXP_AttributeTypeAndValue* ASN1C_CRMF_Controls::AppendNewElement ()
{
   ASN1T_EXP_AttributeTypeAndValue* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CRMF_Controls::~ASN1T_CRMF_Controls ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CRMF_Controls (pctxt, this);
   }
}

int ASN1C_CRMF_Controls::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CRMF_Controls (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CRMF_Controls::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CRMF_Controls;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CRMF_Controls (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CRMF_Controls (ASN1T_CRMF_Controls* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CRMF_Controls;
   rtxDListFastInit (pvalue);
}

void asn1Free_CRMF_Controls (OSCTXT *pctxt, ASN1T_CRMF_Controls* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_EXP_AttributeTypeAndValue* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_EXP_AttributeTypeAndValue*)pnode->data;
      asn1Free_EXP_AttributeTypeAndValue (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CRMF_Controls::MemFree ()
{
   asn1Free_CRMF_Controls (getCtxtPtr(), &msgData);
}

ASN1T_CRMF_CertRequest* new_ASN1T_CRMF_CertRequest (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CRMF_CertRequest));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CRMF_CertRequest;
}

ASN1C_CRMF_CertRequest::ASN1C_CRMF_CertRequest (ASN1T_CRMF_CertRequest& data)
    : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CRMF_CertRequest::ASN1C_CRMF_CertRequest (OSRTMessageBufferIF& msgBuf
   , ASN1T_CRMF_CertRequest& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CRMF_CertRequest::ASN1C_CRMF_CertRequest (OSRTContext &context
   , ASN1T_CRMF_CertRequest& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CRMF_CertRequest::ASN1T_CRMF_CertRequest ()
{
   m.controlsPresent = 0;
}

ASN1T_CRMF_CertRequest::~ASN1T_CRMF_CertRequest ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CRMF_CertRequest (pctxt, this);
   }
}

int ASN1C_CRMF_CertRequest::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CRMF_CertRequest (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CRMF_CertRequest::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CRMF_CertRequest;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CRMF_CertRequest (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CRMF_CertRequest (ASN1T_CRMF_CertRequest* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CRMF_CertRequest;
}

void asn1Free_CRMF_CertRequest (OSCTXT *pctxt, ASN1T_CRMF_CertRequest* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_CRMF_CertTemplate (pctxt, &pvalue->certTemplate);
   if (pvalue->m.controlsPresent) {
      asn1Free_CRMF_Controls (pctxt, &pvalue->controls);
   }
}

void ASN1C_CRMF_CertRequest::MemFree ()
{
   asn1Free_CRMF_CertRequest (getCtxtPtr(), &msgData);
}

ASN1T_CRMF_PKMACValue* new_ASN1T_CRMF_PKMACValue (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CRMF_PKMACValue));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CRMF_PKMACValue;
}

ASN1C_CRMF_PKMACValue::ASN1C_CRMF_PKMACValue (ASN1T_CRMF_PKMACValue& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CRMF_PKMACValue::ASN1C_CRMF_PKMACValue (OSRTMessageBufferIF& msgBuf
   , ASN1T_CRMF_PKMACValue& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CRMF_PKMACValue::ASN1C_CRMF_PKMACValue (OSRTContext &context
   , ASN1T_CRMF_PKMACValue& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CRMF_PKMACValue::ASN1T_CRMF_PKMACValue ()
{
}

ASN1T_CRMF_PKMACValue::~ASN1T_CRMF_PKMACValue ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CRMF_PKMACValue (pctxt, this);
   }
}

int ASN1C_CRMF_PKMACValue::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CRMF_PKMACValue (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CRMF_PKMACValue::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CRMF_PKMACValue;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CRMF_PKMACValue (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CRMF_PKMACValue (ASN1T_CRMF_PKMACValue* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CRMF_PKMACValue;
}

void asn1Free_CRMF_PKMACValue (OSCTXT *pctxt, ASN1T_CRMF_PKMACValue* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_EXP_AlgorithmIdentifier (pctxt, &pvalue->algId);
   if (pvalue->value.numbits > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->value.data);
      pvalue->value.numbits = 0;
      pvalue->value.data = 0;
   }
}

void ASN1C_CRMF_PKMACValue::MemFree ()
{
   asn1Free_CRMF_PKMACValue (getCtxtPtr(), &msgData);
}

ASN1T_CRMF_POPOSigningKeyInput_authInfo* 
   new_ASN1T_CRMF_POPOSigningKeyInput_authInfo (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CRMF_POPOSigningKeyInput_authInfo));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CRMF_POPOSigningKeyInput_authInfo;
}

ASN1C_CRMF_POPOSigningKeyInput_authInfo::
   ASN1C_CRMF_POPOSigningKeyInput_authInfo
    (ASN1T_CRMF_POPOSigningKeyInput_authInfo& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CRMF_POPOSigningKeyInput_authInfo::
   ASN1C_CRMF_POPOSigningKeyInput_authInfo (OSRTMessageBufferIF& msgBuf
   , ASN1T_CRMF_POPOSigningKeyInput_authInfo& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CRMF_POPOSigningKeyInput_authInfo::
   ASN1C_CRMF_POPOSigningKeyInput_authInfo (OSRTContext &context
   , ASN1T_CRMF_POPOSigningKeyInput_authInfo& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CRMF_POPOSigningKeyInput_authInfo::~ASN1T_CRMF_POPOSigningKeyInput_authInfo ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CRMF_POPOSigningKeyInput_authInfo (pctxt, this);
   }
}

int ASN1C_CRMF_POPOSigningKeyInput_authInfo::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CRMF_POPOSigningKeyInput_authInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CRMF_POPOSigningKeyInput_authInfo::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CRMF_POPOSigningKeyInput_authInfo;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CRMF_POPOSigningKeyInput_authInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CRMF_POPOSigningKeyInput_authInfo (
   ASN1T_CRMF_POPOSigningKeyInput_authInfo* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CRMF_POPOSigningKeyInput_authInfo;
}

void asn1Free_CRMF_POPOSigningKeyInput_authInfo (OSCTXT *pctxt, 
   ASN1T_CRMF_POPOSigningKeyInput_authInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.publicKeyMAC) {
            asn1Free_CRMF_PKMACValue (pctxt, pvalue->u.publicKeyMAC);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.publicKeyMAC);
         }
         break;

      case 2:
         if (0 != pvalue->u.sender) {
            asn1Free_IMP_GeneralName (pctxt, pvalue->u.sender);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.sender);
         }
         break;

   }
}

void ASN1C_CRMF_POPOSigningKeyInput_authInfo::MemFree ()
{
   asn1Free_CRMF_POPOSigningKeyInput_authInfo (getCtxtPtr(), &msgData);
}

ASN1T_CRMF_POPOSigningKeyInput* 
   new_ASN1T_CRMF_POPOSigningKeyInput (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CRMF_POPOSigningKeyInput));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CRMF_POPOSigningKeyInput;
}

ASN1C_CRMF_POPOSigningKeyInput::ASN1C_CRMF_POPOSigningKeyInput
    (ASN1T_CRMF_POPOSigningKeyInput& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CRMF_POPOSigningKeyInput::ASN1C_CRMF_POPOSigningKeyInput (
   OSRTMessageBufferIF& msgBuf, ASN1T_CRMF_POPOSigningKeyInput& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CRMF_POPOSigningKeyInput::ASN1C_CRMF_POPOSigningKeyInput (
   OSRTContext &context, ASN1T_CRMF_POPOSigningKeyInput& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CRMF_POPOSigningKeyInput::ASN1T_CRMF_POPOSigningKeyInput ()
{
}

ASN1T_CRMF_POPOSigningKeyInput::~ASN1T_CRMF_POPOSigningKeyInput ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CRMF_POPOSigningKeyInput (pctxt, this);
   }
}

int ASN1C_CRMF_POPOSigningKeyInput::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CRMF_POPOSigningKeyInput (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CRMF_POPOSigningKeyInput::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CRMF_POPOSigningKeyInput;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CRMF_POPOSigningKeyInput (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CRMF_POPOSigningKeyInput (ASN1T_CRMF_POPOSigningKeyInput* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CRMF_POPOSigningKeyInput;
}

void asn1Free_CRMF_POPOSigningKeyInput (OSCTXT *pctxt, 
   ASN1T_CRMF_POPOSigningKeyInput* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_CRMF_POPOSigningKeyInput_authInfo (pctxt, &pvalue->authInfo);
   asn1Free_EXP_SubjectPublicKeyInfo (pctxt, &pvalue->publicKey);
}

void ASN1C_CRMF_POPOSigningKeyInput::MemFree ()
{
   asn1Free_CRMF_POPOSigningKeyInput (getCtxtPtr(), &msgData);
}

ASN1T_CRMF_POPOSigningKey* new_ASN1T_CRMF_POPOSigningKey (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CRMF_POPOSigningKey));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CRMF_POPOSigningKey;
}

ASN1C_CRMF_POPOSigningKey::ASN1C_CRMF_POPOSigningKey
    (ASN1T_CRMF_POPOSigningKey& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CRMF_POPOSigningKey::ASN1C_CRMF_POPOSigningKey (
   OSRTMessageBufferIF& msgBuf, ASN1T_CRMF_POPOSigningKey& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CRMF_POPOSigningKey::ASN1C_CRMF_POPOSigningKey (OSRTContext &context
   , ASN1T_CRMF_POPOSigningKey& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CRMF_POPOSigningKey::ASN1T_CRMF_POPOSigningKey ()
{
   m.poposkInputPresent = 0;
}

ASN1T_CRMF_POPOSigningKey::~ASN1T_CRMF_POPOSigningKey ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CRMF_POPOSigningKey (pctxt, this);
   }
}

int ASN1C_CRMF_POPOSigningKey::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CRMF_POPOSigningKey (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CRMF_POPOSigningKey::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CRMF_POPOSigningKey;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CRMF_POPOSigningKey (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CRMF_POPOSigningKey (ASN1T_CRMF_POPOSigningKey* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CRMF_POPOSigningKey;
}

void asn1Free_CRMF_POPOSigningKey (OSCTXT *pctxt, 
   ASN1T_CRMF_POPOSigningKey* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.poposkInputPresent) {
      asn1Free_CRMF_POPOSigningKeyInput (pctxt, &pvalue->poposkInput);
   }
   asn1Free_EXP_AlgorithmIdentifier (pctxt, &pvalue->algorithmIdentifier);
   if (pvalue->signature_.numbits > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->signature_.data);
      pvalue->signature_.numbits = 0;
      pvalue->signature_.data = 0;
   }
}

void ASN1C_CRMF_POPOSigningKey::MemFree ()
{
   asn1Free_CRMF_POPOSigningKey (getCtxtPtr(), &msgData);
}

ASN1T_CRMF_POPOPrivKey* new_ASN1T_CRMF_POPOPrivKey (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CRMF_POPOPrivKey));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CRMF_POPOPrivKey;
}

ASN1C_CRMF_POPOPrivKey::ASN1C_CRMF_POPOPrivKey (ASN1T_CRMF_POPOPrivKey& data)
    : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CRMF_POPOPrivKey::ASN1C_CRMF_POPOPrivKey (OSRTMessageBufferIF& msgBuf
   , ASN1T_CRMF_POPOPrivKey& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CRMF_POPOPrivKey::ASN1C_CRMF_POPOPrivKey (OSRTContext &context
   , ASN1T_CRMF_POPOPrivKey& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CRMF_POPOPrivKey::~ASN1T_CRMF_POPOPrivKey ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CRMF_POPOPrivKey (pctxt, this);
   }
}

int ASN1C_CRMF_POPOPrivKey::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CRMF_POPOPrivKey (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CRMF_POPOPrivKey::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CRMF_POPOPrivKey;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CRMF_POPOPrivKey (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CRMF_POPOPrivKey (ASN1T_CRMF_POPOPrivKey* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CRMF_POPOPrivKey;
}

void asn1Free_CRMF_POPOPrivKey (OSCTXT *pctxt, ASN1T_CRMF_POPOPrivKey* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.thisMessage) {
            if (pvalue->u.thisMessage->numbits > 0) {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.thisMessage->data);
               pvalue->u.thisMessage->numbits = 0;
               pvalue->u.thisMessage->data = 0;
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.thisMessage);
         }
         break;

      case 2:
         break;

      case 3:
         if (0 != pvalue->u.dhMAC) {
            if (pvalue->u.dhMAC->numbits > 0) {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.dhMAC->data);
               pvalue->u.dhMAC->numbits = 0;
               pvalue->u.dhMAC->data = 0;
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dhMAC);
         }
         break;

   }
}

void ASN1C_CRMF_POPOPrivKey::MemFree ()
{
   asn1Free_CRMF_POPOPrivKey (getCtxtPtr(), &msgData);
}

ASN1T_CRMF_ProofOfPossession* 
   new_ASN1T_CRMF_ProofOfPossession (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CRMF_ProofOfPossession));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CRMF_ProofOfPossession;
}

ASN1C_CRMF_ProofOfPossession::ASN1C_CRMF_ProofOfPossession
    (ASN1T_CRMF_ProofOfPossession& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CRMF_ProofOfPossession::ASN1C_CRMF_ProofOfPossession (
   OSRTMessageBufferIF& msgBuf, ASN1T_CRMF_ProofOfPossession& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CRMF_ProofOfPossession::ASN1C_CRMF_ProofOfPossession (
   OSRTContext &context, ASN1T_CRMF_ProofOfPossession& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CRMF_ProofOfPossession::~ASN1T_CRMF_ProofOfPossession ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CRMF_ProofOfPossession (pctxt, this);
   }
}

int ASN1C_CRMF_ProofOfPossession::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CRMF_ProofOfPossession (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CRMF_ProofOfPossession::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CRMF_ProofOfPossession;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CRMF_ProofOfPossession (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CRMF_ProofOfPossession (ASN1T_CRMF_ProofOfPossession* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CRMF_ProofOfPossession;
}

void asn1Free_CRMF_ProofOfPossession (OSCTXT *pctxt, 
   ASN1T_CRMF_ProofOfPossession* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.signature_) {
            asn1Free_CRMF_POPOSigningKey (pctxt, pvalue->u.signature_);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.signature_);
         }
         break;

      case 3:
         if (0 != pvalue->u.keyEncipherment) {
            asn1Free_CRMF_POPOPrivKey (pctxt, pvalue->u.keyEncipherment);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.keyEncipherment);
         }
         break;

      case 4:
         if (0 != pvalue->u.keyAgreement) {
            asn1Free_CRMF_POPOPrivKey (pctxt, pvalue->u.keyAgreement);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.keyAgreement);
         }
         break;

   }
}

void ASN1C_CRMF_ProofOfPossession::MemFree ()
{
   asn1Free_CRMF_ProofOfPossession (getCtxtPtr(), &msgData);
}

ASN1C_CRMF_CertReqMsg_regInfo::ASN1C_CRMF_CertReqMsg_regInfo
    (ASN1T_CRMF_CertReqMsg_regInfo& data) : ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CRMF_CertReqMsg_regInfo::ASN1C_CRMF_CertReqMsg_regInfo (
   OSRTMessageBufferIF& msgBuf, ASN1T_CRMF_CertReqMsg_regInfo& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CRMF_CertReqMsg_regInfo::ASN1C_CRMF_CertReqMsg_regInfo (
   OSRTContext &context, ASN1T_CRMF_CertReqMsg_regInfo& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CRMF_CertReqMsg_regInfo::ASN1C_CRMF_CertReqMsg_regInfo (ASN1CType& ccobj
   , ASN1T_CRMF_CertReqMsg_regInfo& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CRMF_CertReqMsg_regInfo::Append (ASN1T_EXP_AttributeTypeAndValue* elem)
{
   append ((void*)elem);
}

ASN1T_EXP_AttributeTypeAndValue* ASN1C_CRMF_CertReqMsg_regInfo::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_EXP_AttributeTypeAndValue));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_EXP_AttributeTypeAndValue;
}

ASN1T_EXP_AttributeTypeAndValue* ASN1C_CRMF_CertReqMsg_regInfo::AppendNewElement ()
{
   ASN1T_EXP_AttributeTypeAndValue* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CRMF_CertReqMsg_regInfo::~ASN1T_CRMF_CertReqMsg_regInfo ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CRMF_CertReqMsg_regInfo (pctxt, this);
   }
}

int ASN1C_CRMF_CertReqMsg_regInfo::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CRMF_CertReqMsg_regInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CRMF_CertReqMsg_regInfo::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CRMF_CertReqMsg_regInfo;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CRMF_CertReqMsg_regInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CRMF_CertReqMsg_regInfo (ASN1T_CRMF_CertReqMsg_regInfo* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CRMF_CertReqMsg_regInfo;
   rtxDListFastInit (pvalue);
}

void asn1Free_CRMF_CertReqMsg_regInfo (OSCTXT *pctxt, 
   ASN1T_CRMF_CertReqMsg_regInfo* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_EXP_AttributeTypeAndValue* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_EXP_AttributeTypeAndValue*)pnode->data;
      asn1Free_EXP_AttributeTypeAndValue (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CRMF_CertReqMsg_regInfo::MemFree ()
{
   asn1Free_CRMF_CertReqMsg_regInfo (getCtxtPtr(), &msgData);
}

ASN1T_CRMF_CertReqMsg* new_ASN1T_CRMF_CertReqMsg (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CRMF_CertReqMsg));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CRMF_CertReqMsg;
}

ASN1C_CRMF_CertReqMsg::ASN1C_CRMF_CertReqMsg (ASN1T_CRMF_CertReqMsg& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CRMF_CertReqMsg::ASN1C_CRMF_CertReqMsg (OSRTMessageBufferIF& msgBuf
   , ASN1T_CRMF_CertReqMsg& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CRMF_CertReqMsg::ASN1C_CRMF_CertReqMsg (OSRTContext &context
   , ASN1T_CRMF_CertReqMsg& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CRMF_CertReqMsg::ASN1T_CRMF_CertReqMsg ()
{
   m.popPresent = 0;
   m.regInfoPresent = 0;
}

ASN1T_CRMF_CertReqMsg::~ASN1T_CRMF_CertReqMsg ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CRMF_CertReqMsg (pctxt, this);
   }
}

int ASN1C_CRMF_CertReqMsg::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CRMF_CertReqMsg (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CRMF_CertReqMsg::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CRMF_CertReqMsg;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CRMF_CertReqMsg (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CRMF_CertReqMsg (ASN1T_CRMF_CertReqMsg* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CRMF_CertReqMsg;
}

void asn1Free_CRMF_CertReqMsg (OSCTXT *pctxt, ASN1T_CRMF_CertReqMsg* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_CRMF_CertRequest (pctxt, &pvalue->certReq);
   if (pvalue->m.popPresent) {
      asn1Free_CRMF_ProofOfPossession (pctxt, &pvalue->pop);
   }
   if (pvalue->m.regInfoPresent) {
      asn1Free_CRMF_CertReqMsg_regInfo (pctxt, &pvalue->regInfo);
   }
}

void ASN1C_CRMF_CertReqMsg::MemFree ()
{
   asn1Free_CRMF_CertReqMsg (getCtxtPtr(), &msgData);
}

ASN1C_CRMF_CertReqMessages::ASN1C_CRMF_CertReqMessages
    (ASN1T_CRMF_CertReqMessages& data) : ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CRMF_CertReqMessages::ASN1C_CRMF_CertReqMessages (
   OSRTMessageBufferIF& msgBuf, ASN1T_CRMF_CertReqMessages& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CRMF_CertReqMessages::ASN1C_CRMF_CertReqMessages (OSRTContext &context
   , ASN1T_CRMF_CertReqMessages& data) : ASN1CSeqOfList(context, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CRMF_CertReqMessages::ASN1C_CRMF_CertReqMessages (ASN1CType& ccobj
   , ASN1T_CRMF_CertReqMessages& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CRMF_CertReqMessages::Append (ASN1T_CRMF_CertReqMsg* elem)
{
   append ((void*)elem);
}

ASN1T_CRMF_CertReqMsg* ASN1C_CRMF_CertReqMessages::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_CRMF_CertReqMsg));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CRMF_CertReqMsg;
}

ASN1T_CRMF_CertReqMsg* ASN1C_CRMF_CertReqMessages::AppendNewElement ()
{
   ASN1T_CRMF_CertReqMsg* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CRMF_CertReqMessages::~ASN1T_CRMF_CertReqMessages ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CRMF_CertReqMessages (pctxt, this);
   }
}

int ASN1C_CRMF_CertReqMessages::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CRMF_CertReqMessages (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CRMF_CertReqMessages::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CRMF_CertReqMessages;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CRMF_CertReqMessages (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CRMF_CertReqMessages (ASN1T_CRMF_CertReqMessages* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CRMF_CertReqMessages;
   rtxDListFastInit (pvalue);
}

void asn1Free_CRMF_CertReqMessages (OSCTXT *pctxt, 
   ASN1T_CRMF_CertReqMessages* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_CRMF_CertReqMsg* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_CRMF_CertReqMsg*)pnode->data;
      asn1Free_CRMF_CertReqMsg (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CRMF_CertReqMessages::MemFree ()
{
   asn1Free_CRMF_CertReqMessages (getCtxtPtr(), &msgData);
}

