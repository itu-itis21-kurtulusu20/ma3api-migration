/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.6, Date: 20-Feb-2014.
 */
#include "algorithms.h"
#include "rtxsrc/rtxCommon.h"

EXTERN int asn1D_ALGOS_KEA_Parms_Id (OSCTXT* pctxt, 
   ASN1T_ALGOS_KEA_Parms_Id* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "KEA-Parms-Id");

   stat = xd_octstr (pctxt, &pvalue->data, &pvalue->numocts, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ALGOS_Prime_p (OSCTXT* pctxt, ASN1T_ALGOS_Prime_p* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Prime-p");

   stat = xd_integer (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ALGOS_Trinomial (OSCTXT* pctxt, 
   ASN1T_ALGOS_Trinomial* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Trinomial");

   stat = xd_integer (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ALGOS_FieldElement (OSCTXT* pctxt, 
   ASN1T_ALGOS_FieldElement* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "FieldElement");

   stat = xd_octstr (pctxt, &pvalue->data, &pvalue->numocts, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ALGOS_ECPoint (OSCTXT* pctxt, ASN1T_ALGOS_ECPoint* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ECPoint");

   stat = xd_octstr (pctxt, &pvalue->data, &pvalue->numocts, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ALGOS_HashAlgorithm (OSCTXT* pctxt, 
   ASN1T_ALGOS_HashAlgorithm* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HashAlgorithm");

   stat = asn1D_EXP_AlgorithmIdentifier (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ALGOS_SpecifiedECDomainVersion (OSCTXT* pctxt, 
   ASN1T_ALGOS_SpecifiedECDomainVersion* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SpecifiedECDomainVersion");

   stat = xd_integer (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ALGOS_ECPVer (OSCTXT* pctxt, ASN1T_ALGOS_ECPVer* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ECPVer");

   stat = xd_integer (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ALGOS_ECPrivateKey_version (OSCTXT* pctxt, 
   ASN1T_ALGOS_ECPrivateKey_version* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_uint8 (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!(*pvalue == 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)*pvalue);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

EXTERN int asn1D_ALGOS_Dss_Parms (OSCTXT* pctxt, 
   ASN1T_ALGOS_Dss_Parms* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "Dss-Parms");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode p */
         RTXCTXTPUSHELEMNAME (pctxt, "p");

         stat = xd_integer (pctxt, &pvalue->p, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode q */
         RTXCTXTPUSHELEMNAME (pctxt, "q");

         stat = xd_integer (pctxt, &pvalue->q, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode g */
         RTXCTXTPUSHELEMNAME (pctxt, "g");

         stat = xd_integer (pctxt, &pvalue->g, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ALGOS_DssSigValue (OSCTXT* pctxt, 
   ASN1T_ALGOS_DssSigValue* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "DssSigValue");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode r */
         RTXCTXTPUSHELEMNAME (pctxt, "r");

         stat = xd_bigint (pctxt, &pvalue->r, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode s */
         RTXCTXTPUSHELEMNAME (pctxt, "s");

         stat = xd_bigint (pctxt, &pvalue->s, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ALGOS_ValidationParms (OSCTXT* pctxt, 
   ASN1T_ALGOS_ValidationParms* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "ValidationParms");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode seed */
         RTXCTXTPUSHELEMNAME (pctxt, "seed");

         stat = xd_bitstr (pctxt, &pvalue->seed.data, &pvalue->seed.numbits, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode pgenCounter */
         RTXCTXTPUSHELEMNAME (pctxt, "pgenCounter");

         stat = xd_integer (pctxt, &pvalue->pgenCounter, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|3):
         case (TM_UNIV|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ALGOS_DomainParameters (OSCTXT* pctxt, 
   ASN1T_ALGOS_DomainParameters* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "DomainParameters");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode p */
         RTXCTXTPUSHELEMNAME (pctxt, "p");

         stat = xd_integer (pctxt, &pvalue->p, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode g */
         RTXCTXTPUSHELEMNAME (pctxt, "g");

         stat = xd_integer (pctxt, &pvalue->g, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode q */
         RTXCTXTPUSHELEMNAME (pctxt, "q");

         stat = xd_integer (pctxt, &pvalue->q, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 3:
         /* decode j */
         if (XD_PEEKTAG (pctxt, 0x2)) {
            RTXCTXTPUSHELEMNAME (pctxt, "j");

            stat = xd_integer (pctxt, &pvalue->j, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.jPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 4:
         /* decode validationParms */
         if (XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "validationParms");

            stat = asn1D_ALGOS_ValidationParms (pctxt, &pvalue->validationParms
               , ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.validationParmsPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|2):
         case (TM_UNIV|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ALGOS_FieldID (OSCTXT* pctxt, ASN1T_ALGOS_FieldID* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "FieldID");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode fieldType */
         RTXCTXTPUSHELEMNAME (pctxt, "fieldType");

         stat = xd_objid (pctxt, (ASN1OBJID*)&pvalue->fieldType, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode parameters */
         RTXCTXTPUSHELEMNAME (pctxt, "parameters");

         stat = xd_OpenType (pctxt, &pvalue->parameters.data, &pvalue->parameters.numocts);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ALGOS_ECDSASigValue (OSCTXT* pctxt, 
   ASN1T_ALGOS_ECDSASigValue* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "ECDSASigValue");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode r */
         RTXCTXTPUSHELEMNAME (pctxt, "r");

         stat = xd_bigint (pctxt, &pvalue->r, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode s */
         RTXCTXTPUSHELEMNAME (pctxt, "s");

         stat = xd_bigint (pctxt, &pvalue->s, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ALGOS_Characteristic_two (OSCTXT* pctxt, 
   ASN1T_ALGOS_Characteristic_two* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "Characteristic-two");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode m_ */
         RTXCTXTPUSHELEMNAME (pctxt, "m");

         stat = xd_integer (pctxt, &pvalue->m_, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode basis */
         RTXCTXTPUSHELEMNAME (pctxt, "basis");

         stat = xd_objid (pctxt, (ASN1OBJID*)&pvalue->basis, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode parameters */
         RTXCTXTPUSHELEMNAME (pctxt, "parameters");

         stat = xd_OpenType (pctxt, &pvalue->parameters.data, &pvalue->parameters.numocts);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|2):
         case (TM_UNIV|TM_PRIM|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ALGOS_Pentanomial (OSCTXT* pctxt, 
   ASN1T_ALGOS_Pentanomial* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "Pentanomial");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode k1 */
         RTXCTXTPUSHELEMNAME (pctxt, "k1");

         stat = xd_integer (pctxt, &pvalue->k1, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode k2 */
         RTXCTXTPUSHELEMNAME (pctxt, "k2");

         stat = xd_integer (pctxt, &pvalue->k2, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode k3 */
         RTXCTXTPUSHELEMNAME (pctxt, "k3");

         stat = xd_integer (pctxt, &pvalue->k3, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ALGOS_Curve (OSCTXT* pctxt, ASN1T_ALGOS_Curve* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "Curve");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode a */
         RTXCTXTPUSHELEMNAME (pctxt, "a");

         stat = asn1D_ALGOS_FieldElement (pctxt, &pvalue->a, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode b */
         RTXCTXTPUSHELEMNAME (pctxt, "b");

         stat = asn1D_ALGOS_FieldElement (pctxt, &pvalue->b, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode seed */
         if (XD_PEEKTAG (pctxt, 0x3)) {
            RTXCTXTPUSHELEMNAME (pctxt, "seed");

            stat = xd_bitstr (pctxt, &pvalue->seed.data, &pvalue->seed.numbits, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.seedPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|4):
         case (TM_UNIV|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ALGOS_SpecifiedECDomain (OSCTXT* pctxt, 
   ASN1T_ALGOS_SpecifiedECDomain* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "SpecifiedECDomain");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode version */
         RTXCTXTPUSHELEMNAME (pctxt, "version");

         stat = xd_integer (pctxt, &pvalue->version, ASN1EXPL, length);
         if (stat == 0) {
            if (!((pvalue->version == 1 || pvalue->version == 2 || pvalue->version == 3))) {
               rtxErrAddElemNameParm (pctxt);
               rtxErrAddIntParm (pctxt, pvalue->version);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

         }
         else return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode fieldID */
         RTXCTXTPUSHELEMNAME (pctxt, "fieldID");

         stat = asn1D_ALGOS_FieldID (pctxt, &pvalue->fieldID, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode curve */
         RTXCTXTPUSHELEMNAME (pctxt, "curve");

         stat = asn1D_ALGOS_Curve (pctxt, &pvalue->curve, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 3:
         /* decode base */
         RTXCTXTPUSHELEMNAME (pctxt, "base");

         stat = asn1D_ALGOS_ECPoint (pctxt, &pvalue->base, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 4:
         /* decode order */
         RTXCTXTPUSHELEMNAME (pctxt, "order");

         stat = xd_bigint (pctxt, &pvalue->order, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 5:
         /* decode cofactor */
         if (XD_PEEKTAG (pctxt, 0x2)) {
            RTXCTXTPUSHELEMNAME (pctxt, "cofactor");

            stat = xd_bigint (pctxt, &pvalue->cofactor, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.cofactorPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 6:
         /* decode hash */
         if (XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "hash");

            stat = asn1D_ALGOS_HashAlgorithm (pctxt, &pvalue->hash, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.hashPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|2):
         case (TM_UNIV|TM_CONS|16):
         case (TM_UNIV|TM_PRIM|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 5) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ALGOS_ECParameters (OSCTXT* pctxt, 
   ASN1T_ALGOS_ECParameters* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "ECParameters");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_UNIV|TM_PRIM|5):
         RTXCTXTPUSHELEMNAME (pctxt, "implicitCurve");

         stat = xd_null (pctxt, ASN1IMPL);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|6):
         RTXCTXTPUSHELEMNAME (pctxt, "namedCurve");

         pvalue->u.namedCurve = rtxMemAllocType (pctxt, ASN1TObjId);

         if (pvalue->u.namedCurve == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.namedCurve->numids = 0;
         stat = xd_objid (pctxt, (ASN1OBJID*)pvalue->u.namedCurve, ASN1IMPL, length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_CONS|16):
         RTXCTXTPUSHELEMNAME (pctxt, "specifiedCurve");

         pvalue->u.specifiedCurve = rtxMemAllocType (pctxt, 
            ASN1T_ALGOS_SpecifiedECDomain);

         if (pvalue->u.specifiedCurve == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ALGOS_SpecifiedECDomain (pvalue->u.specifiedCurve);
         stat = asn1D_ALGOS_SpecifiedECDomain (pctxt, pvalue->u.specifiedCurve
            , ASN1IMPL, length);
         pvalue->t = 3;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ALGOS_ECPrivateKey (OSCTXT* pctxt, 
   ASN1T_ALGOS_ECPrivateKey* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "ECPrivateKey");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode version */
         RTXCTXTPUSHELEMNAME (pctxt, "version");

         stat = asn1D_ALGOS_ECPrivateKey_version (pctxt, &pvalue->version, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode privateKey */
         RTXCTXTPUSHELEMNAME (pctxt, "privateKey");

         stat = xd_octstr (pctxt, &pvalue->privateKey.data, &pvalue->privateKey.numocts, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode parameters */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "parameters");

            stat = asn1D_ALGOS_ECParameters (pctxt, &pvalue->parameters, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.parametersPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 3:
         /* decode publicKey */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "publicKey");

            stat = xd_bitstr (pctxt, &pvalue->publicKey.data, &pvalue->publicKey.numbits, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.publicKeyPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|2):
         case (TM_UNIV|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ALGOS_RSASSA_PSS_params (OSCTXT* pctxt, 
   ASN1T_ALGOS_RSASSA_PSS_params* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "RSASSA-PSS-params");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
      pvalue->saltLength = 20;
      pvalue->trailerField = 1;
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode hashAlgorithm */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "hashAlgorithm");

            stat = asn1D_EXP_AlgorithmIdentifier (pctxt, &pvalue->hashAlgorithm
               , ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.hashAlgorithmPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 1:
         /* decode maskGenAlgorithm */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "maskGenAlgorithm");

            stat = asn1D_EXP_AlgorithmIdentifier (pctxt, &pvalue->
               maskGenAlgorithm, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.maskGenAlgorithmPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 2:
         /* decode saltLength */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "saltLength");

            stat = xd_integer (pctxt, &pvalue->saltLength, ASN1EXPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 3:
         /* decode trailerField */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "trailerField");

            stat = xd_integer (pctxt, &pvalue->trailerField, ASN1EXPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

