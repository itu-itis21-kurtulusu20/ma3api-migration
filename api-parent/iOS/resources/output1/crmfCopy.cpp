/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.6, Date: 20-Feb-2014.
 */
#include <new>
#include "crmf.h"
#include "rtsrc/rtCopy.h"
#include "rtxsrc/rtxCommon.h"

void asn1Copy_CRMF_OptionalValidity (OSCTXT* pctxt, 
   ASN1T_CRMF_OptionalValidity* pSrcValue, ASN1T_CRMF_OptionalValidity*
    pDstValue)
{
   if (pSrcValue == pDstValue) return;

   OSCRTLMEMCPY (&pDstValue->m, &pSrcValue->m, sizeof (pDstValue->m));
   if (pSrcValue->m.notBeforePresent) {
      asn1Copy_EXP_Time (pctxt, &pSrcValue->notBefore, &pDstValue->notBefore);
   }

   if (pSrcValue->m.notAfterPresent) {
      asn1Copy_EXP_Time (pctxt, &pSrcValue->notAfter, &pDstValue->notAfter);
   }

}

ASN1C_CRMF_OptionalValidity::ASN1C_CRMF_OptionalValidity (ASN1C_CRMF_OptionalValidity& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CRMF_OptionalValidity::ASN1T_CRMF_OptionalValidity (ASN1C_CRMF_OptionalValidity& original)
{
   original.getCopy (this);
}

ASN1T_CRMF_OptionalValidity& ASN1C_CRMF_OptionalValidity::getCopy (ASN1T_CRMF_OptionalValidity* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CRMF_OptionalValidity);
      new (pDstData) ASN1T_CRMF_OptionalValidity;
   }

   asn1Copy_CRMF_OptionalValidity (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CRMF_OptionalValidity* ASN1C_CRMF_OptionalValidity::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CRMF_OptionalValidity* pDstData = new ASN1T_CRMF_OptionalValidity;

   asn1Copy_CRMF_OptionalValidity (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CRMF_CertTemplate (OSCTXT* pctxt, 
   ASN1T_CRMF_CertTemplate* pSrcValue, ASN1T_CRMF_CertTemplate* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   OSCRTLMEMCPY (&pDstValue->m, &pSrcValue->m, sizeof (pDstValue->m));
   if (pSrcValue->m.versionPresent) {
      pDstValue->version = pSrcValue->version;
   }

   if (pSrcValue->m.serialNumberPresent) {
      asn1Copy_EXP_CertificateSerialNumber (pctxt, &pSrcValue->serialNumber, &pDstValue->serialNumber);
   }

   if (pSrcValue->m.signingAlgPresent) {
      asn1Copy_EXP_AlgorithmIdentifier (pctxt, &pSrcValue->signingAlg, &pDstValue->signingAlg);
   }

   if (pSrcValue->m.issuerPresent) {
      asn1Copy_EXP_Name (pctxt, &pSrcValue->issuer, &pDstValue->issuer);
   }

   if (pSrcValue->m.validityPresent) {
      asn1Copy_CRMF_OptionalValidity (pctxt, &pSrcValue->validity, &pDstValue->validity);
   }

   if (pSrcValue->m.subjectPresent) {
      asn1Copy_EXP_Name (pctxt, &pSrcValue->subject, &pDstValue->subject);
   }

   if (pSrcValue->m.publicKeyPresent) {
      asn1Copy_EXP_SubjectPublicKeyInfo (pctxt, &pSrcValue->publicKey, &pDstValue->publicKey);
   }

   if (pSrcValue->m.issuerUIDPresent) {
      asn1Copy_EXP_UniqueIdentifier (pctxt, &pSrcValue->issuerUID, &pDstValue->issuerUID);
   }

   if (pSrcValue->m.subjectUIDPresent) {
      asn1Copy_EXP_UniqueIdentifier (pctxt, &pSrcValue->subjectUID, &pDstValue->subjectUID);
   }

   if (pSrcValue->m.extensionsPresent) {
      asn1Copy_EXP_Extensions (pctxt, &pSrcValue->extensions, &pDstValue->extensions);
   }

}

ASN1C_CRMF_CertTemplate::ASN1C_CRMF_CertTemplate (ASN1C_CRMF_CertTemplate& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CRMF_CertTemplate::ASN1T_CRMF_CertTemplate (ASN1C_CRMF_CertTemplate& original)
{
   original.getCopy (this);
}

ASN1T_CRMF_CertTemplate& ASN1C_CRMF_CertTemplate::getCopy (ASN1T_CRMF_CertTemplate* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CRMF_CertTemplate);
      new (pDstData) ASN1T_CRMF_CertTemplate;
   }

   asn1Copy_CRMF_CertTemplate (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CRMF_CertTemplate* ASN1C_CRMF_CertTemplate::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CRMF_CertTemplate* pDstData = new ASN1T_CRMF_CertTemplate;

   asn1Copy_CRMF_CertTemplate (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CRMF_SinglePubInfo (OSCTXT* pctxt, 
   ASN1T_CRMF_SinglePubInfo* pSrcValue, ASN1T_CRMF_SinglePubInfo* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   OSCRTLMEMCPY (&pDstValue->m, &pSrcValue->m, sizeof (pDstValue->m));
   pDstValue->pubMethod = pSrcValue->pubMethod;

   if (pSrcValue->m.pubLocationPresent) {
      asn1Copy_IMP_GeneralName (pctxt, &pSrcValue->pubLocation, &pDstValue->pubLocation);
   }

}

ASN1C_CRMF_SinglePubInfo::ASN1C_CRMF_SinglePubInfo (ASN1C_CRMF_SinglePubInfo& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CRMF_SinglePubInfo::ASN1T_CRMF_SinglePubInfo (ASN1C_CRMF_SinglePubInfo& original)
{
   original.getCopy (this);
}

ASN1T_CRMF_SinglePubInfo& ASN1C_CRMF_SinglePubInfo::getCopy (ASN1T_CRMF_SinglePubInfo* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CRMF_SinglePubInfo);
      new (pDstData) ASN1T_CRMF_SinglePubInfo;
   }

   asn1Copy_CRMF_SinglePubInfo (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CRMF_SinglePubInfo* ASN1C_CRMF_SinglePubInfo::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CRMF_SinglePubInfo* pDstData = new ASN1T_CRMF_SinglePubInfo;

   asn1Copy_CRMF_SinglePubInfo (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CRMF_PKIPublicationInfo_pubInfos (OSCTXT* pctxt, 
   ASN1T_CRMF_PKIPublicationInfo_pubInfos* pSrcValue, 
   ASN1T_CRMF_PKIPublicationInfo_pubInfos* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   {
      OSUINT32 xx1;
      ASN1T_CRMF_SinglePubInfo* pSrcData;
      OSRTDListNode* pnode;

      rtxDListInit (pDstValue);
      pnode = pSrcValue->head;
      for (xx1 = 0; xx1 < pSrcValue->count; xx1++) {
         ASN1T_CRMF_SinglePubInfo* pDstData = rtxMemAllocTypeZ (pctxt, ASN1T_CRMF_SinglePubInfo);
         pSrcData = (ASN1T_CRMF_SinglePubInfo*) pnode->data;

         asn1Copy_CRMF_SinglePubInfo (pctxt, pSrcData, pDstData);

         rtxDListAppend (pctxt, pDstValue, (void*)pDstData);
         pnode = pnode->next;
      }
   }
}

ASN1C_CRMF_PKIPublicationInfo_pubInfos::ASN1C_CRMF_PKIPublicationInfo_pubInfos (ASN1C_CRMF_PKIPublicationInfo_pubInfos& original) :
   ASN1CSeqOfList(*original.mpContext, original.getCopy()), msgData (*(ASN1T_CRMF_PKIPublicationInfo_pubInfos*)pList)
{
}

ASN1C_CRMF_PKIPublicationInfo_pubInfos& ASN1C_CRMF_PKIPublicationInfo_pubInfos::operator= (ASN1C_CRMF_PKIPublicationInfo_pubInfos& srcData)
{
   clear ();
   asn1Copy_CRMF_PKIPublicationInfo_pubInfos (getCtxtPtr(), &srcData.msgData, &msgData);
   return *this;
}

ASN1T_CRMF_PKIPublicationInfo_pubInfos& ASN1C_CRMF_PKIPublicationInfo_pubInfos::getCopy (ASN1T_CRMF_PKIPublicationInfo_pubInfos* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CRMF_PKIPublicationInfo_pubInfos);
      new (pDstData) ASN1T_CRMF_PKIPublicationInfo_pubInfos;
   }

   asn1Copy_CRMF_PKIPublicationInfo_pubInfos (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CRMF_PKIPublicationInfo_pubInfos* ASN1C_CRMF_PKIPublicationInfo_pubInfos::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CRMF_PKIPublicationInfo_pubInfos* pDstData = new ASN1T_CRMF_PKIPublicationInfo_pubInfos;

   asn1Copy_CRMF_PKIPublicationInfo_pubInfos (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CRMF_PKIPublicationInfo (OSCTXT* pctxt, 
   ASN1T_CRMF_PKIPublicationInfo* pSrcValue, ASN1T_CRMF_PKIPublicationInfo*
    pDstValue)
{
   if (pSrcValue == pDstValue) return;

   OSCRTLMEMCPY (&pDstValue->m, &pSrcValue->m, sizeof (pDstValue->m));
   pDstValue->action = pSrcValue->action;

   if (pSrcValue->m.pubInfosPresent) {
      asn1Copy_CRMF_PKIPublicationInfo_pubInfos (pctxt, &pSrcValue->pubInfos, &pDstValue->pubInfos);
   }

}

ASN1C_CRMF_PKIPublicationInfo::ASN1C_CRMF_PKIPublicationInfo (ASN1C_CRMF_PKIPublicationInfo& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CRMF_PKIPublicationInfo::ASN1T_CRMF_PKIPublicationInfo (ASN1C_CRMF_PKIPublicationInfo& original)
{
   original.getCopy (this);
}

ASN1T_CRMF_PKIPublicationInfo& ASN1C_CRMF_PKIPublicationInfo::getCopy (ASN1T_CRMF_PKIPublicationInfo* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CRMF_PKIPublicationInfo);
      new (pDstData) ASN1T_CRMF_PKIPublicationInfo;
   }

   asn1Copy_CRMF_PKIPublicationInfo (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CRMF_PKIPublicationInfo* ASN1C_CRMF_PKIPublicationInfo::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CRMF_PKIPublicationInfo* pDstData = new ASN1T_CRMF_PKIPublicationInfo;

   asn1Copy_CRMF_PKIPublicationInfo (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CRMF_EncryptedValue (OSCTXT* pctxt, 
   ASN1T_CRMF_EncryptedValue* pSrcValue, ASN1T_CRMF_EncryptedValue* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   OSCRTLMEMCPY (&pDstValue->m, &pSrcValue->m, sizeof (pDstValue->m));
   if (pSrcValue->m.intendedAlgPresent) {
      asn1Copy_EXP_AlgorithmIdentifier (pctxt, &pSrcValue->intendedAlg, &pDstValue->intendedAlg);
   }

   if (pSrcValue->m.symmAlgPresent) {
      asn1Copy_EXP_AlgorithmIdentifier (pctxt, &pSrcValue->symmAlg, &pDstValue->symmAlg);
   }

   if (pSrcValue->m.encSymmKeyPresent) {
      rtCopyDynBitStr (pctxt, &pSrcValue->encSymmKey, &pDstValue->encSymmKey);
   }

   if (pSrcValue->m.keyAlgPresent) {
      asn1Copy_EXP_AlgorithmIdentifier (pctxt, &pSrcValue->keyAlg, &pDstValue->keyAlg);
   }

   if (pSrcValue->m.valueHintPresent) {
      rtCopyDynOctStr (pctxt, &pSrcValue->valueHint, &pDstValue->valueHint);
   }

   rtCopyDynBitStr (pctxt, &pSrcValue->encValue, &pDstValue->encValue);

}

ASN1C_CRMF_EncryptedValue::ASN1C_CRMF_EncryptedValue (ASN1C_CRMF_EncryptedValue& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CRMF_EncryptedValue::ASN1T_CRMF_EncryptedValue (ASN1C_CRMF_EncryptedValue& original)
{
   original.getCopy (this);
}

ASN1T_CRMF_EncryptedValue& ASN1C_CRMF_EncryptedValue::getCopy (ASN1T_CRMF_EncryptedValue* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CRMF_EncryptedValue);
      new (pDstData) ASN1T_CRMF_EncryptedValue;
   }

   asn1Copy_CRMF_EncryptedValue (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CRMF_EncryptedValue* ASN1C_CRMF_EncryptedValue::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CRMF_EncryptedValue* pDstData = new ASN1T_CRMF_EncryptedValue;

   asn1Copy_CRMF_EncryptedValue (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CRMF_CertId (OSCTXT* pctxt, ASN1T_CRMF_CertId* pSrcValue, 
   ASN1T_CRMF_CertId* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   asn1Copy_IMP_GeneralName (pctxt, &pSrcValue->issuer, &pDstValue->issuer);

   asn1Copy_EXP_CertificateSerialNumber (pctxt, &pSrcValue->serialNumber, &pDstValue->serialNumber);

}

ASN1C_CRMF_CertId::ASN1C_CRMF_CertId (ASN1C_CRMF_CertId& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CRMF_CertId::ASN1T_CRMF_CertId (ASN1C_CRMF_CertId& original)
{
   original.getCopy (this);
}

ASN1T_CRMF_CertId& ASN1C_CRMF_CertId::getCopy (ASN1T_CRMF_CertId* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CRMF_CertId);
      new (pDstData) ASN1T_CRMF_CertId;
   }

   asn1Copy_CRMF_CertId (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CRMF_CertId* ASN1C_CRMF_CertId::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CRMF_CertId* pDstData = new ASN1T_CRMF_CertId;

   asn1Copy_CRMF_CertId (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CRMF_Controls (OSCTXT* pctxt, ASN1T_CRMF_Controls* pSrcValue, 
   ASN1T_CRMF_Controls* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   {
      OSUINT32 xx1;
      ASN1T_EXP_AttributeTypeAndValue* pSrcData;
      OSRTDListNode* pnode;

      rtxDListInit (pDstValue);
      pnode = pSrcValue->head;
      for (xx1 = 0; xx1 < pSrcValue->count; xx1++) {
         ASN1T_EXP_AttributeTypeAndValue* pDstData = rtxMemAllocTypeZ (pctxt, ASN1T_EXP_AttributeTypeAndValue);
         pSrcData = (ASN1T_EXP_AttributeTypeAndValue*) pnode->data;

         asn1Copy_EXP_AttributeTypeAndValue (pctxt, pSrcData, pDstData);

         rtxDListAppend (pctxt, pDstValue, (void*)pDstData);
         pnode = pnode->next;
      }
   }
}

ASN1C_CRMF_Controls::ASN1C_CRMF_Controls (ASN1C_CRMF_Controls& original) :
   ASN1CSeqOfList(*original.mpContext, original.getCopy()), msgData (*(ASN1T_CRMF_Controls*)pList)
{
}

ASN1C_CRMF_Controls& ASN1C_CRMF_Controls::operator= (ASN1C_CRMF_Controls& srcData)
{
   clear ();
   asn1Copy_CRMF_Controls (getCtxtPtr(), &srcData.msgData, &msgData);
   return *this;
}

ASN1T_CRMF_Controls& ASN1C_CRMF_Controls::getCopy (ASN1T_CRMF_Controls* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CRMF_Controls);
      new (pDstData) ASN1T_CRMF_Controls;
   }

   asn1Copy_CRMF_Controls (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CRMF_Controls* ASN1C_CRMF_Controls::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CRMF_Controls* pDstData = new ASN1T_CRMF_Controls;

   asn1Copy_CRMF_Controls (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CRMF_CertRequest (OSCTXT* pctxt, 
   ASN1T_CRMF_CertRequest* pSrcValue, ASN1T_CRMF_CertRequest* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   OSCRTLMEMCPY (&pDstValue->m, &pSrcValue->m, sizeof (pDstValue->m));
   pDstValue->certReqId = pSrcValue->certReqId;

   asn1Copy_CRMF_CertTemplate (pctxt, &pSrcValue->certTemplate, &pDstValue->certTemplate);

   if (pSrcValue->m.controlsPresent) {
      asn1Copy_CRMF_Controls (pctxt, &pSrcValue->controls, &pDstValue->controls);
   }

}

ASN1C_CRMF_CertRequest::ASN1C_CRMF_CertRequest (ASN1C_CRMF_CertRequest& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CRMF_CertRequest::ASN1T_CRMF_CertRequest (ASN1C_CRMF_CertRequest& original)
{
   original.getCopy (this);
}

ASN1T_CRMF_CertRequest& ASN1C_CRMF_CertRequest::getCopy (ASN1T_CRMF_CertRequest* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CRMF_CertRequest);
      new (pDstData) ASN1T_CRMF_CertRequest;
   }

   asn1Copy_CRMF_CertRequest (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CRMF_CertRequest* ASN1C_CRMF_CertRequest::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CRMF_CertRequest* pDstData = new ASN1T_CRMF_CertRequest;

   asn1Copy_CRMF_CertRequest (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CRMF_PKMACValue (OSCTXT* pctxt, 
   ASN1T_CRMF_PKMACValue* pSrcValue, ASN1T_CRMF_PKMACValue* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   asn1Copy_EXP_AlgorithmIdentifier (pctxt, &pSrcValue->algId, &pDstValue->algId);

   rtCopyDynBitStr (pctxt, &pSrcValue->value, &pDstValue->value);

}

ASN1C_CRMF_PKMACValue::ASN1C_CRMF_PKMACValue (ASN1C_CRMF_PKMACValue& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CRMF_PKMACValue::ASN1T_CRMF_PKMACValue (ASN1C_CRMF_PKMACValue& original)
{
   original.getCopy (this);
}

ASN1T_CRMF_PKMACValue& ASN1C_CRMF_PKMACValue::getCopy (ASN1T_CRMF_PKMACValue* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CRMF_PKMACValue);
      new (pDstData) ASN1T_CRMF_PKMACValue;
   }

   asn1Copy_CRMF_PKMACValue (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CRMF_PKMACValue* ASN1C_CRMF_PKMACValue::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CRMF_PKMACValue* pDstData = new ASN1T_CRMF_PKMACValue;

   asn1Copy_CRMF_PKMACValue (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CRMF_POPOSigningKeyInput_authInfo (OSCTXT* pctxt, 
   ASN1T_CRMF_POPOSigningKeyInput_authInfo* pSrcValue, 
   ASN1T_CRMF_POPOSigningKeyInput_authInfo* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   pDstValue->t = pSrcValue->t;
   switch (pSrcValue->t)
   {
      /* publicKeyMAC */
      case 1:
         pDstValue->u.publicKeyMAC = rtxMemAllocType (pctxt, ASN1T_CRMF_PKMACValue);
         new (pDstValue->u.publicKeyMAC) ASN1T_CRMF_PKMACValue;
         asn1Copy_CRMF_PKMACValue (pctxt, pSrcValue->u.publicKeyMAC, pDstValue->u.publicKeyMAC);
         break;

      /* sender */
      case 2:
         pDstValue->u.sender = rtxMemAllocType (pctxt, ASN1T_IMP_GeneralName);
         new (pDstValue->u.sender) ASN1T_IMP_GeneralName;
         asn1Copy_IMP_GeneralName (pctxt, pSrcValue->u.sender, pDstValue->u.sender);
         break;

   }
}

ASN1C_CRMF_POPOSigningKeyInput_authInfo::ASN1C_CRMF_POPOSigningKeyInput_authInfo (ASN1C_CRMF_POPOSigningKeyInput_authInfo& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CRMF_POPOSigningKeyInput_authInfo::ASN1T_CRMF_POPOSigningKeyInput_authInfo (ASN1C_CRMF_POPOSigningKeyInput_authInfo& original)
{
   original.getCopy (this);
}

ASN1T_CRMF_POPOSigningKeyInput_authInfo& ASN1C_CRMF_POPOSigningKeyInput_authInfo::getCopy (ASN1T_CRMF_POPOSigningKeyInput_authInfo* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CRMF_POPOSigningKeyInput_authInfo);
      new (pDstData) ASN1T_CRMF_POPOSigningKeyInput_authInfo;
   }

   asn1Copy_CRMF_POPOSigningKeyInput_authInfo (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CRMF_POPOSigningKeyInput_authInfo* ASN1C_CRMF_POPOSigningKeyInput_authInfo::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CRMF_POPOSigningKeyInput_authInfo* pDstData = new ASN1T_CRMF_POPOSigningKeyInput_authInfo;

   asn1Copy_CRMF_POPOSigningKeyInput_authInfo (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CRMF_POPOSigningKeyInput (OSCTXT* pctxt, 
   ASN1T_CRMF_POPOSigningKeyInput* pSrcValue, ASN1T_CRMF_POPOSigningKeyInput*
    pDstValue)
{
   if (pSrcValue == pDstValue) return;

   asn1Copy_CRMF_POPOSigningKeyInput_authInfo (pctxt, &pSrcValue->authInfo, &pDstValue->authInfo);

   asn1Copy_EXP_SubjectPublicKeyInfo (pctxt, &pSrcValue->publicKey, &pDstValue->publicKey);

}

ASN1C_CRMF_POPOSigningKeyInput::ASN1C_CRMF_POPOSigningKeyInput (ASN1C_CRMF_POPOSigningKeyInput& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CRMF_POPOSigningKeyInput::ASN1T_CRMF_POPOSigningKeyInput (ASN1C_CRMF_POPOSigningKeyInput& original)
{
   original.getCopy (this);
}

ASN1T_CRMF_POPOSigningKeyInput& ASN1C_CRMF_POPOSigningKeyInput::getCopy (ASN1T_CRMF_POPOSigningKeyInput* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CRMF_POPOSigningKeyInput);
      new (pDstData) ASN1T_CRMF_POPOSigningKeyInput;
   }

   asn1Copy_CRMF_POPOSigningKeyInput (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CRMF_POPOSigningKeyInput* ASN1C_CRMF_POPOSigningKeyInput::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CRMF_POPOSigningKeyInput* pDstData = new ASN1T_CRMF_POPOSigningKeyInput;

   asn1Copy_CRMF_POPOSigningKeyInput (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CRMF_POPOSigningKey (OSCTXT* pctxt, 
   ASN1T_CRMF_POPOSigningKey* pSrcValue, ASN1T_CRMF_POPOSigningKey* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   OSCRTLMEMCPY (&pDstValue->m, &pSrcValue->m, sizeof (pDstValue->m));
   if (pSrcValue->m.poposkInputPresent) {
      asn1Copy_CRMF_POPOSigningKeyInput (pctxt, &pSrcValue->poposkInput, &pDstValue->poposkInput);
   }

   asn1Copy_EXP_AlgorithmIdentifier (pctxt, &pSrcValue->algorithmIdentifier, &pDstValue->algorithmIdentifier);

   rtCopyDynBitStr (pctxt, &pSrcValue->signature_, &pDstValue->signature_);

}

ASN1C_CRMF_POPOSigningKey::ASN1C_CRMF_POPOSigningKey (ASN1C_CRMF_POPOSigningKey& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CRMF_POPOSigningKey::ASN1T_CRMF_POPOSigningKey (ASN1C_CRMF_POPOSigningKey& original)
{
   original.getCopy (this);
}

ASN1T_CRMF_POPOSigningKey& ASN1C_CRMF_POPOSigningKey::getCopy (ASN1T_CRMF_POPOSigningKey* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CRMF_POPOSigningKey);
      new (pDstData) ASN1T_CRMF_POPOSigningKey;
   }

   asn1Copy_CRMF_POPOSigningKey (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CRMF_POPOSigningKey* ASN1C_CRMF_POPOSigningKey::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CRMF_POPOSigningKey* pDstData = new ASN1T_CRMF_POPOSigningKey;

   asn1Copy_CRMF_POPOSigningKey (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CRMF_POPOPrivKey (OSCTXT* pctxt, 
   ASN1T_CRMF_POPOPrivKey* pSrcValue, ASN1T_CRMF_POPOPrivKey* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   pDstValue->t = pSrcValue->t;
   switch (pSrcValue->t)
   {
      /* thisMessage */
      case 1:
         pDstValue->u.thisMessage = rtxMemAllocType (pctxt, ASN1TDynBitStr);
         new (pDstValue->u.thisMessage) ASN1TDynBitStr;
         rtCopyDynBitStr (pctxt, pSrcValue->u.thisMessage, pDstValue->
            u.thisMessage);
         break;

      /* subsequentMessage */
      case 2:
         pDstValue->u.subsequentMessage = pSrcValue->u.subsequentMessage;
         break;

      /* dhMAC */
      case 3:
         pDstValue->u.dhMAC = rtxMemAllocType (pctxt, ASN1TDynBitStr);
         new (pDstValue->u.dhMAC) ASN1TDynBitStr;
         rtCopyDynBitStr (pctxt, pSrcValue->u.dhMAC, pDstValue->u.dhMAC);
         break;

   }
}

ASN1C_CRMF_POPOPrivKey::ASN1C_CRMF_POPOPrivKey (ASN1C_CRMF_POPOPrivKey& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CRMF_POPOPrivKey::ASN1T_CRMF_POPOPrivKey (ASN1C_CRMF_POPOPrivKey& original)
{
   original.getCopy (this);
}

ASN1T_CRMF_POPOPrivKey& ASN1C_CRMF_POPOPrivKey::getCopy (ASN1T_CRMF_POPOPrivKey* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CRMF_POPOPrivKey);
      new (pDstData) ASN1T_CRMF_POPOPrivKey;
   }

   asn1Copy_CRMF_POPOPrivKey (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CRMF_POPOPrivKey* ASN1C_CRMF_POPOPrivKey::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CRMF_POPOPrivKey* pDstData = new ASN1T_CRMF_POPOPrivKey;

   asn1Copy_CRMF_POPOPrivKey (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CRMF_ProofOfPossession (OSCTXT* pctxt, 
   ASN1T_CRMF_ProofOfPossession* pSrcValue, ASN1T_CRMF_ProofOfPossession*
    pDstValue)
{
   if (pSrcValue == pDstValue) return;

   pDstValue->t = pSrcValue->t;
   switch (pSrcValue->t)
   {
      /* raVerified */
      case 1:
         break;

      /* signature */
      case 2:
         pDstValue->u.signature_ = rtxMemAllocType (pctxt, ASN1T_CRMF_POPOSigningKey);
         new (pDstValue->u.signature_) ASN1T_CRMF_POPOSigningKey;
         asn1Copy_CRMF_POPOSigningKey (pctxt, pSrcValue->u.signature_, pDstValue->u.signature_);
         break;

      /* keyEncipherment */
      case 3:
         pDstValue->u.keyEncipherment = rtxMemAllocType (pctxt, ASN1T_CRMF_POPOPrivKey);
         new (pDstValue->u.keyEncipherment) ASN1T_CRMF_POPOPrivKey;
         asn1Copy_CRMF_POPOPrivKey (pctxt, pSrcValue->u.keyEncipherment, pDstValue->u.keyEncipherment);
         break;

      /* keyAgreement */
      case 4:
         pDstValue->u.keyAgreement = rtxMemAllocType (pctxt, ASN1T_CRMF_POPOPrivKey);
         new (pDstValue->u.keyAgreement) ASN1T_CRMF_POPOPrivKey;
         asn1Copy_CRMF_POPOPrivKey (pctxt, pSrcValue->u.keyAgreement, pDstValue->u.keyAgreement);
         break;

   }
}

ASN1C_CRMF_ProofOfPossession::ASN1C_CRMF_ProofOfPossession (ASN1C_CRMF_ProofOfPossession& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CRMF_ProofOfPossession::ASN1T_CRMF_ProofOfPossession (ASN1C_CRMF_ProofOfPossession& original)
{
   original.getCopy (this);
}

ASN1T_CRMF_ProofOfPossession& ASN1C_CRMF_ProofOfPossession::getCopy (ASN1T_CRMF_ProofOfPossession* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CRMF_ProofOfPossession);
      new (pDstData) ASN1T_CRMF_ProofOfPossession;
   }

   asn1Copy_CRMF_ProofOfPossession (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CRMF_ProofOfPossession* ASN1C_CRMF_ProofOfPossession::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CRMF_ProofOfPossession* pDstData = new ASN1T_CRMF_ProofOfPossession;

   asn1Copy_CRMF_ProofOfPossession (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CRMF_CertReqMsg_regInfo (OSCTXT* pctxt, 
   ASN1T_CRMF_CertReqMsg_regInfo* pSrcValue, ASN1T_CRMF_CertReqMsg_regInfo*
    pDstValue)
{
   if (pSrcValue == pDstValue) return;

   {
      OSUINT32 xx1;
      ASN1T_EXP_AttributeTypeAndValue* pSrcData;
      OSRTDListNode* pnode;

      rtxDListInit (pDstValue);
      pnode = pSrcValue->head;
      for (xx1 = 0; xx1 < pSrcValue->count; xx1++) {
         ASN1T_EXP_AttributeTypeAndValue* pDstData = rtxMemAllocTypeZ (pctxt, ASN1T_EXP_AttributeTypeAndValue);
         pSrcData = (ASN1T_EXP_AttributeTypeAndValue*) pnode->data;

         asn1Copy_EXP_AttributeTypeAndValue (pctxt, pSrcData, pDstData);

         rtxDListAppend (pctxt, pDstValue, (void*)pDstData);
         pnode = pnode->next;
      }
   }
}

ASN1C_CRMF_CertReqMsg_regInfo::ASN1C_CRMF_CertReqMsg_regInfo (ASN1C_CRMF_CertReqMsg_regInfo& original) :
   ASN1CSeqOfList(*original.mpContext, original.getCopy()), msgData (*(ASN1T_CRMF_CertReqMsg_regInfo*)pList)
{
}

ASN1C_CRMF_CertReqMsg_regInfo& ASN1C_CRMF_CertReqMsg_regInfo::operator= (ASN1C_CRMF_CertReqMsg_regInfo& srcData)
{
   clear ();
   asn1Copy_CRMF_CertReqMsg_regInfo (getCtxtPtr(), &srcData.msgData, &msgData);
   return *this;
}

ASN1T_CRMF_CertReqMsg_regInfo& ASN1C_CRMF_CertReqMsg_regInfo::getCopy (ASN1T_CRMF_CertReqMsg_regInfo* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CRMF_CertReqMsg_regInfo);
      new (pDstData) ASN1T_CRMF_CertReqMsg_regInfo;
   }

   asn1Copy_CRMF_CertReqMsg_regInfo (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CRMF_CertReqMsg_regInfo* ASN1C_CRMF_CertReqMsg_regInfo::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CRMF_CertReqMsg_regInfo* pDstData = new ASN1T_CRMF_CertReqMsg_regInfo;

   asn1Copy_CRMF_CertReqMsg_regInfo (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CRMF_CertReqMsg (OSCTXT* pctxt, 
   ASN1T_CRMF_CertReqMsg* pSrcValue, ASN1T_CRMF_CertReqMsg* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   OSCRTLMEMCPY (&pDstValue->m, &pSrcValue->m, sizeof (pDstValue->m));
   asn1Copy_CRMF_CertRequest (pctxt, &pSrcValue->certReq, &pDstValue->certReq);

   if (pSrcValue->m.popPresent) {
      asn1Copy_CRMF_ProofOfPossession (pctxt, &pSrcValue->pop, &pDstValue->pop);
   }

   if (pSrcValue->m.regInfoPresent) {
      asn1Copy_CRMF_CertReqMsg_regInfo (pctxt, &pSrcValue->regInfo, &pDstValue->regInfo);
   }

}

ASN1C_CRMF_CertReqMsg::ASN1C_CRMF_CertReqMsg (ASN1C_CRMF_CertReqMsg& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CRMF_CertReqMsg::ASN1T_CRMF_CertReqMsg (ASN1C_CRMF_CertReqMsg& original)
{
   original.getCopy (this);
}

ASN1T_CRMF_CertReqMsg& ASN1C_CRMF_CertReqMsg::getCopy (ASN1T_CRMF_CertReqMsg* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CRMF_CertReqMsg);
      new (pDstData) ASN1T_CRMF_CertReqMsg;
   }

   asn1Copy_CRMF_CertReqMsg (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CRMF_CertReqMsg* ASN1C_CRMF_CertReqMsg::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CRMF_CertReqMsg* pDstData = new ASN1T_CRMF_CertReqMsg;

   asn1Copy_CRMF_CertReqMsg (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CRMF_CertReqMessages (OSCTXT* pctxt, 
   ASN1T_CRMF_CertReqMessages* pSrcValue, ASN1T_CRMF_CertReqMessages*
    pDstValue)
{
   if (pSrcValue == pDstValue) return;

   {
      OSUINT32 xx1;
      ASN1T_CRMF_CertReqMsg* pSrcData;
      OSRTDListNode* pnode;

      rtxDListInit (pDstValue);
      pnode = pSrcValue->head;
      for (xx1 = 0; xx1 < pSrcValue->count; xx1++) {
         ASN1T_CRMF_CertReqMsg* pDstData = rtxMemAllocTypeZ (pctxt, ASN1T_CRMF_CertReqMsg);
         pSrcData = (ASN1T_CRMF_CertReqMsg*) pnode->data;

         asn1Copy_CRMF_CertReqMsg (pctxt, pSrcData, pDstData);

         rtxDListAppend (pctxt, pDstValue, (void*)pDstData);
         pnode = pnode->next;
      }
   }
}

ASN1C_CRMF_CertReqMessages::ASN1C_CRMF_CertReqMessages (ASN1C_CRMF_CertReqMessages& original) :
   ASN1CSeqOfList(*original.mpContext, original.getCopy()), msgData (*(ASN1T_CRMF_CertReqMessages*)pList)
{
}

ASN1C_CRMF_CertReqMessages& ASN1C_CRMF_CertReqMessages::operator= (ASN1C_CRMF_CertReqMessages& srcData)
{
   clear ();
   asn1Copy_CRMF_CertReqMessages (getCtxtPtr(), &srcData.msgData, &msgData);
   return *this;
}

ASN1T_CRMF_CertReqMessages& ASN1C_CRMF_CertReqMessages::getCopy (ASN1T_CRMF_CertReqMessages* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CRMF_CertReqMessages);
      new (pDstData) ASN1T_CRMF_CertReqMessages;
   }

   asn1Copy_CRMF_CertReqMessages (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CRMF_CertReqMessages* ASN1C_CRMF_CertReqMessages::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CRMF_CertReqMessages* pDstData = new ASN1T_CRMF_CertReqMessages;

   asn1Copy_CRMF_CertReqMessages (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

