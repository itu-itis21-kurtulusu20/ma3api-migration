/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.6, Date: 20-Feb-2014.
 */
#include <new>
#include "cmp.h"
#include "rtsrc/rtCopy.h"
#include "rtxsrc/rtxCommon.h"

void asn1Copy_CMP_PKIProtection (OSCTXT* pctxt, 
   ASN1T_CMP_PKIProtection* pSrcValue, ASN1T_CMP_PKIProtection* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   rtCopyDynBitStr (pctxt, pSrcValue, pDstValue);
}

ASN1C_CMP_PKIProtection::ASN1C_CMP_PKIProtection (ASN1C_CMP_PKIProtection& original) :
   ASN1CBitStr (original), msgData (original.getCopy ())
{
   ASN1CBitStr::init (msgData);
}

ASN1C_CMP_PKIProtection& ASN1C_CMP_PKIProtection::operator= (ASN1C_CMP_PKIProtection& srcData)
{
   srcData.getCopy (&msgData);
   return *this;
}

ASN1T_CMP_PKIProtection& ASN1C_CMP_PKIProtection::getCopy (ASN1T_CMP_PKIProtection* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_PKIProtection);
      new (pDstData) ASN1T_CMP_PKIProtection;
   }

   asn1Copy_CMP_PKIProtection (pctxt, &msgData, pDstData);

   return *pDstData;
}

ASN1T_CMP_PKIProtection* ASN1C_CMP_PKIProtection::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_PKIProtection* pDstData = new ASN1T_CMP_PKIProtection;

   asn1Copy_CMP_PKIProtection (pctxt, &msgData, pDstData);

   return pDstData;
}

void asn1Copy_CMP_PKIFreeText (OSCTXT* pctxt, 
   ASN1T_CMP_PKIFreeText* pSrcValue, ASN1T_CMP_PKIFreeText* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   {
      OSUINT32 xx1;
      const OSUTF8CHAR* pSrcData;
      OSRTDListNode* pnode;

      rtxDListInit (pDstValue);
      pnode = pSrcValue->head;
      for (xx1 = 0; xx1 < pSrcValue->count; xx1++) {
         const OSUTF8CHAR* pCharPtr = 0;
         const OSUTF8CHAR** pDstData = &pCharPtr;
         pSrcData = (const OSUTF8CHAR*) pnode->data;

         *pDstData = (const unsigned char *)rtxUTF8Strdup (pctxt, pSrcData);

         rtxDListAppend (pctxt, pDstValue, (void*)pCharPtr);
         pnode = pnode->next;
      }
   }
}

ASN1C_CMP_PKIFreeText::ASN1C_CMP_PKIFreeText (ASN1C_CMP_PKIFreeText& original) :
   ASN1CSeqOfList(*original.mpContext, original.getCopy()), msgData (*(ASN1T_CMP_PKIFreeText*)pList)
{
}

ASN1C_CMP_PKIFreeText& ASN1C_CMP_PKIFreeText::operator= (ASN1C_CMP_PKIFreeText& srcData)
{
   clear ();
   asn1Copy_CMP_PKIFreeText (getCtxtPtr(), &srcData.msgData, &msgData);
   return *this;
}

ASN1T_CMP_PKIFreeText& ASN1C_CMP_PKIFreeText::getCopy (ASN1T_CMP_PKIFreeText* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_PKIFreeText);
      new (pDstData) ASN1T_CMP_PKIFreeText;
   }

   asn1Copy_CMP_PKIFreeText (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_PKIFreeText* ASN1C_CMP_PKIFreeText::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_PKIFreeText* pDstData = new ASN1T_CMP_PKIFreeText;

   asn1Copy_CMP_PKIFreeText (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_InfoTypeAndValue (OSCTXT* pctxt, 
   ASN1T_CMP_InfoTypeAndValue* pSrcValue, ASN1T_CMP_InfoTypeAndValue*
    pDstValue)
{
   if (pSrcValue == pDstValue) return;

   OSCRTLMEMCPY (&pDstValue->m, &pSrcValue->m, sizeof (pDstValue->m));
   rtCopyOID ((ASN1OBJID*)&pSrcValue->infoType, (ASN1OBJID*)&pDstValue->infoType);

   if (pSrcValue->m.infoValuePresent) {
      rtCopyOpenType (pctxt, &pSrcValue->infoValue, &pDstValue->infoValue);
   }

}

ASN1C_CMP_InfoTypeAndValue::ASN1C_CMP_InfoTypeAndValue (ASN1C_CMP_InfoTypeAndValue& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CMP_InfoTypeAndValue::ASN1T_CMP_InfoTypeAndValue (ASN1C_CMP_InfoTypeAndValue& original)
{
   original.getCopy (this);
}

ASN1T_CMP_InfoTypeAndValue& ASN1C_CMP_InfoTypeAndValue::getCopy (ASN1T_CMP_InfoTypeAndValue* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_InfoTypeAndValue);
      new (pDstData) ASN1T_CMP_InfoTypeAndValue;
   }

   asn1Copy_CMP_InfoTypeAndValue (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_InfoTypeAndValue* ASN1C_CMP_InfoTypeAndValue::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_InfoTypeAndValue* pDstData = new ASN1T_CMP_InfoTypeAndValue;

   asn1Copy_CMP_InfoTypeAndValue (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_PKIHeader_generalInfo (OSCTXT* pctxt, 
   ASN1T_CMP_PKIHeader_generalInfo* pSrcValue, ASN1T_CMP_PKIHeader_generalInfo*
    pDstValue)
{
   if (pSrcValue == pDstValue) return;

   {
      OSUINT32 xx1;
      ASN1T_CMP_InfoTypeAndValue* pSrcData;
      OSRTDListNode* pnode;

      rtxDListInit (pDstValue);
      pnode = pSrcValue->head;
      for (xx1 = 0; xx1 < pSrcValue->count; xx1++) {
         ASN1T_CMP_InfoTypeAndValue* pDstData = rtxMemAllocTypeZ (pctxt, ASN1T_CMP_InfoTypeAndValue);
         pSrcData = (ASN1T_CMP_InfoTypeAndValue*) pnode->data;

         asn1Copy_CMP_InfoTypeAndValue (pctxt, pSrcData, pDstData);

         rtxDListAppend (pctxt, pDstValue, (void*)pDstData);
         pnode = pnode->next;
      }
   }
}

ASN1C_CMP_PKIHeader_generalInfo::ASN1C_CMP_PKIHeader_generalInfo (ASN1C_CMP_PKIHeader_generalInfo& original) :
   ASN1CSeqOfList(*original.mpContext, original.getCopy()), msgData (*(ASN1T_CMP_PKIHeader_generalInfo*)pList)
{
}

ASN1C_CMP_PKIHeader_generalInfo& ASN1C_CMP_PKIHeader_generalInfo::operator= (ASN1C_CMP_PKIHeader_generalInfo& srcData)
{
   clear ();
   asn1Copy_CMP_PKIHeader_generalInfo (getCtxtPtr(), &srcData.msgData, &msgData);
   return *this;
}

ASN1T_CMP_PKIHeader_generalInfo& ASN1C_CMP_PKIHeader_generalInfo::getCopy (ASN1T_CMP_PKIHeader_generalInfo* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_PKIHeader_generalInfo);
      new (pDstData) ASN1T_CMP_PKIHeader_generalInfo;
   }

   asn1Copy_CMP_PKIHeader_generalInfo (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_PKIHeader_generalInfo* ASN1C_CMP_PKIHeader_generalInfo::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_PKIHeader_generalInfo* pDstData = new ASN1T_CMP_PKIHeader_generalInfo;

   asn1Copy_CMP_PKIHeader_generalInfo (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_PKIHeader (OSCTXT* pctxt, ASN1T_CMP_PKIHeader* pSrcValue, 
   ASN1T_CMP_PKIHeader* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   OSCRTLMEMCPY (&pDstValue->m, &pSrcValue->m, sizeof (pDstValue->m));
   pDstValue->pvno = pSrcValue->pvno;

   asn1Copy_IMP_GeneralName (pctxt, &pSrcValue->sender, &pDstValue->sender);

   asn1Copy_IMP_GeneralName (pctxt, &pSrcValue->recipient, &pDstValue->recipient);

   if (pSrcValue->m.messageTimePresent) {
      RTCOPYCHARSTR (pctxt, (char *)pSrcValue->messageTime, (char **)&pDstValue->messageTime);
   }

   if (pSrcValue->m.protectionAlgPresent) {
      asn1Copy_EXP_AlgorithmIdentifier (pctxt, &pSrcValue->protectionAlg, &pDstValue->protectionAlg);
   }

   if (pSrcValue->m.senderKIDPresent) {
      asn1Copy_IMP_KeyIdentifier (pctxt, &pSrcValue->senderKID, &pDstValue->senderKID);
   }

   if (pSrcValue->m.recipKIDPresent) {
      asn1Copy_IMP_KeyIdentifier (pctxt, &pSrcValue->recipKID, &pDstValue->recipKID);
   }

   if (pSrcValue->m.transactionIDPresent) {
      rtCopyDynOctStr (pctxt, &pSrcValue->transactionID, &pDstValue->
         transactionID);
   }

   if (pSrcValue->m.senderNoncePresent) {
      rtCopyDynOctStr (pctxt, &pSrcValue->senderNonce, &pDstValue->senderNonce
         );
   }

   if (pSrcValue->m.recipNoncePresent) {
      rtCopyDynOctStr (pctxt, &pSrcValue->recipNonce, &pDstValue->recipNonce);
   }

   if (pSrcValue->m.freeTextPresent) {
      asn1Copy_CMP_PKIFreeText (pctxt, &pSrcValue->freeText, &pDstValue->freeText);
   }

   if (pSrcValue->m.generalInfoPresent) {
      asn1Copy_CMP_PKIHeader_generalInfo (pctxt, &pSrcValue->generalInfo, &pDstValue->generalInfo);
   }

}

ASN1C_CMP_PKIHeader::ASN1C_CMP_PKIHeader (ASN1C_CMP_PKIHeader& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CMP_PKIHeader::ASN1T_CMP_PKIHeader (ASN1C_CMP_PKIHeader& original)
{
   original.getCopy (this);
}

ASN1T_CMP_PKIHeader& ASN1C_CMP_PKIHeader::getCopy (ASN1T_CMP_PKIHeader* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_PKIHeader);
      new (pDstData) ASN1T_CMP_PKIHeader;
   }

   asn1Copy_CMP_PKIHeader (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_PKIHeader* ASN1C_CMP_PKIHeader::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_PKIHeader* pDstData = new ASN1T_CMP_PKIHeader;

   asn1Copy_CMP_PKIHeader (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_CMPCertificate (OSCTXT* pctxt, 
   ASN1T_CMP_CMPCertificate* pSrcValue, ASN1T_CMP_CMPCertificate* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   pDstValue->t = pSrcValue->t;
   switch (pSrcValue->t)
   {
      /* x509v3PKCert */
      case 1:
         pDstValue->u.x509v3PKCert = rtxMemAllocType (pctxt, ASN1T_EXP_Certificate);
         new (pDstValue->u.x509v3PKCert) ASN1T_EXP_Certificate;
         asn1Copy_EXP_Certificate (pctxt, pSrcValue->u.x509v3PKCert, pDstValue->u.x509v3PKCert);
         break;

   }
}

ASN1C_CMP_CMPCertificate::ASN1C_CMP_CMPCertificate (ASN1C_CMP_CMPCertificate& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CMP_CMPCertificate::ASN1T_CMP_CMPCertificate (ASN1C_CMP_CMPCertificate& original)
{
   original.getCopy (this);
}

ASN1T_CMP_CMPCertificate& ASN1C_CMP_CMPCertificate::getCopy (ASN1T_CMP_CMPCertificate* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_CMPCertificate);
      new (pDstData) ASN1T_CMP_CMPCertificate;
   }

   asn1Copy_CMP_CMPCertificate (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_CMPCertificate* ASN1C_CMP_CMPCertificate::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_CMPCertificate* pDstData = new ASN1T_CMP_CMPCertificate;

   asn1Copy_CMP_CMPCertificate (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_CertRepMessage_caPubs (OSCTXT* pctxt, 
   ASN1T_CMP_CertRepMessage_caPubs* pSrcValue, ASN1T_CMP_CertRepMessage_caPubs*
    pDstValue)
{
   if (pSrcValue == pDstValue) return;

   {
      OSUINT32 xx1;
      ASN1T_CMP_CMPCertificate* pSrcData;
      OSRTDListNode* pnode;

      rtxDListInit (pDstValue);
      pnode = pSrcValue->head;
      for (xx1 = 0; xx1 < pSrcValue->count; xx1++) {
         ASN1T_CMP_CMPCertificate* pDstData = rtxMemAllocTypeZ (pctxt, ASN1T_CMP_CMPCertificate);
         pSrcData = (ASN1T_CMP_CMPCertificate*) pnode->data;

         asn1Copy_CMP_CMPCertificate (pctxt, pSrcData, pDstData);

         rtxDListAppend (pctxt, pDstValue, (void*)pDstData);
         pnode = pnode->next;
      }
   }
}

ASN1C_CMP_CertRepMessage_caPubs::ASN1C_CMP_CertRepMessage_caPubs (ASN1C_CMP_CertRepMessage_caPubs& original) :
   ASN1CSeqOfList(*original.mpContext, original.getCopy()), msgData (*(ASN1T_CMP_CertRepMessage_caPubs*)pList)
{
}

ASN1C_CMP_CertRepMessage_caPubs& ASN1C_CMP_CertRepMessage_caPubs::operator= (ASN1C_CMP_CertRepMessage_caPubs& srcData)
{
   clear ();
   asn1Copy_CMP_CertRepMessage_caPubs (getCtxtPtr(), &srcData.msgData, &msgData);
   return *this;
}

ASN1T_CMP_CertRepMessage_caPubs& ASN1C_CMP_CertRepMessage_caPubs::getCopy (ASN1T_CMP_CertRepMessage_caPubs* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_CertRepMessage_caPubs);
      new (pDstData) ASN1T_CMP_CertRepMessage_caPubs;
   }

   asn1Copy_CMP_CertRepMessage_caPubs (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_CertRepMessage_caPubs* ASN1C_CMP_CertRepMessage_caPubs::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_CertRepMessage_caPubs* pDstData = new ASN1T_CMP_CertRepMessage_caPubs;

   asn1Copy_CMP_CertRepMessage_caPubs (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_PKIFailureInfo (OSCTXT* pctxt, 
   ASN1T_CMP_PKIFailureInfo* pSrcValue, ASN1T_CMP_PKIFailureInfo* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   pDstValue->numbits = pSrcValue->numbits;
   if (pSrcValue->numbits > 0) {
      OSCRTLMEMCPY (pDstValue->data, pSrcValue->data, (pSrcValue->
         numbits+7)/8);
   }
}

ASN1C_CMP_PKIFailureInfo::ASN1C_CMP_PKIFailureInfo (ASN1C_CMP_PKIFailureInfo& original) :
   ASN1CBitStr (original), msgData (original.getCopy ())
{
   ASN1CBitStr::init (msgData.data, msgData.numbits, 32);
}

ASN1T_CMP_PKIFailureInfo::ASN1T_CMP_PKIFailureInfo (ASN1C_CMP_PKIFailureInfo& original)
{
   original.getCopy (this);
}

ASN1C_CMP_PKIFailureInfo& ASN1C_CMP_PKIFailureInfo::operator= (ASN1C_CMP_PKIFailureInfo& srcData)
{
   srcData.getCopy (&msgData);
   return *this;
}

ASN1T_CMP_PKIFailureInfo& ASN1C_CMP_PKIFailureInfo::getCopy (ASN1T_CMP_PKIFailureInfo* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_PKIFailureInfo);
      new (pDstData) ASN1T_CMP_PKIFailureInfo;
   }

   asn1Copy_CMP_PKIFailureInfo (pctxt, &msgData, pDstData);

   return *pDstData;
}

ASN1T_CMP_PKIFailureInfo* ASN1C_CMP_PKIFailureInfo::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_PKIFailureInfo* pDstData = new ASN1T_CMP_PKIFailureInfo;

   asn1Copy_CMP_PKIFailureInfo (pctxt, &msgData, pDstData);

   return pDstData;
}

void asn1Copy_CMP_PKIStatusInfo (OSCTXT* pctxt, 
   ASN1T_CMP_PKIStatusInfo* pSrcValue, ASN1T_CMP_PKIStatusInfo* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   OSCRTLMEMCPY (&pDstValue->m, &pSrcValue->m, sizeof (pDstValue->m));
   pDstValue->status = pSrcValue->status;

   if (pSrcValue->m.statusStringPresent) {
      asn1Copy_CMP_PKIFreeText (pctxt, &pSrcValue->statusString, &pDstValue->statusString);
   }

   if (pSrcValue->m.failInfoPresent) {
      asn1Copy_CMP_PKIFailureInfo (pctxt, &pSrcValue->failInfo, &pDstValue->failInfo);
   }

}

ASN1C_CMP_PKIStatusInfo::ASN1C_CMP_PKIStatusInfo (ASN1C_CMP_PKIStatusInfo& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CMP_PKIStatusInfo::ASN1T_CMP_PKIStatusInfo (ASN1C_CMP_PKIStatusInfo& original)
{
   original.getCopy (this);
}

ASN1T_CMP_PKIStatusInfo& ASN1C_CMP_PKIStatusInfo::getCopy (ASN1T_CMP_PKIStatusInfo* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_PKIStatusInfo);
      new (pDstData) ASN1T_CMP_PKIStatusInfo;
   }

   asn1Copy_CMP_PKIStatusInfo (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_PKIStatusInfo* ASN1C_CMP_PKIStatusInfo::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_PKIStatusInfo* pDstData = new ASN1T_CMP_PKIStatusInfo;

   asn1Copy_CMP_PKIStatusInfo (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_CertOrEncCert (OSCTXT* pctxt, 
   ASN1T_CMP_CertOrEncCert* pSrcValue, ASN1T_CMP_CertOrEncCert* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   pDstValue->t = pSrcValue->t;
   switch (pSrcValue->t)
   {
      /* certificate */
      case 1:
         pDstValue->u.certificate = rtxMemAllocType (pctxt, ASN1T_CMP_CMPCertificate);
         new (pDstValue->u.certificate) ASN1T_CMP_CMPCertificate;
         asn1Copy_CMP_CMPCertificate (pctxt, pSrcValue->u.certificate, pDstValue->u.certificate);
         break;

      /* encryptedCert */
      case 2:
         pDstValue->u.encryptedCert = rtxMemAllocType (pctxt, ASN1T_CRMF_EncryptedValue);
         new (pDstValue->u.encryptedCert) ASN1T_CRMF_EncryptedValue;
         asn1Copy_CRMF_EncryptedValue (pctxt, pSrcValue->u.encryptedCert, pDstValue->u.encryptedCert);
         break;

   }
}

ASN1C_CMP_CertOrEncCert::ASN1C_CMP_CertOrEncCert (ASN1C_CMP_CertOrEncCert& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CMP_CertOrEncCert::ASN1T_CMP_CertOrEncCert (ASN1C_CMP_CertOrEncCert& original)
{
   original.getCopy (this);
}

ASN1T_CMP_CertOrEncCert& ASN1C_CMP_CertOrEncCert::getCopy (ASN1T_CMP_CertOrEncCert* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_CertOrEncCert);
      new (pDstData) ASN1T_CMP_CertOrEncCert;
   }

   asn1Copy_CMP_CertOrEncCert (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_CertOrEncCert* ASN1C_CMP_CertOrEncCert::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_CertOrEncCert* pDstData = new ASN1T_CMP_CertOrEncCert;

   asn1Copy_CMP_CertOrEncCert (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_CertifiedKeyPair (OSCTXT* pctxt, 
   ASN1T_CMP_CertifiedKeyPair* pSrcValue, ASN1T_CMP_CertifiedKeyPair*
    pDstValue)
{
   if (pSrcValue == pDstValue) return;

   OSCRTLMEMCPY (&pDstValue->m, &pSrcValue->m, sizeof (pDstValue->m));
   asn1Copy_CMP_CertOrEncCert (pctxt, &pSrcValue->certOrEncCert, &pDstValue->certOrEncCert);

   if (pSrcValue->m.privateKeyPresent) {
      asn1Copy_CRMF_EncryptedValue (pctxt, &pSrcValue->privateKey, &pDstValue->privateKey);
   }

   if (pSrcValue->m.publicationInfoPresent) {
      asn1Copy_CRMF_PKIPublicationInfo (pctxt, &pSrcValue->publicationInfo, &pDstValue->publicationInfo);
   }

}

ASN1C_CMP_CertifiedKeyPair::ASN1C_CMP_CertifiedKeyPair (ASN1C_CMP_CertifiedKeyPair& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CMP_CertifiedKeyPair::ASN1T_CMP_CertifiedKeyPair (ASN1C_CMP_CertifiedKeyPair& original)
{
   original.getCopy (this);
}

ASN1T_CMP_CertifiedKeyPair& ASN1C_CMP_CertifiedKeyPair::getCopy (ASN1T_CMP_CertifiedKeyPair* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_CertifiedKeyPair);
      new (pDstData) ASN1T_CMP_CertifiedKeyPair;
   }

   asn1Copy_CMP_CertifiedKeyPair (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_CertifiedKeyPair* ASN1C_CMP_CertifiedKeyPair::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_CertifiedKeyPair* pDstData = new ASN1T_CMP_CertifiedKeyPair;

   asn1Copy_CMP_CertifiedKeyPair (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_CertResponse (OSCTXT* pctxt, 
   ASN1T_CMP_CertResponse* pSrcValue, ASN1T_CMP_CertResponse* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   OSCRTLMEMCPY (&pDstValue->m, &pSrcValue->m, sizeof (pDstValue->m));
   pDstValue->certReqId = pSrcValue->certReqId;

   asn1Copy_CMP_PKIStatusInfo (pctxt, &pSrcValue->status, &pDstValue->status);

   if (pSrcValue->m.certifiedKeyPairPresent) {
      asn1Copy_CMP_CertifiedKeyPair (pctxt, &pSrcValue->certifiedKeyPair, &pDstValue->certifiedKeyPair);
   }

   if (pSrcValue->m.rspInfoPresent) {
      rtCopyDynOctStr (pctxt, &pSrcValue->rspInfo, &pDstValue->rspInfo);
   }

}

ASN1C_CMP_CertResponse::ASN1C_CMP_CertResponse (ASN1C_CMP_CertResponse& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CMP_CertResponse::ASN1T_CMP_CertResponse (ASN1C_CMP_CertResponse& original)
{
   original.getCopy (this);
}

ASN1T_CMP_CertResponse& ASN1C_CMP_CertResponse::getCopy (ASN1T_CMP_CertResponse* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_CertResponse);
      new (pDstData) ASN1T_CMP_CertResponse;
   }

   asn1Copy_CMP_CertResponse (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_CertResponse* ASN1C_CMP_CertResponse::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_CertResponse* pDstData = new ASN1T_CMP_CertResponse;

   asn1Copy_CMP_CertResponse (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP__SeqOfCMP_CertResponse (OSCTXT* pctxt, 
   ASN1T_CMP__SeqOfCMP_CertResponse* pSrcValue, 
   ASN1T_CMP__SeqOfCMP_CertResponse* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   {
      OSUINT32 xx1;
      ASN1T_CMP_CertResponse* pSrcData;
      OSRTDListNode* pnode;

      rtxDListInit (pDstValue);
      pnode = pSrcValue->head;
      for (xx1 = 0; xx1 < pSrcValue->count; xx1++) {
         ASN1T_CMP_CertResponse* pDstData = rtxMemAllocTypeZ (pctxt, ASN1T_CMP_CertResponse);
         pSrcData = (ASN1T_CMP_CertResponse*) pnode->data;

         asn1Copy_CMP_CertResponse (pctxt, pSrcData, pDstData);

         rtxDListAppend (pctxt, pDstValue, (void*)pDstData);
         pnode = pnode->next;
      }
   }
}

ASN1C_CMP__SeqOfCMP_CertResponse::ASN1C_CMP__SeqOfCMP_CertResponse (ASN1C_CMP__SeqOfCMP_CertResponse& original) :
   ASN1CSeqOfList(*original.mpContext, original.getCopy()), msgData (*(ASN1T_CMP__SeqOfCMP_CertResponse*)pList)
{
}

ASN1C_CMP__SeqOfCMP_CertResponse& ASN1C_CMP__SeqOfCMP_CertResponse::operator= (ASN1C_CMP__SeqOfCMP_CertResponse& srcData)
{
   clear ();
   asn1Copy_CMP__SeqOfCMP_CertResponse (getCtxtPtr(), &srcData.msgData, &msgData);
   return *this;
}

ASN1T_CMP__SeqOfCMP_CertResponse& ASN1C_CMP__SeqOfCMP_CertResponse::getCopy (ASN1T_CMP__SeqOfCMP_CertResponse* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP__SeqOfCMP_CertResponse);
      new (pDstData) ASN1T_CMP__SeqOfCMP_CertResponse;
   }

   asn1Copy_CMP__SeqOfCMP_CertResponse (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP__SeqOfCMP_CertResponse* ASN1C_CMP__SeqOfCMP_CertResponse::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP__SeqOfCMP_CertResponse* pDstData = new ASN1T_CMP__SeqOfCMP_CertResponse;

   asn1Copy_CMP__SeqOfCMP_CertResponse (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_CertRepMessage (OSCTXT* pctxt, 
   ASN1T_CMP_CertRepMessage* pSrcValue, ASN1T_CMP_CertRepMessage* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   OSCRTLMEMCPY (&pDstValue->m, &pSrcValue->m, sizeof (pDstValue->m));
   if (pSrcValue->m.caPubsPresent) {
      asn1Copy_CMP_CertRepMessage_caPubs (pctxt, &pSrcValue->caPubs, &pDstValue->caPubs);
   }

   asn1Copy_CMP__SeqOfCMP_CertResponse (pctxt, &pSrcValue->response, &pDstValue->response);

}

ASN1C_CMP_CertRepMessage::ASN1C_CMP_CertRepMessage (ASN1C_CMP_CertRepMessage& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CMP_CertRepMessage::ASN1T_CMP_CertRepMessage (ASN1C_CMP_CertRepMessage& original)
{
   original.getCopy (this);
}

ASN1T_CMP_CertRepMessage& ASN1C_CMP_CertRepMessage::getCopy (ASN1T_CMP_CertRepMessage* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_CertRepMessage);
      new (pDstData) ASN1T_CMP_CertRepMessage;
   }

   asn1Copy_CMP_CertRepMessage (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_CertRepMessage* ASN1C_CMP_CertRepMessage::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_CertRepMessage* pDstData = new ASN1T_CMP_CertRepMessage;

   asn1Copy_CMP_CertRepMessage (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_Challenge (OSCTXT* pctxt, ASN1T_CMP_Challenge* pSrcValue, 
   ASN1T_CMP_Challenge* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   OSCRTLMEMCPY (&pDstValue->m, &pSrcValue->m, sizeof (pDstValue->m));
   if (pSrcValue->m.owfPresent) {
      asn1Copy_EXP_AlgorithmIdentifier (pctxt, &pSrcValue->owf, &pDstValue->owf);
   }

   rtCopyDynOctStr (pctxt, &pSrcValue->witness, &pDstValue->witness);

   rtCopyDynOctStr (pctxt, &pSrcValue->challenge, &pDstValue->challenge);

}

ASN1C_CMP_Challenge::ASN1C_CMP_Challenge (ASN1C_CMP_Challenge& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CMP_Challenge::ASN1T_CMP_Challenge (ASN1C_CMP_Challenge& original)
{
   original.getCopy (this);
}

ASN1T_CMP_Challenge& ASN1C_CMP_Challenge::getCopy (ASN1T_CMP_Challenge* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_Challenge);
      new (pDstData) ASN1T_CMP_Challenge;
   }

   asn1Copy_CMP_Challenge (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_Challenge* ASN1C_CMP_Challenge::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_Challenge* pDstData = new ASN1T_CMP_Challenge;

   asn1Copy_CMP_Challenge (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_POPODecKeyChallContent (OSCTXT* pctxt, 
   ASN1T_CMP_POPODecKeyChallContent* pSrcValue, 
   ASN1T_CMP_POPODecKeyChallContent* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   {
      OSUINT32 xx1;
      ASN1T_CMP_Challenge* pSrcData;
      OSRTDListNode* pnode;

      rtxDListInit (pDstValue);
      pnode = pSrcValue->head;
      for (xx1 = 0; xx1 < pSrcValue->count; xx1++) {
         ASN1T_CMP_Challenge* pDstData = rtxMemAllocTypeZ (pctxt, ASN1T_CMP_Challenge);
         pSrcData = (ASN1T_CMP_Challenge*) pnode->data;

         asn1Copy_CMP_Challenge (pctxt, pSrcData, pDstData);

         rtxDListAppend (pctxt, pDstValue, (void*)pDstData);
         pnode = pnode->next;
      }
   }
}

ASN1C_CMP_POPODecKeyChallContent::ASN1C_CMP_POPODecKeyChallContent (ASN1C_CMP_POPODecKeyChallContent& original) :
   ASN1CSeqOfList(*original.mpContext, original.getCopy()), msgData (*(ASN1T_CMP_POPODecKeyChallContent*)pList)
{
}

ASN1C_CMP_POPODecKeyChallContent& ASN1C_CMP_POPODecKeyChallContent::operator= (ASN1C_CMP_POPODecKeyChallContent& srcData)
{
   clear ();
   asn1Copy_CMP_POPODecKeyChallContent (getCtxtPtr(), &srcData.msgData, &msgData);
   return *this;
}

ASN1T_CMP_POPODecKeyChallContent& ASN1C_CMP_POPODecKeyChallContent::getCopy (ASN1T_CMP_POPODecKeyChallContent* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_POPODecKeyChallContent);
      new (pDstData) ASN1T_CMP_POPODecKeyChallContent;
   }

   asn1Copy_CMP_POPODecKeyChallContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_POPODecKeyChallContent* ASN1C_CMP_POPODecKeyChallContent::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_POPODecKeyChallContent* pDstData = new ASN1T_CMP_POPODecKeyChallContent;

   asn1Copy_CMP_POPODecKeyChallContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_POPODecKeyRespContent (OSCTXT* pctxt, 
   ASN1T_CMP_POPODecKeyRespContent* pSrcValue, ASN1T_CMP_POPODecKeyRespContent*
    pDstValue)
{
   if (pSrcValue == pDstValue) return;

   {
      OSUINT32 xx1;
      OSINT32* pSrcData;
      OSRTDListNode* pnode;

      rtxDListInit (pDstValue);
      pnode = pSrcValue->head;
      for (xx1 = 0; xx1 < pSrcValue->count; xx1++) {
         OSINT32* pDstData = rtxMemAllocTypeZ (pctxt, OSINT32);
         pSrcData = (OSINT32*) pnode->data;

         *pDstData = *pSrcData;

         rtxDListAppend (pctxt, pDstValue, (void*)pDstData);
         pnode = pnode->next;
      }
   }
}

ASN1C_CMP_POPODecKeyRespContent::ASN1C_CMP_POPODecKeyRespContent (ASN1C_CMP_POPODecKeyRespContent& original) :
   ASN1CSeqOfList(*original.mpContext, original.getCopy()), msgData (*(ASN1T_CMP_POPODecKeyRespContent*)pList)
{
}

ASN1C_CMP_POPODecKeyRespContent& ASN1C_CMP_POPODecKeyRespContent::operator= (ASN1C_CMP_POPODecKeyRespContent& srcData)
{
   clear ();
   asn1Copy_CMP_POPODecKeyRespContent (getCtxtPtr(), &srcData.msgData, &msgData);
   return *this;
}

ASN1T_CMP_POPODecKeyRespContent& ASN1C_CMP_POPODecKeyRespContent::getCopy (ASN1T_CMP_POPODecKeyRespContent* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_POPODecKeyRespContent);
      new (pDstData) ASN1T_CMP_POPODecKeyRespContent;
   }

   asn1Copy_CMP_POPODecKeyRespContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_POPODecKeyRespContent* ASN1C_CMP_POPODecKeyRespContent::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_POPODecKeyRespContent* pDstData = new ASN1T_CMP_POPODecKeyRespContent;

   asn1Copy_CMP_POPODecKeyRespContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_KeyRecRepContent_caCerts (OSCTXT* pctxt, 
   ASN1T_CMP_KeyRecRepContent_caCerts* pSrcValue, 
   ASN1T_CMP_KeyRecRepContent_caCerts* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   {
      OSUINT32 xx1;
      ASN1T_CMP_CMPCertificate* pSrcData;
      OSRTDListNode* pnode;

      rtxDListInit (pDstValue);
      pnode = pSrcValue->head;
      for (xx1 = 0; xx1 < pSrcValue->count; xx1++) {
         ASN1T_CMP_CMPCertificate* pDstData = rtxMemAllocTypeZ (pctxt, ASN1T_CMP_CMPCertificate);
         pSrcData = (ASN1T_CMP_CMPCertificate*) pnode->data;

         asn1Copy_CMP_CMPCertificate (pctxt, pSrcData, pDstData);

         rtxDListAppend (pctxt, pDstValue, (void*)pDstData);
         pnode = pnode->next;
      }
   }
}

ASN1C_CMP_KeyRecRepContent_caCerts::ASN1C_CMP_KeyRecRepContent_caCerts (ASN1C_CMP_KeyRecRepContent_caCerts& original) :
   ASN1CSeqOfList(*original.mpContext, original.getCopy()), msgData (*(ASN1T_CMP_KeyRecRepContent_caCerts*)pList)
{
}

ASN1C_CMP_KeyRecRepContent_caCerts& ASN1C_CMP_KeyRecRepContent_caCerts::operator= (ASN1C_CMP_KeyRecRepContent_caCerts& srcData)
{
   clear ();
   asn1Copy_CMP_KeyRecRepContent_caCerts (getCtxtPtr(), &srcData.msgData, &msgData);
   return *this;
}

ASN1T_CMP_KeyRecRepContent_caCerts& ASN1C_CMP_KeyRecRepContent_caCerts::getCopy (ASN1T_CMP_KeyRecRepContent_caCerts* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_KeyRecRepContent_caCerts);
      new (pDstData) ASN1T_CMP_KeyRecRepContent_caCerts;
   }

   asn1Copy_CMP_KeyRecRepContent_caCerts (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_KeyRecRepContent_caCerts* ASN1C_CMP_KeyRecRepContent_caCerts::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_KeyRecRepContent_caCerts* pDstData = new ASN1T_CMP_KeyRecRepContent_caCerts;

   asn1Copy_CMP_KeyRecRepContent_caCerts (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_KeyRecRepContent_keyPairHist (OSCTXT* pctxt, 
   ASN1T_CMP_KeyRecRepContent_keyPairHist* pSrcValue, 
   ASN1T_CMP_KeyRecRepContent_keyPairHist* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   {
      OSUINT32 xx1;
      ASN1T_CMP_CertifiedKeyPair* pSrcData;
      OSRTDListNode* pnode;

      rtxDListInit (pDstValue);
      pnode = pSrcValue->head;
      for (xx1 = 0; xx1 < pSrcValue->count; xx1++) {
         ASN1T_CMP_CertifiedKeyPair* pDstData = rtxMemAllocTypeZ (pctxt, ASN1T_CMP_CertifiedKeyPair);
         pSrcData = (ASN1T_CMP_CertifiedKeyPair*) pnode->data;

         asn1Copy_CMP_CertifiedKeyPair (pctxt, pSrcData, pDstData);

         rtxDListAppend (pctxt, pDstValue, (void*)pDstData);
         pnode = pnode->next;
      }
   }
}

ASN1C_CMP_KeyRecRepContent_keyPairHist::ASN1C_CMP_KeyRecRepContent_keyPairHist (ASN1C_CMP_KeyRecRepContent_keyPairHist& original) :
   ASN1CSeqOfList(*original.mpContext, original.getCopy()), msgData (*(ASN1T_CMP_KeyRecRepContent_keyPairHist*)pList)
{
}

ASN1C_CMP_KeyRecRepContent_keyPairHist& ASN1C_CMP_KeyRecRepContent_keyPairHist::operator= (ASN1C_CMP_KeyRecRepContent_keyPairHist& srcData)
{
   clear ();
   asn1Copy_CMP_KeyRecRepContent_keyPairHist (getCtxtPtr(), &srcData.msgData, &msgData);
   return *this;
}

ASN1T_CMP_KeyRecRepContent_keyPairHist& ASN1C_CMP_KeyRecRepContent_keyPairHist::getCopy (ASN1T_CMP_KeyRecRepContent_keyPairHist* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_KeyRecRepContent_keyPairHist);
      new (pDstData) ASN1T_CMP_KeyRecRepContent_keyPairHist;
   }

   asn1Copy_CMP_KeyRecRepContent_keyPairHist (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_KeyRecRepContent_keyPairHist* ASN1C_CMP_KeyRecRepContent_keyPairHist::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_KeyRecRepContent_keyPairHist* pDstData = new ASN1T_CMP_KeyRecRepContent_keyPairHist;

   asn1Copy_CMP_KeyRecRepContent_keyPairHist (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_KeyRecRepContent (OSCTXT* pctxt, 
   ASN1T_CMP_KeyRecRepContent* pSrcValue, ASN1T_CMP_KeyRecRepContent*
    pDstValue)
{
   if (pSrcValue == pDstValue) return;

   OSCRTLMEMCPY (&pDstValue->m, &pSrcValue->m, sizeof (pDstValue->m));
   asn1Copy_CMP_PKIStatusInfo (pctxt, &pSrcValue->status, &pDstValue->status);

   if (pSrcValue->m.newSigCertPresent) {
      asn1Copy_CMP_CMPCertificate (pctxt, &pSrcValue->newSigCert, &pDstValue->newSigCert);
   }

   if (pSrcValue->m.caCertsPresent) {
      asn1Copy_CMP_KeyRecRepContent_caCerts (pctxt, &pSrcValue->caCerts, &pDstValue->caCerts);
   }

   if (pSrcValue->m.keyPairHistPresent) {
      asn1Copy_CMP_KeyRecRepContent_keyPairHist (pctxt, &pSrcValue->keyPairHist, &pDstValue->keyPairHist);
   }

}

ASN1C_CMP_KeyRecRepContent::ASN1C_CMP_KeyRecRepContent (ASN1C_CMP_KeyRecRepContent& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CMP_KeyRecRepContent::ASN1T_CMP_KeyRecRepContent (ASN1C_CMP_KeyRecRepContent& original)
{
   original.getCopy (this);
}

ASN1T_CMP_KeyRecRepContent& ASN1C_CMP_KeyRecRepContent::getCopy (ASN1T_CMP_KeyRecRepContent* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_KeyRecRepContent);
      new (pDstData) ASN1T_CMP_KeyRecRepContent;
   }

   asn1Copy_CMP_KeyRecRepContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_KeyRecRepContent* ASN1C_CMP_KeyRecRepContent::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_KeyRecRepContent* pDstData = new ASN1T_CMP_KeyRecRepContent;

   asn1Copy_CMP_KeyRecRepContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_RevDetails (OSCTXT* pctxt, ASN1T_CMP_RevDetails* pSrcValue, 
   ASN1T_CMP_RevDetails* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   OSCRTLMEMCPY (&pDstValue->m, &pSrcValue->m, sizeof (pDstValue->m));
   asn1Copy_CRMF_CertTemplate (pctxt, &pSrcValue->certDetails, &pDstValue->certDetails);

   if (pSrcValue->m.crlEntryDetailsPresent) {
      asn1Copy_EXP_Extensions (pctxt, &pSrcValue->crlEntryDetails, &pDstValue->crlEntryDetails);
   }

}

ASN1C_CMP_RevDetails::ASN1C_CMP_RevDetails (ASN1C_CMP_RevDetails& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CMP_RevDetails::ASN1T_CMP_RevDetails (ASN1C_CMP_RevDetails& original)
{
   original.getCopy (this);
}

ASN1T_CMP_RevDetails& ASN1C_CMP_RevDetails::getCopy (ASN1T_CMP_RevDetails* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_RevDetails);
      new (pDstData) ASN1T_CMP_RevDetails;
   }

   asn1Copy_CMP_RevDetails (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_RevDetails* ASN1C_CMP_RevDetails::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_RevDetails* pDstData = new ASN1T_CMP_RevDetails;

   asn1Copy_CMP_RevDetails (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_RevReqContent (OSCTXT* pctxt, 
   ASN1T_CMP_RevReqContent* pSrcValue, ASN1T_CMP_RevReqContent* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   {
      OSUINT32 xx1;
      ASN1T_CMP_RevDetails* pSrcData;
      OSRTDListNode* pnode;

      rtxDListInit (pDstValue);
      pnode = pSrcValue->head;
      for (xx1 = 0; xx1 < pSrcValue->count; xx1++) {
         ASN1T_CMP_RevDetails* pDstData = rtxMemAllocTypeZ (pctxt, ASN1T_CMP_RevDetails);
         pSrcData = (ASN1T_CMP_RevDetails*) pnode->data;

         asn1Copy_CMP_RevDetails (pctxt, pSrcData, pDstData);

         rtxDListAppend (pctxt, pDstValue, (void*)pDstData);
         pnode = pnode->next;
      }
   }
}

ASN1C_CMP_RevReqContent::ASN1C_CMP_RevReqContent (ASN1C_CMP_RevReqContent& original) :
   ASN1CSeqOfList(*original.mpContext, original.getCopy()), msgData (*(ASN1T_CMP_RevReqContent*)pList)
{
}

ASN1C_CMP_RevReqContent& ASN1C_CMP_RevReqContent::operator= (ASN1C_CMP_RevReqContent& srcData)
{
   clear ();
   asn1Copy_CMP_RevReqContent (getCtxtPtr(), &srcData.msgData, &msgData);
   return *this;
}

ASN1T_CMP_RevReqContent& ASN1C_CMP_RevReqContent::getCopy (ASN1T_CMP_RevReqContent* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_RevReqContent);
      new (pDstData) ASN1T_CMP_RevReqContent;
   }

   asn1Copy_CMP_RevReqContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_RevReqContent* ASN1C_CMP_RevReqContent::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_RevReqContent* pDstData = new ASN1T_CMP_RevReqContent;

   asn1Copy_CMP_RevReqContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_RevRepContent_status (OSCTXT* pctxt, 
   ASN1T_CMP_RevRepContent_status* pSrcValue, ASN1T_CMP_RevRepContent_status*
    pDstValue)
{
   if (pSrcValue == pDstValue) return;

   {
      OSUINT32 xx1;
      ASN1T_CMP_PKIStatusInfo* pSrcData;
      OSRTDListNode* pnode;

      rtxDListInit (pDstValue);
      pnode = pSrcValue->head;
      for (xx1 = 0; xx1 < pSrcValue->count; xx1++) {
         ASN1T_CMP_PKIStatusInfo* pDstData = rtxMemAllocTypeZ (pctxt, ASN1T_CMP_PKIStatusInfo);
         pSrcData = (ASN1T_CMP_PKIStatusInfo*) pnode->data;

         asn1Copy_CMP_PKIStatusInfo (pctxt, pSrcData, pDstData);

         rtxDListAppend (pctxt, pDstValue, (void*)pDstData);
         pnode = pnode->next;
      }
   }
}

ASN1C_CMP_RevRepContent_status::ASN1C_CMP_RevRepContent_status (ASN1C_CMP_RevRepContent_status& original) :
   ASN1CSeqOfList(*original.mpContext, original.getCopy()), msgData (*(ASN1T_CMP_RevRepContent_status*)pList)
{
}

ASN1C_CMP_RevRepContent_status& ASN1C_CMP_RevRepContent_status::operator= (ASN1C_CMP_RevRepContent_status& srcData)
{
   clear ();
   asn1Copy_CMP_RevRepContent_status (getCtxtPtr(), &srcData.msgData, &msgData);
   return *this;
}

ASN1T_CMP_RevRepContent_status& ASN1C_CMP_RevRepContent_status::getCopy (ASN1T_CMP_RevRepContent_status* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_RevRepContent_status);
      new (pDstData) ASN1T_CMP_RevRepContent_status;
   }

   asn1Copy_CMP_RevRepContent_status (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_RevRepContent_status* ASN1C_CMP_RevRepContent_status::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_RevRepContent_status* pDstData = new ASN1T_CMP_RevRepContent_status;

   asn1Copy_CMP_RevRepContent_status (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_RevRepContent_revCerts (OSCTXT* pctxt, 
   ASN1T_CMP_RevRepContent_revCerts* pSrcValue, 
   ASN1T_CMP_RevRepContent_revCerts* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   {
      OSUINT32 xx1;
      ASN1T_CRMF_CertId* pSrcData;
      OSRTDListNode* pnode;

      rtxDListInit (pDstValue);
      pnode = pSrcValue->head;
      for (xx1 = 0; xx1 < pSrcValue->count; xx1++) {
         ASN1T_CRMF_CertId* pDstData = rtxMemAllocTypeZ (pctxt, ASN1T_CRMF_CertId);
         pSrcData = (ASN1T_CRMF_CertId*) pnode->data;

         asn1Copy_CRMF_CertId (pctxt, pSrcData, pDstData);

         rtxDListAppend (pctxt, pDstValue, (void*)pDstData);
         pnode = pnode->next;
      }
   }
}

ASN1C_CMP_RevRepContent_revCerts::ASN1C_CMP_RevRepContent_revCerts (ASN1C_CMP_RevRepContent_revCerts& original) :
   ASN1CSeqOfList(*original.mpContext, original.getCopy()), msgData (*(ASN1T_CMP_RevRepContent_revCerts*)pList)
{
}

ASN1C_CMP_RevRepContent_revCerts& ASN1C_CMP_RevRepContent_revCerts::operator= (ASN1C_CMP_RevRepContent_revCerts& srcData)
{
   clear ();
   asn1Copy_CMP_RevRepContent_revCerts (getCtxtPtr(), &srcData.msgData, &msgData);
   return *this;
}

ASN1T_CMP_RevRepContent_revCerts& ASN1C_CMP_RevRepContent_revCerts::getCopy (ASN1T_CMP_RevRepContent_revCerts* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_RevRepContent_revCerts);
      new (pDstData) ASN1T_CMP_RevRepContent_revCerts;
   }

   asn1Copy_CMP_RevRepContent_revCerts (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_RevRepContent_revCerts* ASN1C_CMP_RevRepContent_revCerts::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_RevRepContent_revCerts* pDstData = new ASN1T_CMP_RevRepContent_revCerts;

   asn1Copy_CMP_RevRepContent_revCerts (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_RevRepContent_crls (OSCTXT* pctxt, 
   ASN1T_CMP_RevRepContent_crls* pSrcValue, ASN1T_CMP_RevRepContent_crls*
    pDstValue)
{
   if (pSrcValue == pDstValue) return;

   {
      OSUINT32 xx1;
      ASN1T_EXP_CertificateList* pSrcData;
      OSRTDListNode* pnode;

      rtxDListInit (pDstValue);
      pnode = pSrcValue->head;
      for (xx1 = 0; xx1 < pSrcValue->count; xx1++) {
         ASN1T_EXP_CertificateList* pDstData = rtxMemAllocTypeZ (pctxt, ASN1T_EXP_CertificateList);
         pSrcData = (ASN1T_EXP_CertificateList*) pnode->data;

         asn1Copy_EXP_CertificateList (pctxt, pSrcData, pDstData);

         rtxDListAppend (pctxt, pDstValue, (void*)pDstData);
         pnode = pnode->next;
      }
   }
}

ASN1C_CMP_RevRepContent_crls::ASN1C_CMP_RevRepContent_crls (ASN1C_CMP_RevRepContent_crls& original) :
   ASN1CSeqOfList(*original.mpContext, original.getCopy()), msgData (*(ASN1T_CMP_RevRepContent_crls*)pList)
{
}

ASN1C_CMP_RevRepContent_crls& ASN1C_CMP_RevRepContent_crls::operator= (ASN1C_CMP_RevRepContent_crls& srcData)
{
   clear ();
   asn1Copy_CMP_RevRepContent_crls (getCtxtPtr(), &srcData.msgData, &msgData);
   return *this;
}

ASN1T_CMP_RevRepContent_crls& ASN1C_CMP_RevRepContent_crls::getCopy (ASN1T_CMP_RevRepContent_crls* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_RevRepContent_crls);
      new (pDstData) ASN1T_CMP_RevRepContent_crls;
   }

   asn1Copy_CMP_RevRepContent_crls (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_RevRepContent_crls* ASN1C_CMP_RevRepContent_crls::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_RevRepContent_crls* pDstData = new ASN1T_CMP_RevRepContent_crls;

   asn1Copy_CMP_RevRepContent_crls (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_RevRepContent (OSCTXT* pctxt, 
   ASN1T_CMP_RevRepContent* pSrcValue, ASN1T_CMP_RevRepContent* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   OSCRTLMEMCPY (&pDstValue->m, &pSrcValue->m, sizeof (pDstValue->m));
   asn1Copy_CMP_RevRepContent_status (pctxt, &pSrcValue->status, &pDstValue->status);

   if (pSrcValue->m.revCertsPresent) {
      asn1Copy_CMP_RevRepContent_revCerts (pctxt, &pSrcValue->revCerts, &pDstValue->revCerts);
   }

   if (pSrcValue->m.crlsPresent) {
      asn1Copy_CMP_RevRepContent_crls (pctxt, &pSrcValue->crls, &pDstValue->crls);
   }

}

ASN1C_CMP_RevRepContent::ASN1C_CMP_RevRepContent (ASN1C_CMP_RevRepContent& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CMP_RevRepContent::ASN1T_CMP_RevRepContent (ASN1C_CMP_RevRepContent& original)
{
   original.getCopy (this);
}

ASN1T_CMP_RevRepContent& ASN1C_CMP_RevRepContent::getCopy (ASN1T_CMP_RevRepContent* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_RevRepContent);
      new (pDstData) ASN1T_CMP_RevRepContent;
   }

   asn1Copy_CMP_RevRepContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_RevRepContent* ASN1C_CMP_RevRepContent::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_RevRepContent* pDstData = new ASN1T_CMP_RevRepContent;

   asn1Copy_CMP_RevRepContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_CAKeyUpdAnnContent (OSCTXT* pctxt, 
   ASN1T_CMP_CAKeyUpdAnnContent* pSrcValue, ASN1T_CMP_CAKeyUpdAnnContent*
    pDstValue)
{
   if (pSrcValue == pDstValue) return;

   asn1Copy_CMP_CMPCertificate (pctxt, &pSrcValue->oldWithNew, &pDstValue->oldWithNew);

   asn1Copy_CMP_CMPCertificate (pctxt, &pSrcValue->newWithOld, &pDstValue->newWithOld);

   asn1Copy_CMP_CMPCertificate (pctxt, &pSrcValue->newWithNew, &pDstValue->newWithNew);

}

ASN1C_CMP_CAKeyUpdAnnContent::ASN1C_CMP_CAKeyUpdAnnContent (ASN1C_CMP_CAKeyUpdAnnContent& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CMP_CAKeyUpdAnnContent::ASN1T_CMP_CAKeyUpdAnnContent (ASN1C_CMP_CAKeyUpdAnnContent& original)
{
   original.getCopy (this);
}

ASN1T_CMP_CAKeyUpdAnnContent& ASN1C_CMP_CAKeyUpdAnnContent::getCopy (ASN1T_CMP_CAKeyUpdAnnContent* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_CAKeyUpdAnnContent);
      new (pDstData) ASN1T_CMP_CAKeyUpdAnnContent;
   }

   asn1Copy_CMP_CAKeyUpdAnnContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_CAKeyUpdAnnContent* ASN1C_CMP_CAKeyUpdAnnContent::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_CAKeyUpdAnnContent* pDstData = new ASN1T_CMP_CAKeyUpdAnnContent;

   asn1Copy_CMP_CAKeyUpdAnnContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_CertAnnContent (OSCTXT* pctxt, 
   ASN1T_CMP_CertAnnContent* pSrcValue, ASN1T_CMP_CertAnnContent* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   asn1Copy_CMP_CMPCertificate (pctxt, pSrcValue, pDstValue);
}

ASN1C_CMP_CertAnnContent::ASN1C_CMP_CertAnnContent (ASN1C_CMP_CertAnnContent& original) :
   ASN1C_CMP_CMPCertificate (original)
{
}

ASN1T_CMP_CertAnnContent& ASN1C_CMP_CertAnnContent::getCopy (ASN1T_CMP_CertAnnContent* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_CertAnnContent);
      new (pDstData) ASN1T_CMP_CertAnnContent;
   }

   asn1Copy_CMP_CertAnnContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_CertAnnContent* ASN1C_CMP_CertAnnContent::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_CertAnnContent* pDstData = new ASN1T_CMP_CertAnnContent;

   asn1Copy_CMP_CertAnnContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_RevAnnContent (OSCTXT* pctxt, 
   ASN1T_CMP_RevAnnContent* pSrcValue, ASN1T_CMP_RevAnnContent* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   OSCRTLMEMCPY (&pDstValue->m, &pSrcValue->m, sizeof (pDstValue->m));
   pDstValue->status = pSrcValue->status;

   asn1Copy_CRMF_CertId (pctxt, &pSrcValue->certId, &pDstValue->certId);

   RTCOPYCHARSTR (pctxt, (char *)pSrcValue->willBeRevokedAt, (char **)&pDstValue->willBeRevokedAt);

   RTCOPYCHARSTR (pctxt, (char *)pSrcValue->badSinceDate, (char **)&pDstValue->badSinceDate);

   if (pSrcValue->m.crlDetailsPresent) {
      asn1Copy_EXP_Extensions (pctxt, &pSrcValue->crlDetails, &pDstValue->crlDetails);
   }

}

ASN1C_CMP_RevAnnContent::ASN1C_CMP_RevAnnContent (ASN1C_CMP_RevAnnContent& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CMP_RevAnnContent::ASN1T_CMP_RevAnnContent (ASN1C_CMP_RevAnnContent& original)
{
   original.getCopy (this);
}

ASN1T_CMP_RevAnnContent& ASN1C_CMP_RevAnnContent::getCopy (ASN1T_CMP_RevAnnContent* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_RevAnnContent);
      new (pDstData) ASN1T_CMP_RevAnnContent;
   }

   asn1Copy_CMP_RevAnnContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_RevAnnContent* ASN1C_CMP_RevAnnContent::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_RevAnnContent* pDstData = new ASN1T_CMP_RevAnnContent;

   asn1Copy_CMP_RevAnnContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_CRLAnnContent (OSCTXT* pctxt, 
   ASN1T_CMP_CRLAnnContent* pSrcValue, ASN1T_CMP_CRLAnnContent* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   {
      OSUINT32 xx1;
      ASN1T_EXP_CertificateList* pSrcData;
      OSRTDListNode* pnode;

      rtxDListInit (pDstValue);
      pnode = pSrcValue->head;
      for (xx1 = 0; xx1 < pSrcValue->count; xx1++) {
         ASN1T_EXP_CertificateList* pDstData = rtxMemAllocTypeZ (pctxt, ASN1T_EXP_CertificateList);
         pSrcData = (ASN1T_EXP_CertificateList*) pnode->data;

         asn1Copy_EXP_CertificateList (pctxt, pSrcData, pDstData);

         rtxDListAppend (pctxt, pDstValue, (void*)pDstData);
         pnode = pnode->next;
      }
   }
}

ASN1C_CMP_CRLAnnContent::ASN1C_CMP_CRLAnnContent (ASN1C_CMP_CRLAnnContent& original) :
   ASN1CSeqOfList(*original.mpContext, original.getCopy()), msgData (*(ASN1T_CMP_CRLAnnContent*)pList)
{
}

ASN1C_CMP_CRLAnnContent& ASN1C_CMP_CRLAnnContent::operator= (ASN1C_CMP_CRLAnnContent& srcData)
{
   clear ();
   asn1Copy_CMP_CRLAnnContent (getCtxtPtr(), &srcData.msgData, &msgData);
   return *this;
}

ASN1T_CMP_CRLAnnContent& ASN1C_CMP_CRLAnnContent::getCopy (ASN1T_CMP_CRLAnnContent* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_CRLAnnContent);
      new (pDstData) ASN1T_CMP_CRLAnnContent;
   }

   asn1Copy_CMP_CRLAnnContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_CRLAnnContent* ASN1C_CMP_CRLAnnContent::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_CRLAnnContent* pDstData = new ASN1T_CMP_CRLAnnContent;

   asn1Copy_CMP_CRLAnnContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_GenMsgContent (OSCTXT* pctxt, 
   ASN1T_CMP_GenMsgContent* pSrcValue, ASN1T_CMP_GenMsgContent* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   {
      OSUINT32 xx1;
      ASN1T_CMP_InfoTypeAndValue* pSrcData;
      OSRTDListNode* pnode;

      rtxDListInit (pDstValue);
      pnode = pSrcValue->head;
      for (xx1 = 0; xx1 < pSrcValue->count; xx1++) {
         ASN1T_CMP_InfoTypeAndValue* pDstData = rtxMemAllocTypeZ (pctxt, ASN1T_CMP_InfoTypeAndValue);
         pSrcData = (ASN1T_CMP_InfoTypeAndValue*) pnode->data;

         asn1Copy_CMP_InfoTypeAndValue (pctxt, pSrcData, pDstData);

         rtxDListAppend (pctxt, pDstValue, (void*)pDstData);
         pnode = pnode->next;
      }
   }
}

ASN1C_CMP_GenMsgContent::ASN1C_CMP_GenMsgContent (ASN1C_CMP_GenMsgContent& original) :
   ASN1CSeqOfList(*original.mpContext, original.getCopy()), msgData (*(ASN1T_CMP_GenMsgContent*)pList)
{
}

ASN1C_CMP_GenMsgContent& ASN1C_CMP_GenMsgContent::operator= (ASN1C_CMP_GenMsgContent& srcData)
{
   clear ();
   asn1Copy_CMP_GenMsgContent (getCtxtPtr(), &srcData.msgData, &msgData);
   return *this;
}

ASN1T_CMP_GenMsgContent& ASN1C_CMP_GenMsgContent::getCopy (ASN1T_CMP_GenMsgContent* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_GenMsgContent);
      new (pDstData) ASN1T_CMP_GenMsgContent;
   }

   asn1Copy_CMP_GenMsgContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_GenMsgContent* ASN1C_CMP_GenMsgContent::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_GenMsgContent* pDstData = new ASN1T_CMP_GenMsgContent;

   asn1Copy_CMP_GenMsgContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_GenRepContent (OSCTXT* pctxt, 
   ASN1T_CMP_GenRepContent* pSrcValue, ASN1T_CMP_GenRepContent* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   {
      OSUINT32 xx1;
      ASN1T_CMP_InfoTypeAndValue* pSrcData;
      OSRTDListNode* pnode;

      rtxDListInit (pDstValue);
      pnode = pSrcValue->head;
      for (xx1 = 0; xx1 < pSrcValue->count; xx1++) {
         ASN1T_CMP_InfoTypeAndValue* pDstData = rtxMemAllocTypeZ (pctxt, ASN1T_CMP_InfoTypeAndValue);
         pSrcData = (ASN1T_CMP_InfoTypeAndValue*) pnode->data;

         asn1Copy_CMP_InfoTypeAndValue (pctxt, pSrcData, pDstData);

         rtxDListAppend (pctxt, pDstValue, (void*)pDstData);
         pnode = pnode->next;
      }
   }
}

ASN1C_CMP_GenRepContent::ASN1C_CMP_GenRepContent (ASN1C_CMP_GenRepContent& original) :
   ASN1CSeqOfList(*original.mpContext, original.getCopy()), msgData (*(ASN1T_CMP_GenRepContent*)pList)
{
}

ASN1C_CMP_GenRepContent& ASN1C_CMP_GenRepContent::operator= (ASN1C_CMP_GenRepContent& srcData)
{
   clear ();
   asn1Copy_CMP_GenRepContent (getCtxtPtr(), &srcData.msgData, &msgData);
   return *this;
}

ASN1T_CMP_GenRepContent& ASN1C_CMP_GenRepContent::getCopy (ASN1T_CMP_GenRepContent* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_GenRepContent);
      new (pDstData) ASN1T_CMP_GenRepContent;
   }

   asn1Copy_CMP_GenRepContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_GenRepContent* ASN1C_CMP_GenRepContent::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_GenRepContent* pDstData = new ASN1T_CMP_GenRepContent;

   asn1Copy_CMP_GenRepContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_ErrorMsgContent (OSCTXT* pctxt, 
   ASN1T_CMP_ErrorMsgContent* pSrcValue, ASN1T_CMP_ErrorMsgContent* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   OSCRTLMEMCPY (&pDstValue->m, &pSrcValue->m, sizeof (pDstValue->m));
   asn1Copy_CMP_PKIStatusInfo (pctxt, &pSrcValue->pKIStatusInfo, &pDstValue->pKIStatusInfo);

   if (pSrcValue->m.errorCodePresent) {
      pDstValue->errorCode = pSrcValue->errorCode;
   }

   if (pSrcValue->m.errorDetailsPresent) {
      asn1Copy_CMP_PKIFreeText (pctxt, &pSrcValue->errorDetails, &pDstValue->errorDetails);
   }

}

ASN1C_CMP_ErrorMsgContent::ASN1C_CMP_ErrorMsgContent (ASN1C_CMP_ErrorMsgContent& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CMP_ErrorMsgContent::ASN1T_CMP_ErrorMsgContent (ASN1C_CMP_ErrorMsgContent& original)
{
   original.getCopy (this);
}

ASN1T_CMP_ErrorMsgContent& ASN1C_CMP_ErrorMsgContent::getCopy (ASN1T_CMP_ErrorMsgContent* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_ErrorMsgContent);
      new (pDstData) ASN1T_CMP_ErrorMsgContent;
   }

   asn1Copy_CMP_ErrorMsgContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_ErrorMsgContent* ASN1C_CMP_ErrorMsgContent::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_ErrorMsgContent* pDstData = new ASN1T_CMP_ErrorMsgContent;

   asn1Copy_CMP_ErrorMsgContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_CertStatus (OSCTXT* pctxt, ASN1T_CMP_CertStatus* pSrcValue, 
   ASN1T_CMP_CertStatus* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   OSCRTLMEMCPY (&pDstValue->m, &pSrcValue->m, sizeof (pDstValue->m));
   rtCopyDynOctStr (pctxt, &pSrcValue->certHash, &pDstValue->certHash);

   pDstValue->certReqId = pSrcValue->certReqId;

   if (pSrcValue->m.statusInfoPresent) {
      asn1Copy_CMP_PKIStatusInfo (pctxt, &pSrcValue->statusInfo, &pDstValue->statusInfo);
   }

}

ASN1C_CMP_CertStatus::ASN1C_CMP_CertStatus (ASN1C_CMP_CertStatus& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CMP_CertStatus::ASN1T_CMP_CertStatus (ASN1C_CMP_CertStatus& original)
{
   original.getCopy (this);
}

ASN1T_CMP_CertStatus& ASN1C_CMP_CertStatus::getCopy (ASN1T_CMP_CertStatus* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_CertStatus);
      new (pDstData) ASN1T_CMP_CertStatus;
   }

   asn1Copy_CMP_CertStatus (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_CertStatus* ASN1C_CMP_CertStatus::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_CertStatus* pDstData = new ASN1T_CMP_CertStatus;

   asn1Copy_CMP_CertStatus (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_CertConfirmContent (OSCTXT* pctxt, 
   ASN1T_CMP_CertConfirmContent* pSrcValue, ASN1T_CMP_CertConfirmContent*
    pDstValue)
{
   if (pSrcValue == pDstValue) return;

   {
      OSUINT32 xx1;
      ASN1T_CMP_CertStatus* pSrcData;
      OSRTDListNode* pnode;

      rtxDListInit (pDstValue);
      pnode = pSrcValue->head;
      for (xx1 = 0; xx1 < pSrcValue->count; xx1++) {
         ASN1T_CMP_CertStatus* pDstData = rtxMemAllocTypeZ (pctxt, ASN1T_CMP_CertStatus);
         pSrcData = (ASN1T_CMP_CertStatus*) pnode->data;

         asn1Copy_CMP_CertStatus (pctxt, pSrcData, pDstData);

         rtxDListAppend (pctxt, pDstValue, (void*)pDstData);
         pnode = pnode->next;
      }
   }
}

ASN1C_CMP_CertConfirmContent::ASN1C_CMP_CertConfirmContent (ASN1C_CMP_CertConfirmContent& original) :
   ASN1CSeqOfList(*original.mpContext, original.getCopy()), msgData (*(ASN1T_CMP_CertConfirmContent*)pList)
{
}

ASN1C_CMP_CertConfirmContent& ASN1C_CMP_CertConfirmContent::operator= (ASN1C_CMP_CertConfirmContent& srcData)
{
   clear ();
   asn1Copy_CMP_CertConfirmContent (getCtxtPtr(), &srcData.msgData, &msgData);
   return *this;
}

ASN1T_CMP_CertConfirmContent& ASN1C_CMP_CertConfirmContent::getCopy (ASN1T_CMP_CertConfirmContent* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_CertConfirmContent);
      new (pDstData) ASN1T_CMP_CertConfirmContent;
   }

   asn1Copy_CMP_CertConfirmContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_CertConfirmContent* ASN1C_CMP_CertConfirmContent::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_CertConfirmContent* pDstData = new ASN1T_CMP_CertConfirmContent;

   asn1Copy_CMP_CertConfirmContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_PollReqContent_element (OSCTXT* pctxt, 
   ASN1T_CMP_PollReqContent_element* pSrcValue, 
   ASN1T_CMP_PollReqContent_element* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   pDstValue->certReqId = pSrcValue->certReqId;

}

ASN1C_CMP_PollReqContent_element::ASN1C_CMP_PollReqContent_element (ASN1C_CMP_PollReqContent_element& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CMP_PollReqContent_element::ASN1T_CMP_PollReqContent_element (ASN1C_CMP_PollReqContent_element& original)
{
   original.getCopy (this);
}

ASN1T_CMP_PollReqContent_element& ASN1C_CMP_PollReqContent_element::getCopy (ASN1T_CMP_PollReqContent_element* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_PollReqContent_element);
      new (pDstData) ASN1T_CMP_PollReqContent_element;
   }

   asn1Copy_CMP_PollReqContent_element (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_PollReqContent_element* ASN1C_CMP_PollReqContent_element::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_PollReqContent_element* pDstData = new ASN1T_CMP_PollReqContent_element;

   asn1Copy_CMP_PollReqContent_element (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_PollReqContent (OSCTXT* pctxt, 
   ASN1T_CMP_PollReqContent* pSrcValue, ASN1T_CMP_PollReqContent* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   {
      OSUINT32 xx1;
      ASN1T_CMP_PollReqContent_element* pSrcData;
      OSRTDListNode* pnode;

      rtxDListInit (pDstValue);
      pnode = pSrcValue->head;
      for (xx1 = 0; xx1 < pSrcValue->count; xx1++) {
         ASN1T_CMP_PollReqContent_element* pDstData = rtxMemAllocTypeZ (pctxt, ASN1T_CMP_PollReqContent_element);
         pSrcData = (ASN1T_CMP_PollReqContent_element*) pnode->data;

         asn1Copy_CMP_PollReqContent_element (pctxt, pSrcData, pDstData);

         rtxDListAppend (pctxt, pDstValue, (void*)pDstData);
         pnode = pnode->next;
      }
   }
}

ASN1C_CMP_PollReqContent::ASN1C_CMP_PollReqContent (ASN1C_CMP_PollReqContent& original) :
   ASN1CSeqOfList(*original.mpContext, original.getCopy()), msgData (*(ASN1T_CMP_PollReqContent*)pList)
{
}

ASN1C_CMP_PollReqContent& ASN1C_CMP_PollReqContent::operator= (ASN1C_CMP_PollReqContent& srcData)
{
   clear ();
   asn1Copy_CMP_PollReqContent (getCtxtPtr(), &srcData.msgData, &msgData);
   return *this;
}

ASN1T_CMP_PollReqContent& ASN1C_CMP_PollReqContent::getCopy (ASN1T_CMP_PollReqContent* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_PollReqContent);
      new (pDstData) ASN1T_CMP_PollReqContent;
   }

   asn1Copy_CMP_PollReqContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_PollReqContent* ASN1C_CMP_PollReqContent::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_PollReqContent* pDstData = new ASN1T_CMP_PollReqContent;

   asn1Copy_CMP_PollReqContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_PollRepContent_element (OSCTXT* pctxt, 
   ASN1T_CMP_PollRepContent_element* pSrcValue, 
   ASN1T_CMP_PollRepContent_element* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   OSCRTLMEMCPY (&pDstValue->m, &pSrcValue->m, sizeof (pDstValue->m));
   pDstValue->certReqId = pSrcValue->certReqId;

   pDstValue->checkAfter = pSrcValue->checkAfter;

   if (pSrcValue->m.reasonPresent) {
      asn1Copy_CMP_PKIFreeText (pctxt, &pSrcValue->reason, &pDstValue->reason);
   }

}

ASN1C_CMP_PollRepContent_element::ASN1C_CMP_PollRepContent_element (ASN1C_CMP_PollRepContent_element& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CMP_PollRepContent_element::ASN1T_CMP_PollRepContent_element (ASN1C_CMP_PollRepContent_element& original)
{
   original.getCopy (this);
}

ASN1T_CMP_PollRepContent_element& ASN1C_CMP_PollRepContent_element::getCopy (ASN1T_CMP_PollRepContent_element* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_PollRepContent_element);
      new (pDstData) ASN1T_CMP_PollRepContent_element;
   }

   asn1Copy_CMP_PollRepContent_element (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_PollRepContent_element* ASN1C_CMP_PollRepContent_element::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_PollRepContent_element* pDstData = new ASN1T_CMP_PollRepContent_element;

   asn1Copy_CMP_PollRepContent_element (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_PollRepContent (OSCTXT* pctxt, 
   ASN1T_CMP_PollRepContent* pSrcValue, ASN1T_CMP_PollRepContent* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   {
      OSUINT32 xx1;
      ASN1T_CMP_PollRepContent_element* pSrcData;
      OSRTDListNode* pnode;

      rtxDListInit (pDstValue);
      pnode = pSrcValue->head;
      for (xx1 = 0; xx1 < pSrcValue->count; xx1++) {
         ASN1T_CMP_PollRepContent_element* pDstData = rtxMemAllocTypeZ (pctxt, ASN1T_CMP_PollRepContent_element);
         pSrcData = (ASN1T_CMP_PollRepContent_element*) pnode->data;

         asn1Copy_CMP_PollRepContent_element (pctxt, pSrcData, pDstData);

         rtxDListAppend (pctxt, pDstValue, (void*)pDstData);
         pnode = pnode->next;
      }
   }
}

ASN1C_CMP_PollRepContent::ASN1C_CMP_PollRepContent (ASN1C_CMP_PollRepContent& original) :
   ASN1CSeqOfList(*original.mpContext, original.getCopy()), msgData (*(ASN1T_CMP_PollRepContent*)pList)
{
}

ASN1C_CMP_PollRepContent& ASN1C_CMP_PollRepContent::operator= (ASN1C_CMP_PollRepContent& srcData)
{
   clear ();
   asn1Copy_CMP_PollRepContent (getCtxtPtr(), &srcData.msgData, &msgData);
   return *this;
}

ASN1T_CMP_PollRepContent& ASN1C_CMP_PollRepContent::getCopy (ASN1T_CMP_PollRepContent* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_PollRepContent);
      new (pDstData) ASN1T_CMP_PollRepContent;
   }

   asn1Copy_CMP_PollRepContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_PollRepContent* ASN1C_CMP_PollRepContent::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_PollRepContent* pDstData = new ASN1T_CMP_PollRepContent;

   asn1Copy_CMP_PollRepContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_PKIBody (OSCTXT* pctxt, ASN1T_CMP_PKIBody* pSrcValue, 
   ASN1T_CMP_PKIBody* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   pDstValue->t = pSrcValue->t;
   switch (pSrcValue->t)
   {
      /* ir */
      case 1:
         pDstValue->u.ir = rtxMemAllocType (pctxt, ASN1T_CRMF_CertReqMessages);
         new (pDstValue->u.ir) ASN1T_CRMF_CertReqMessages;
         asn1Copy_CRMF_CertReqMessages (pctxt, pSrcValue->u.ir, pDstValue->u.ir);
         break;

      /* ip */
      case 2:
         pDstValue->u.ip = rtxMemAllocType (pctxt, ASN1T_CMP_CertRepMessage);
         new (pDstValue->u.ip) ASN1T_CMP_CertRepMessage;
         asn1Copy_CMP_CertRepMessage (pctxt, pSrcValue->u.ip, pDstValue->u.ip);
         break;

      /* cr */
      case 3:
         pDstValue->u.cr = rtxMemAllocType (pctxt, ASN1T_CRMF_CertReqMessages);
         new (pDstValue->u.cr) ASN1T_CRMF_CertReqMessages;
         asn1Copy_CRMF_CertReqMessages (pctxt, pSrcValue->u.cr, pDstValue->u.cr);
         break;

      /* cp */
      case 4:
         pDstValue->u.cp = rtxMemAllocType (pctxt, ASN1T_CMP_CertRepMessage);
         new (pDstValue->u.cp) ASN1T_CMP_CertRepMessage;
         asn1Copy_CMP_CertRepMessage (pctxt, pSrcValue->u.cp, pDstValue->u.cp);
         break;

      /* p10cr */
      case 5:
         pDstValue->u.p10cr = rtxMemAllocType (pctxt, ASN1T_PKCS10_CertificationRequest);
         new (pDstValue->u.p10cr) ASN1T_PKCS10_CertificationRequest;
         asn1Copy_PKCS10_CertificationRequest (pctxt, pSrcValue->u.p10cr, pDstValue->u.p10cr);
         break;

      /* popdecc */
      case 6:
         pDstValue->u.popdecc = rtxMemAllocType (pctxt, ASN1T_CMP_POPODecKeyChallContent);
         new (pDstValue->u.popdecc) ASN1T_CMP_POPODecKeyChallContent;
         asn1Copy_CMP_POPODecKeyChallContent (pctxt, pSrcValue->u.popdecc, pDstValue->u.popdecc);
         break;

      /* popdecr */
      case 7:
         pDstValue->u.popdecr = rtxMemAllocType (pctxt, ASN1T_CMP_POPODecKeyRespContent);
         new (pDstValue->u.popdecr) ASN1T_CMP_POPODecKeyRespContent;
         asn1Copy_CMP_POPODecKeyRespContent (pctxt, pSrcValue->u.popdecr, pDstValue->u.popdecr);
         break;

      /* kur */
      case 8:
         pDstValue->u.kur = rtxMemAllocType (pctxt, ASN1T_CRMF_CertReqMessages);
         new (pDstValue->u.kur) ASN1T_CRMF_CertReqMessages;
         asn1Copy_CRMF_CertReqMessages (pctxt, pSrcValue->u.kur, pDstValue->u.kur);
         break;

      /* kup */
      case 9:
         pDstValue->u.kup = rtxMemAllocType (pctxt, ASN1T_CMP_CertRepMessage);
         new (pDstValue->u.kup) ASN1T_CMP_CertRepMessage;
         asn1Copy_CMP_CertRepMessage (pctxt, pSrcValue->u.kup, pDstValue->u.kup);
         break;

      /* krr */
      case 10:
         pDstValue->u.krr = rtxMemAllocType (pctxt, ASN1T_CRMF_CertReqMessages);
         new (pDstValue->u.krr) ASN1T_CRMF_CertReqMessages;
         asn1Copy_CRMF_CertReqMessages (pctxt, pSrcValue->u.krr, pDstValue->u.krr);
         break;

      /* krp */
      case 11:
         pDstValue->u.krp = rtxMemAllocType (pctxt, ASN1T_CMP_KeyRecRepContent);
         new (pDstValue->u.krp) ASN1T_CMP_KeyRecRepContent;
         asn1Copy_CMP_KeyRecRepContent (pctxt, pSrcValue->u.krp, pDstValue->u.krp);
         break;

      /* rr */
      case 12:
         pDstValue->u.rr = rtxMemAllocType (pctxt, ASN1T_CMP_RevReqContent);
         new (pDstValue->u.rr) ASN1T_CMP_RevReqContent;
         asn1Copy_CMP_RevReqContent (pctxt, pSrcValue->u.rr, pDstValue->u.rr);
         break;

      /* rp */
      case 13:
         pDstValue->u.rp = rtxMemAllocType (pctxt, ASN1T_CMP_RevRepContent);
         new (pDstValue->u.rp) ASN1T_CMP_RevRepContent;
         asn1Copy_CMP_RevRepContent (pctxt, pSrcValue->u.rp, pDstValue->u.rp);
         break;

      /* ccr */
      case 14:
         pDstValue->u.ccr = rtxMemAllocType (pctxt, ASN1T_CRMF_CertReqMessages);
         new (pDstValue->u.ccr) ASN1T_CRMF_CertReqMessages;
         asn1Copy_CRMF_CertReqMessages (pctxt, pSrcValue->u.ccr, pDstValue->u.ccr);
         break;

      /* ccp */
      case 15:
         pDstValue->u.ccp = rtxMemAllocType (pctxt, ASN1T_CMP_CertRepMessage);
         new (pDstValue->u.ccp) ASN1T_CMP_CertRepMessage;
         asn1Copy_CMP_CertRepMessage (pctxt, pSrcValue->u.ccp, pDstValue->u.ccp);
         break;

      /* ckuann */
      case 16:
         pDstValue->u.ckuann = rtxMemAllocType (pctxt, ASN1T_CMP_CAKeyUpdAnnContent);
         new (pDstValue->u.ckuann) ASN1T_CMP_CAKeyUpdAnnContent;
         asn1Copy_CMP_CAKeyUpdAnnContent (pctxt, pSrcValue->u.ckuann, pDstValue->u.ckuann);
         break;

      /* cann */
      case 17:
         pDstValue->u.cann = rtxMemAllocType (pctxt, ASN1T_CMP_CertAnnContent);
         new (pDstValue->u.cann) ASN1T_CMP_CertAnnContent;
         asn1Copy_CMP_CertAnnContent (pctxt, pSrcValue->u.cann, pDstValue->u.cann);
         break;

      /* rann */
      case 18:
         pDstValue->u.rann = rtxMemAllocType (pctxt, ASN1T_CMP_RevAnnContent);
         new (pDstValue->u.rann) ASN1T_CMP_RevAnnContent;
         asn1Copy_CMP_RevAnnContent (pctxt, pSrcValue->u.rann, pDstValue->u.rann);
         break;

      /* crlann */
      case 19:
         pDstValue->u.crlann = rtxMemAllocType (pctxt, ASN1T_CMP_CRLAnnContent);
         new (pDstValue->u.crlann) ASN1T_CMP_CRLAnnContent;
         asn1Copy_CMP_CRLAnnContent (pctxt, pSrcValue->u.crlann, pDstValue->u.crlann);
         break;

      /* pkiconf */
      case 20:
         break;

      /* nested */
      case 21:
         pDstValue->u.nested = rtxMemAllocType (pctxt, ASN1T_CMP_NestedMessageContent);
         new (pDstValue->u.nested) ASN1T_CMP_NestedMessageContent;
         asn1Copy_CMP_NestedMessageContent (pctxt, (ASN1T_CMP_NestedMessageContent*)pSrcValue->u.nested, (ASN1T_CMP_NestedMessageContent*)pDstValue->u.nested);
         break;

      /* genm */
      case 22:
         pDstValue->u.genm = rtxMemAllocType (pctxt, ASN1T_CMP_GenMsgContent);
         new (pDstValue->u.genm) ASN1T_CMP_GenMsgContent;
         asn1Copy_CMP_GenMsgContent (pctxt, pSrcValue->u.genm, pDstValue->u.genm);
         break;

      /* genp */
      case 23:
         pDstValue->u.genp = rtxMemAllocType (pctxt, ASN1T_CMP_GenRepContent);
         new (pDstValue->u.genp) ASN1T_CMP_GenRepContent;
         asn1Copy_CMP_GenRepContent (pctxt, pSrcValue->u.genp, pDstValue->u.genp);
         break;

      /* error */
      case 24:
         pDstValue->u.error = rtxMemAllocType (pctxt, ASN1T_CMP_ErrorMsgContent);
         new (pDstValue->u.error) ASN1T_CMP_ErrorMsgContent;
         asn1Copy_CMP_ErrorMsgContent (pctxt, pSrcValue->u.error, pDstValue->u.error);
         break;

      /* certConf */
      case 25:
         pDstValue->u.certConf = rtxMemAllocType (pctxt, ASN1T_CMP_CertConfirmContent);
         new (pDstValue->u.certConf) ASN1T_CMP_CertConfirmContent;
         asn1Copy_CMP_CertConfirmContent (pctxt, pSrcValue->u.certConf, pDstValue->u.certConf);
         break;

      /* pollReq */
      case 26:
         pDstValue->u.pollReq = rtxMemAllocType (pctxt, ASN1T_CMP_PollReqContent);
         new (pDstValue->u.pollReq) ASN1T_CMP_PollReqContent;
         asn1Copy_CMP_PollReqContent (pctxt, pSrcValue->u.pollReq, pDstValue->u.pollReq);
         break;

      /* pollRep */
      case 27:
         pDstValue->u.pollRep = rtxMemAllocType (pctxt, ASN1T_CMP_PollRepContent);
         new (pDstValue->u.pollRep) ASN1T_CMP_PollRepContent;
         asn1Copy_CMP_PollRepContent (pctxt, pSrcValue->u.pollRep, pDstValue->u.pollRep);
         break;

      /* bcr */
      case 28:
         pDstValue->u.bcr = rtxMemAllocType (pctxt, ASN1T_CRMF_CertReqMessages);
         new (pDstValue->u.bcr) ASN1T_CRMF_CertReqMessages;
         asn1Copy_CRMF_CertReqMessages (pctxt, pSrcValue->u.bcr, pDstValue->u.bcr);
         break;

   }
}

ASN1C_CMP_PKIBody::ASN1C_CMP_PKIBody (ASN1C_CMP_PKIBody& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CMP_PKIBody::ASN1T_CMP_PKIBody (ASN1C_CMP_PKIBody& original)
{
   original.getCopy (this);
}

ASN1T_CMP_PKIBody& ASN1C_CMP_PKIBody::getCopy (ASN1T_CMP_PKIBody* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_PKIBody);
      new (pDstData) ASN1T_CMP_PKIBody;
   }

   asn1Copy_CMP_PKIBody (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_PKIBody* ASN1C_CMP_PKIBody::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_PKIBody* pDstData = new ASN1T_CMP_PKIBody;

   asn1Copy_CMP_PKIBody (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_PKIMessage_extraCerts (OSCTXT* pctxt, 
   ASN1T_CMP_PKIMessage_extraCerts* pSrcValue, ASN1T_CMP_PKIMessage_extraCerts*
    pDstValue)
{
   if (pSrcValue == pDstValue) return;

   {
      OSUINT32 xx1;
      ASN1T_CMP_CMPCertificate* pSrcData;
      OSRTDListNode* pnode;

      rtxDListInit (pDstValue);
      pnode = pSrcValue->head;
      for (xx1 = 0; xx1 < pSrcValue->count; xx1++) {
         ASN1T_CMP_CMPCertificate* pDstData = rtxMemAllocTypeZ (pctxt, ASN1T_CMP_CMPCertificate);
         pSrcData = (ASN1T_CMP_CMPCertificate*) pnode->data;

         asn1Copy_CMP_CMPCertificate (pctxt, pSrcData, pDstData);

         rtxDListAppend (pctxt, pDstValue, (void*)pDstData);
         pnode = pnode->next;
      }
   }
}

ASN1C_CMP_PKIMessage_extraCerts::ASN1C_CMP_PKIMessage_extraCerts (ASN1C_CMP_PKIMessage_extraCerts& original) :
   ASN1CSeqOfList(*original.mpContext, original.getCopy()), msgData (*(ASN1T_CMP_PKIMessage_extraCerts*)pList)
{
}

ASN1C_CMP_PKIMessage_extraCerts& ASN1C_CMP_PKIMessage_extraCerts::operator= (ASN1C_CMP_PKIMessage_extraCerts& srcData)
{
   clear ();
   asn1Copy_CMP_PKIMessage_extraCerts (getCtxtPtr(), &srcData.msgData, &msgData);
   return *this;
}

ASN1T_CMP_PKIMessage_extraCerts& ASN1C_CMP_PKIMessage_extraCerts::getCopy (ASN1T_CMP_PKIMessage_extraCerts* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_PKIMessage_extraCerts);
      new (pDstData) ASN1T_CMP_PKIMessage_extraCerts;
   }

   asn1Copy_CMP_PKIMessage_extraCerts (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_PKIMessage_extraCerts* ASN1C_CMP_PKIMessage_extraCerts::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_PKIMessage_extraCerts* pDstData = new ASN1T_CMP_PKIMessage_extraCerts;

   asn1Copy_CMP_PKIMessage_extraCerts (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_PKIMessage (OSCTXT* pctxt, ASN1T_CMP_PKIMessage* pSrcValue, 
   ASN1T_CMP_PKIMessage* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   OSCRTLMEMCPY (&pDstValue->m, &pSrcValue->m, sizeof (pDstValue->m));
   asn1Copy_CMP_PKIHeader (pctxt, &pSrcValue->header, &pDstValue->header);

   asn1Copy_CMP_PKIBody (pctxt, &pSrcValue->body, &pDstValue->body);

   if (pSrcValue->m.protectionPresent) {
      asn1Copy_CMP_PKIProtection (pctxt, &pSrcValue->protection, &pDstValue->protection);
   }

   if (pSrcValue->m.extraCertsPresent) {
      asn1Copy_CMP_PKIMessage_extraCerts (pctxt, &pSrcValue->extraCerts, &pDstValue->extraCerts);
   }

}

ASN1C_CMP_PKIMessage::ASN1C_CMP_PKIMessage (ASN1C_CMP_PKIMessage& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CMP_PKIMessage::ASN1T_CMP_PKIMessage (ASN1C_CMP_PKIMessage& original)
{
   original.getCopy (this);
}

ASN1T_CMP_PKIMessage& ASN1C_CMP_PKIMessage::getCopy (ASN1T_CMP_PKIMessage* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_PKIMessage);
      new (pDstData) ASN1T_CMP_PKIMessage;
   }

   asn1Copy_CMP_PKIMessage (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_PKIMessage* ASN1C_CMP_PKIMessage::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_PKIMessage* pDstData = new ASN1T_CMP_PKIMessage;

   asn1Copy_CMP_PKIMessage (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_PKIMessages (OSCTXT* pctxt, 
   ASN1T_CMP_PKIMessages* pSrcValue, ASN1T_CMP_PKIMessages* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   {
      OSUINT32 xx1;
      ASN1T_CMP_PKIMessage* pSrcData;
      OSRTDListNode* pnode;

      rtxDListInit (pDstValue);
      pnode = pSrcValue->head;
      for (xx1 = 0; xx1 < pSrcValue->count; xx1++) {
         ASN1T_CMP_PKIMessage* pDstData = rtxMemAllocTypeZ (pctxt, ASN1T_CMP_PKIMessage);
         pSrcData = (ASN1T_CMP_PKIMessage*) pnode->data;

         asn1Copy_CMP_PKIMessage (pctxt, pSrcData, pDstData);

         rtxDListAppend (pctxt, pDstValue, (void*)pDstData);
         pnode = pnode->next;
      }
   }
}

ASN1C_CMP_PKIMessages::ASN1C_CMP_PKIMessages (ASN1C_CMP_PKIMessages& original) :
   ASN1CSeqOfList(*original.mpContext, original.getCopy()), msgData (*(ASN1T_CMP_PKIMessages*)pList)
{
}

ASN1C_CMP_PKIMessages& ASN1C_CMP_PKIMessages::operator= (ASN1C_CMP_PKIMessages& srcData)
{
   clear ();
   asn1Copy_CMP_PKIMessages (getCtxtPtr(), &srcData.msgData, &msgData);
   return *this;
}

ASN1T_CMP_PKIMessages& ASN1C_CMP_PKIMessages::getCopy (ASN1T_CMP_PKIMessages* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_PKIMessages);
      new (pDstData) ASN1T_CMP_PKIMessages;
   }

   asn1Copy_CMP_PKIMessages (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_PKIMessages* ASN1C_CMP_PKIMessages::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_PKIMessages* pDstData = new ASN1T_CMP_PKIMessages;

   asn1Copy_CMP_PKIMessages (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_NestedMessageContent (OSCTXT* pctxt, 
   ASN1T_CMP_NestedMessageContent* pSrcValue, ASN1T_CMP_NestedMessageContent*
    pDstValue)
{
   if (pSrcValue == pDstValue) return;

   asn1Copy_CMP_PKIMessages (pctxt, pSrcValue, pDstValue);
}

ASN1C_CMP_NestedMessageContent::ASN1C_CMP_NestedMessageContent (ASN1C_CMP_NestedMessageContent& original) :
   ASN1C_CMP_PKIMessages (original)
{
}

ASN1T_CMP_NestedMessageContent& ASN1C_CMP_NestedMessageContent::getCopy (ASN1T_CMP_NestedMessageContent* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_NestedMessageContent);
      new (pDstData) ASN1T_CMP_NestedMessageContent;
   }

   asn1Copy_CMP_NestedMessageContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_NestedMessageContent* ASN1C_CMP_NestedMessageContent::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_NestedMessageContent* pDstData = new ASN1T_CMP_NestedMessageContent;

   asn1Copy_CMP_NestedMessageContent (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_OOBCert (OSCTXT* pctxt, ASN1T_CMP_OOBCert* pSrcValue, 
   ASN1T_CMP_OOBCert* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   asn1Copy_CMP_CMPCertificate (pctxt, pSrcValue, pDstValue);
}

ASN1C_CMP_OOBCert::ASN1C_CMP_OOBCert (ASN1C_CMP_OOBCert& original) :
   ASN1C_CMP_CMPCertificate (original)
{
}

ASN1T_CMP_OOBCert& ASN1C_CMP_OOBCert::getCopy (ASN1T_CMP_OOBCert* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_OOBCert);
      new (pDstData) ASN1T_CMP_OOBCert;
   }

   asn1Copy_CMP_OOBCert (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_OOBCert* ASN1C_CMP_OOBCert::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_OOBCert* pDstData = new ASN1T_CMP_OOBCert;

   asn1Copy_CMP_OOBCert (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_ProtectedPart (OSCTXT* pctxt, 
   ASN1T_CMP_ProtectedPart* pSrcValue, ASN1T_CMP_ProtectedPart* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   asn1Copy_CMP_PKIHeader (pctxt, &pSrcValue->header, &pDstValue->header);

   asn1Copy_CMP_PKIBody (pctxt, &pSrcValue->body, &pDstValue->body);

}

ASN1C_CMP_ProtectedPart::ASN1C_CMP_ProtectedPart (ASN1C_CMP_ProtectedPart& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CMP_ProtectedPart::ASN1T_CMP_ProtectedPart (ASN1C_CMP_ProtectedPart& original)
{
   original.getCopy (this);
}

ASN1T_CMP_ProtectedPart& ASN1C_CMP_ProtectedPart::getCopy (ASN1T_CMP_ProtectedPart* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_ProtectedPart);
      new (pDstData) ASN1T_CMP_ProtectedPart;
   }

   asn1Copy_CMP_ProtectedPart (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_ProtectedPart* ASN1C_CMP_ProtectedPart::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_ProtectedPart* pDstData = new ASN1T_CMP_ProtectedPart;

   asn1Copy_CMP_ProtectedPart (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_PBMParameter (OSCTXT* pctxt, 
   ASN1T_CMP_PBMParameter* pSrcValue, ASN1T_CMP_PBMParameter* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   rtCopyDynOctStr (pctxt, &pSrcValue->salt, &pDstValue->salt);

   asn1Copy_EXP_AlgorithmIdentifier (pctxt, &pSrcValue->owf, &pDstValue->owf);

   pDstValue->iterationCount = pSrcValue->iterationCount;

   asn1Copy_EXP_AlgorithmIdentifier (pctxt, &pSrcValue->mac, &pDstValue->mac);

}

ASN1C_CMP_PBMParameter::ASN1C_CMP_PBMParameter (ASN1C_CMP_PBMParameter& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CMP_PBMParameter::ASN1T_CMP_PBMParameter (ASN1C_CMP_PBMParameter& original)
{
   original.getCopy (this);
}

ASN1T_CMP_PBMParameter& ASN1C_CMP_PBMParameter::getCopy (ASN1T_CMP_PBMParameter* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_PBMParameter);
      new (pDstData) ASN1T_CMP_PBMParameter;
   }

   asn1Copy_CMP_PBMParameter (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_PBMParameter* ASN1C_CMP_PBMParameter::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_PBMParameter* pDstData = new ASN1T_CMP_PBMParameter;

   asn1Copy_CMP_PBMParameter (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_DHBMParameter (OSCTXT* pctxt, 
   ASN1T_CMP_DHBMParameter* pSrcValue, ASN1T_CMP_DHBMParameter* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   asn1Copy_EXP_AlgorithmIdentifier (pctxt, &pSrcValue->owf, &pDstValue->owf);

   asn1Copy_EXP_AlgorithmIdentifier (pctxt, &pSrcValue->mac, &pDstValue->mac);

}

ASN1C_CMP_DHBMParameter::ASN1C_CMP_DHBMParameter (ASN1C_CMP_DHBMParameter& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CMP_DHBMParameter::ASN1T_CMP_DHBMParameter (ASN1C_CMP_DHBMParameter& original)
{
   original.getCopy (this);
}

ASN1T_CMP_DHBMParameter& ASN1C_CMP_DHBMParameter::getCopy (ASN1T_CMP_DHBMParameter* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_DHBMParameter);
      new (pDstData) ASN1T_CMP_DHBMParameter;
   }

   asn1Copy_CMP_DHBMParameter (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_DHBMParameter* ASN1C_CMP_DHBMParameter::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_DHBMParameter* pDstData = new ASN1T_CMP_DHBMParameter;

   asn1Copy_CMP_DHBMParameter (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

void asn1Copy_CMP_OOBCertHash (OSCTXT* pctxt, 
   ASN1T_CMP_OOBCertHash* pSrcValue, ASN1T_CMP_OOBCertHash* pDstValue)
{
   if (pSrcValue == pDstValue) return;

   OSCRTLMEMCPY (&pDstValue->m, &pSrcValue->m, sizeof (pDstValue->m));
   if (pSrcValue->m.hashAlgPresent) {
      asn1Copy_EXP_AlgorithmIdentifier (pctxt, &pSrcValue->hashAlg, &pDstValue->hashAlg);
   }

   if (pSrcValue->m.certIdPresent) {
      asn1Copy_CRMF_CertId (pctxt, &pSrcValue->certId, &pDstValue->certId);
   }

   rtCopyDynBitStr (pctxt, &pSrcValue->hashVal, &pDstValue->hashVal);

}

ASN1C_CMP_OOBCertHash::ASN1C_CMP_OOBCertHash (ASN1C_CMP_OOBCertHash& original) :
   ASN1CType(original), msgData(original.getCopy())
{
}

ASN1T_CMP_OOBCertHash::ASN1T_CMP_OOBCertHash (ASN1C_CMP_OOBCertHash& original)
{
   original.getCopy (this);
}

ASN1T_CMP_OOBCertHash& ASN1C_CMP_OOBCertHash::getCopy (ASN1T_CMP_OOBCertHash* pDstData)
{
   if (&msgData == pDstData) return *pDstData;

   OSCTXT* pctxt = getCtxtPtr();

   if (pDstData == 0) {
      pDstData = rtxMemAllocType (pctxt, ASN1T_CMP_OOBCertHash);
      new (pDstData) ASN1T_CMP_OOBCertHash;
   }

   asn1Copy_CMP_OOBCertHash (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return *pDstData;
}

ASN1T_CMP_OOBCertHash* ASN1C_CMP_OOBCertHash::newCopy ()
{
   OSCTXT* pctxt = getCtxtPtr();
   ASN1T_CMP_OOBCertHash* pDstData = new ASN1T_CMP_OOBCertHash;

   asn1Copy_CMP_OOBCertHash (pctxt, &msgData, pDstData);

   pDstData->setContext (mpContext);

   return pDstData;
}

