/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.6, Date: 20-Feb-2014.
 */
#include "pkcs5v2.h"
#include "rtxsrc/rtxCommon.h"

EXTERN int asn1D_PKCS5_PBEParameter_salt (OSCTXT* pctxt, 
   ASN1T_PKCS5_PBEParameter_salt* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   pvalue->numocts = 8;
   stat = xd_octstr_s (pctxt, pvalue->data, &pvalue->numocts, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!(pvalue->numocts == 8)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->numocts);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

EXTERN int asn1D_PKCS5_RC2_CBC_Parameter_iv (OSCTXT* pctxt, 
   ASN1T_PKCS5_RC2_CBC_Parameter_iv* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   pvalue->numocts = 8;
   stat = xd_octstr_s (pctxt, pvalue->data, &pvalue->numocts, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!(pvalue->numocts == 8)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->numocts);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

EXTERN int asn1D_PKCS5_RC5_CBC_Parameters_version (OSCTXT* pctxt, 
   ASN1T_PKCS5_RC5_CBC_Parameters_version* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   stat = xd_uint8 (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!(*pvalue == 16)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)*pvalue);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

EXTERN int asn1D_PKCS5_PBKDF2_params_salt (OSCTXT* pctxt, 
   ASN1T_PKCS5_PBKDF2_params_salt* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_UNIV|TM_PRIM|4):
         RTXCTXTPUSHELEMNAME (pctxt, "specified");

         pvalue->u.specified = rtxMemAllocType (pctxt, ASN1TDynOctStr);

         if (pvalue->u.specified == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.specified->numocts = 0;
         pvalue->u.specified->data = 0;
         stat = xd_octstr (pctxt, &pvalue->u.specified->data, &pvalue->u.specified->numocts, ASN1IMPL, length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_CONS|16):
         RTXCTXTPUSHELEMNAME (pctxt, "otherSource");

         pvalue->u.otherSource = rtxMemAllocType (pctxt, 
            ASN1T_EXP_AlgorithmIdentifier);

         if (pvalue->u.otherSource == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_EXP_AlgorithmIdentifier (pvalue->u.otherSource);
         stat = asn1D_EXP_AlgorithmIdentifier (pctxt, pvalue->u.otherSource, 
            ASN1IMPL, length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1D_PKCS5_PBKDF2_params (OSCTXT* pctxt, 
   ASN1T_PKCS5_PBKDF2_params* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "PBKDF2-params");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode salt */
         RTXCTXTPUSHELEMNAME (pctxt, "salt");

         stat = asn1D_PKCS5_PBKDF2_params_salt (pctxt, &pvalue->salt, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode iterationCount */
         RTXCTXTPUSHELEMNAME (pctxt, "iterationCount");

         stat = xd_unsigned (pctxt, &pvalue->iterationCount, ASN1EXPL, length);
         if (stat == 0) {
            if (!(pvalue->iterationCount >= 1)) {
               rtxErrAddElemNameParm (pctxt);
               rtxErrAddUIntParm (pctxt, pvalue->iterationCount);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

         }
         else return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode keyLength */
         if (XD_PEEKTAG (pctxt, 0x2)) {
            RTXCTXTPUSHELEMNAME (pctxt, "keyLength");

            stat = xd_unsigned (pctxt, &pvalue->keyLength, ASN1EXPL, length);
            if (stat == 0) {
               if (!(pvalue->keyLength >= 1)) {
                  rtxErrAddElemNameParm (pctxt);
                  rtxErrAddUIntParm (pctxt, pvalue->keyLength);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

               pvalue->m.keyLengthPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 3:
         /* decode prf */
         if (XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "prf");

            stat = asn1D_EXP_AlgorithmIdentifier (pctxt, &pvalue->prf, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.prfPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|4):
         case (TM_UNIV|TM_CONS|16):
         case (TM_UNIV|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_PKCS5_PBEParameter (OSCTXT* pctxt, 
   ASN1T_PKCS5_PBEParameter* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "PBEParameter");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode salt */
         RTXCTXTPUSHELEMNAME (pctxt, "salt");

         stat = asn1D_PKCS5_PBEParameter_salt (pctxt, &pvalue->salt, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode iterationCount */
         RTXCTXTPUSHELEMNAME (pctxt, "iterationCount");

         stat = xd_integer (pctxt, &pvalue->iterationCount, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|4):
         case (TM_UNIV|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_PKCS5_PBES2_params (OSCTXT* pctxt, 
   ASN1T_PKCS5_PBES2_params* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "PBES2-params");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode keyDerivationFunc */
         RTXCTXTPUSHELEMNAME (pctxt, "keyDerivationFunc");

         stat = asn1D_EXP_AlgorithmIdentifier (pctxt, &pvalue->
            keyDerivationFunc, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode encryptionScheme */
         RTXCTXTPUSHELEMNAME (pctxt, "encryptionScheme");

         stat = asn1D_EXP_AlgorithmIdentifier (pctxt, &pvalue->encryptionScheme
            , ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_PKCS5_PBMAC1_params (OSCTXT* pctxt, 
   ASN1T_PKCS5_PBMAC1_params* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "PBMAC1-params");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode keyDerivationFunc */
         RTXCTXTPUSHELEMNAME (pctxt, "keyDerivationFunc");

         stat = asn1D_EXP_AlgorithmIdentifier (pctxt, &pvalue->
            keyDerivationFunc, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode messageAuthScheme */
         RTXCTXTPUSHELEMNAME (pctxt, "messageAuthScheme");

         stat = asn1D_EXP_AlgorithmIdentifier (pctxt, &pvalue->
            messageAuthScheme, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_PKCS5_RC2_CBC_Parameter (OSCTXT* pctxt, 
   ASN1T_PKCS5_RC2_CBC_Parameter* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "RC2-CBC-Parameter");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode rc2ParameterVersion */
         if (XD_PEEKTAG (pctxt, 0x2)) {
            RTXCTXTPUSHELEMNAME (pctxt, "rc2ParameterVersion");

            stat = xd_integer (pctxt, &pvalue->rc2ParameterVersion, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.rc2ParameterVersionPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 1:
         /* decode iv */
         RTXCTXTPUSHELEMNAME (pctxt, "iv");

         stat = asn1D_PKCS5_RC2_CBC_Parameter_iv (pctxt, &pvalue->iv, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|2):
         case (TM_UNIV|TM_PRIM|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_PKCS5_RC5_CBC_Parameters (OSCTXT* pctxt, 
   ASN1T_PKCS5_RC5_CBC_Parameters* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "RC5-CBC-Parameters");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode version */
         RTXCTXTPUSHELEMNAME (pctxt, "version");

         stat = asn1D_PKCS5_RC5_CBC_Parameters_version (pctxt, &pvalue->version
            , ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode rounds */
         RTXCTXTPUSHELEMNAME (pctxt, "rounds");

         stat = xd_uint8 (pctxt, &pvalue->rounds, ASN1EXPL, length);
         if (stat == 0) {
            if (!((pvalue->rounds >= OSUINTCONST(8) && pvalue->rounds
                <= OSUINTCONST(127)))) {
               rtxErrAddElemNameParm (pctxt);
               rtxErrAddIntParm (pctxt, (int)pvalue->rounds);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

         }
         else return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode blockSizeInBits */
         RTXCTXTPUSHELEMNAME (pctxt, "blockSizeInBits");

         stat = xd_uint8 (pctxt, &pvalue->blockSizeInBits, ASN1EXPL, length);
         if (stat == 0) {
            if (!((pvalue->blockSizeInBits == 64 || pvalue->blockSizeInBits == 128))) {
               rtxErrAddElemNameParm (pctxt);
               rtxErrAddIntParm (pctxt, (int)pvalue->blockSizeInBits);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

         }
         else return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 3:
         /* decode iv */
         if (XD_PEEKTAG (pctxt, 0x4)) {
            RTXCTXTPUSHELEMNAME (pctxt, "iv");

            stat = xd_octstr (pctxt, &pvalue->iv.data, &pvalue->iv.numocts, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.ivPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|2):
         case (TM_UNIV|TM_PRIM|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

