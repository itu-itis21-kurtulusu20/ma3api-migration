/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.6, Date: 20-Feb-2014.
 */
#include <new>
#include "attrcert.h"
#include "rtxsrc/rtxCommon.h"

ASN1OBJID ATTRCERT_id_pe_ac_auditIdentity = {
   9,
   { 1, 3, 6, 1, 5, 5, 7, 1, 4 }
} ;
ASN1OBJID ATTRCERT_id_pe_aaControls = {
   9,
   { 1, 3, 6, 1, 5, 5, 7, 1, 6 }
} ;
ASN1OBJID ATTRCERT_id_pe_ac_proxying = {
   9,
   { 1, 3, 6, 1, 5, 5, 7, 1, 10 }
} ;
ASN1OBJID ATTRCERT_id_ce_targetInformation = {
   4,
   { 2, 5, 29, 55 }
} ;
ASN1OBJID ATTRCERT_id_aca = {
   8,
   { 1, 3, 6, 1, 5, 5, 7, 10 }
} ;
ASN1OBJID ATTRCERT_id_aca_authenticationInfo = {
   9,
   { 1, 3, 6, 1, 5, 5, 7, 10, 1 }
} ;
ASN1OBJID ATTRCERT_id_aca_accessIdentity = {
   9,
   { 1, 3, 6, 1, 5, 5, 7, 10, 2 }
} ;
ASN1OBJID ATTRCERT_id_aca_chargingIdentity = {
   9,
   { 1, 3, 6, 1, 5, 5, 7, 10, 3 }
} ;
ASN1OBJID ATTRCERT_id_aca_group = {
   9,
   { 1, 3, 6, 1, 5, 5, 7, 10, 4 }
} ;
ASN1OBJID ATTRCERT_id_aca_encAttrs = {
   9,
   { 1, 3, 6, 1, 5, 5, 7, 10, 6 }
} ;
ASN1OBJID ATTRCERT_id_at_role = {
   4,
   { 2, 5, 4, 72 }
} ;
ASN1OBJID ATTRCERT_id_at_clearance = {
   5,
   { 2, 5, 1, 5, 55 }
} ;

ASN1T_ATTRCERT_AttCertVersion* 
   new_ASN1T_ATTRCERT_AttCertVersion (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_ATTRCERT_AttCertVersion));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_ATTRCERT_AttCertVersion;
}

ASN1C_ATTRCERT_AttCertVersion::ASN1C_ATTRCERT_AttCertVersion
    (ASN1T_ATTRCERT_AttCertVersion& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT_AttCertVersion::ASN1C_ATTRCERT_AttCertVersion (
   OSRTMessageBufferIF& msgBuf, ASN1T_ATTRCERT_AttCertVersion& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT_AttCertVersion::ASN1C_ATTRCERT_AttCertVersion (
   OSRTContext &context, ASN1T_ATTRCERT_AttCertVersion& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_ATTRCERT_AttCertVersion::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT_AttCertVersion (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT_AttCertVersion::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_ATTRCERT_AttCertVersion (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

ASN1T_ATTRCERT_ClassList* new_ASN1T_ATTRCERT_ClassList (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_ATTRCERT_ClassList));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_ATTRCERT_ClassList;
}

ASN1C_ATTRCERT_ClassList::ASN1C_ATTRCERT_ClassList
    (ASN1T_ATTRCERT_ClassList& data) : ASN1CBitStr (data.data, data.numbits, 8
   ), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT_ClassList::ASN1C_ATTRCERT_ClassList (OSRTMessageBufferIF& msgBuf
   , ASN1T_ATTRCERT_ClassList& data) : ASN1CBitStr (msgBuf, data.data, 
   data.numbits, 8), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT_ClassList::ASN1C_ATTRCERT_ClassList (OSRTContext &context
   , ASN1T_ATTRCERT_ClassList& data) : ASN1CBitStr (context, data.data, 
   data.numbits, 8), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_ATTRCERT_ClassList::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT_ClassList (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT_ClassList::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_ATTRCERT_ClassList (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_ATTRCERT_ClassList (ASN1T_ATTRCERT_ClassList* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_ATTRCERT_ClassList;
}

ASN1T_ATTRCERT_AttCertVersionV1* 
   new_ASN1T_ATTRCERT_AttCertVersionV1 (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_ATTRCERT_AttCertVersionV1));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_ATTRCERT_AttCertVersionV1;
}

ASN1C_ATTRCERT_AttCertVersionV1::ASN1C_ATTRCERT_AttCertVersionV1
    (ASN1T_ATTRCERT_AttCertVersionV1& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT_AttCertVersionV1::ASN1C_ATTRCERT_AttCertVersionV1 (
   OSRTMessageBufferIF& msgBuf, ASN1T_ATTRCERT_AttCertVersionV1& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT_AttCertVersionV1::ASN1C_ATTRCERT_AttCertVersionV1 (
   OSRTContext &context, ASN1T_ATTRCERT_AttCertVersionV1& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_ATTRCERT_AttCertVersionV1::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT_AttCertVersionV1 (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT_AttCertVersionV1::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_ATTRCERT_AttCertVersionV1 (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

static const OSEnumItem ASN1T_ATTRCERT_ObjectDigestInfo_digestedObjectType_ENUMTAB[] = {
   { OSUTF8("otherObjectTypes"), 2, 16, 1 },
   { OSUTF8("publicKey"), 0, 9, 2 },
   { OSUTF8("publicKeyCert"), 1, 13, 0 }
} ;
#define ASN1T_ATTRCERT_ObjectDigestInfo_digestedObjectType_ENUMTABSIZE 3

const OSUTF8CHAR* ASN1T_ATTRCERT_ObjectDigestInfo_digestedObjectType_ToString (OSINT32 value)
{
   OSINT32 idx = value;

   if (idx >= 0 && idx < ASN1T_ATTRCERT_ObjectDigestInfo_digestedObjectType_ENUMTABSIZE) {
      return ASN1T_ATTRCERT_ObjectDigestInfo_digestedObjectType_ENUMTAB
         [ASN1T_ATTRCERT_ObjectDigestInfo_digestedObjectType_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ASN1T_ATTRCERT_ObjectDigestInfo_digestedObjectType_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, 
      ASN1T_ATTRCERT_ObjectDigestInfo_digestedObjectType* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ASN1T_ATTRCERT_ObjectDigestInfo_digestedObjectType_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ASN1T_ATTRCERT_ObjectDigestInfo_digestedObjectType_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ASN1T_ATTRCERT_ObjectDigestInfo_digestedObjectType* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ASN1T_ATTRCERT_ObjectDigestInfo_digestedObjectType_ENUMTAB, 
      ASN1T_ATTRCERT_ObjectDigestInfo_digestedObjectType_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ASN1T_ATTRCERT_ObjectDigestInfo_digestedObjectType)
         ASN1T_ATTRCERT_ObjectDigestInfo_digestedObjectType_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

ASN1T_ATTRCERT_ObjectDigestInfo_digestedObjectType* 
   new_ASN1T_ATTRCERT_ObjectDigestInfo_digestedObjectType (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_ATTRCERT_ObjectDigestInfo_digestedObjectType));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_ATTRCERT_ObjectDigestInfo_digestedObjectType;
}

ASN1C_ATTRCERT_ObjectDigestInfo_digestedObjectType::
   ASN1C_ATTRCERT_ObjectDigestInfo_digestedObjectType
    (ASN1T_ATTRCERT_ObjectDigestInfo_digestedObjectType& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT_ObjectDigestInfo_digestedObjectType::
   ASN1C_ATTRCERT_ObjectDigestInfo_digestedObjectType (
   OSRTMessageBufferIF& msgBuf
   , ASN1T_ATTRCERT_ObjectDigestInfo_digestedObjectType& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT_ObjectDigestInfo_digestedObjectType::
   ASN1C_ATTRCERT_ObjectDigestInfo_digestedObjectType (OSRTContext &context
   , ASN1T_ATTRCERT_ObjectDigestInfo_digestedObjectType& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_ATTRCERT_ObjectDigestInfo_digestedObjectType::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT_ObjectDigestInfo_digestedObjectType (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT_ObjectDigestInfo_digestedObjectType::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_ATTRCERT_ObjectDigestInfo_digestedObjectType (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

ASN1T_ATTRCERT_IssuerSerial* new_ASN1T_ATTRCERT_IssuerSerial (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_ATTRCERT_IssuerSerial));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_ATTRCERT_IssuerSerial;
}

ASN1C_ATTRCERT_IssuerSerial::ASN1C_ATTRCERT_IssuerSerial
    (ASN1T_ATTRCERT_IssuerSerial& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT_IssuerSerial::ASN1C_ATTRCERT_IssuerSerial (
   OSRTMessageBufferIF& msgBuf, ASN1T_ATTRCERT_IssuerSerial& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT_IssuerSerial::ASN1C_ATTRCERT_IssuerSerial (OSRTContext &context
   , ASN1T_ATTRCERT_IssuerSerial& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_ATTRCERT_IssuerSerial::ASN1T_ATTRCERT_IssuerSerial ()
{
   m.issuerUIDPresent = 0;
}

ASN1T_ATTRCERT_IssuerSerial::~ASN1T_ATTRCERT_IssuerSerial ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_ATTRCERT_IssuerSerial (pctxt, this);
   }
}

int ASN1C_ATTRCERT_IssuerSerial::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT_IssuerSerial (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT_IssuerSerial::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_ATTRCERT_IssuerSerial;
   msgData.setContext (msgBuf.getContext());
   return asn1D_ATTRCERT_IssuerSerial (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_ATTRCERT_IssuerSerial (ASN1T_ATTRCERT_IssuerSerial* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_ATTRCERT_IssuerSerial;
}

void asn1Free_ATTRCERT_IssuerSerial (OSCTXT *pctxt, 
   ASN1T_ATTRCERT_IssuerSerial* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_IMP_GeneralNames (pctxt, &pvalue->issuer);
   if (pvalue->m.issuerUIDPresent) {
      asn1Free_EXP_UniqueIdentifier (pctxt, &pvalue->issuerUID);
   }
}

void ASN1C_ATTRCERT_IssuerSerial::MemFree ()
{
   asn1Free_ATTRCERT_IssuerSerial (getCtxtPtr(), &msgData);
}

ASN1T_ATTRCERT_ObjectDigestInfo* 
   new_ASN1T_ATTRCERT_ObjectDigestInfo (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_ATTRCERT_ObjectDigestInfo));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_ATTRCERT_ObjectDigestInfo;
}

ASN1C_ATTRCERT_ObjectDigestInfo::ASN1C_ATTRCERT_ObjectDigestInfo
    (ASN1T_ATTRCERT_ObjectDigestInfo& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT_ObjectDigestInfo::ASN1C_ATTRCERT_ObjectDigestInfo (
   OSRTMessageBufferIF& msgBuf, ASN1T_ATTRCERT_ObjectDigestInfo& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT_ObjectDigestInfo::ASN1C_ATTRCERT_ObjectDigestInfo (
   OSRTContext &context, ASN1T_ATTRCERT_ObjectDigestInfo& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_ATTRCERT_ObjectDigestInfo::ASN1T_ATTRCERT_ObjectDigestInfo ()
{
   m.otherObjectTypeIDPresent = 0;
}

ASN1T_ATTRCERT_ObjectDigestInfo::~ASN1T_ATTRCERT_ObjectDigestInfo ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_ATTRCERT_ObjectDigestInfo (pctxt, this);
   }
}

int ASN1C_ATTRCERT_ObjectDigestInfo::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT_ObjectDigestInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT_ObjectDigestInfo::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_ATTRCERT_ObjectDigestInfo;
   msgData.setContext (msgBuf.getContext());
   return asn1D_ATTRCERT_ObjectDigestInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_ATTRCERT_ObjectDigestInfo (
   ASN1T_ATTRCERT_ObjectDigestInfo* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_ATTRCERT_ObjectDigestInfo;
}

void asn1Free_ATTRCERT_ObjectDigestInfo (OSCTXT *pctxt, 
   ASN1T_ATTRCERT_ObjectDigestInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_EXP_AlgorithmIdentifier (pctxt, &pvalue->digestAlgorithm);
   if (pvalue->objectDigest.numbits > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->objectDigest.data);
      pvalue->objectDigest.numbits = 0;
      pvalue->objectDigest.data = 0;
   }
}

void ASN1C_ATTRCERT_ObjectDigestInfo::MemFree ()
{
   asn1Free_ATTRCERT_ObjectDigestInfo (getCtxtPtr(), &msgData);
}

ASN1T_ATTRCERT_Holder* new_ASN1T_ATTRCERT_Holder (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_ATTRCERT_Holder));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_ATTRCERT_Holder;
}

ASN1C_ATTRCERT_Holder::ASN1C_ATTRCERT_Holder (ASN1T_ATTRCERT_Holder& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT_Holder::ASN1C_ATTRCERT_Holder (OSRTMessageBufferIF& msgBuf
   , ASN1T_ATTRCERT_Holder& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT_Holder::ASN1C_ATTRCERT_Holder (OSRTContext &context
   , ASN1T_ATTRCERT_Holder& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_ATTRCERT_Holder::ASN1T_ATTRCERT_Holder ()
{
   m.baseCertificateIDPresent = 0;
   m.entityNamePresent = 0;
   m.objectDigestInfoPresent = 0;
}

ASN1T_ATTRCERT_Holder::~ASN1T_ATTRCERT_Holder ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_ATTRCERT_Holder (pctxt, this);
   }
}

int ASN1C_ATTRCERT_Holder::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT_Holder (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT_Holder::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_ATTRCERT_Holder;
   msgData.setContext (msgBuf.getContext());
   return asn1D_ATTRCERT_Holder (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_ATTRCERT_Holder (ASN1T_ATTRCERT_Holder* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_ATTRCERT_Holder;
}

void asn1Free_ATTRCERT_Holder (OSCTXT *pctxt, ASN1T_ATTRCERT_Holder* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.baseCertificateIDPresent) {
      asn1Free_ATTRCERT_IssuerSerial (pctxt, &pvalue->baseCertificateID);
   }
   if (pvalue->m.entityNamePresent) {
      asn1Free_IMP_GeneralNames (pctxt, &pvalue->entityName);
   }
   if (pvalue->m.objectDigestInfoPresent) {
      asn1Free_ATTRCERT_ObjectDigestInfo (pctxt, &pvalue->objectDigestInfo);
   }
}

void ASN1C_ATTRCERT_Holder::MemFree ()
{
   asn1Free_ATTRCERT_Holder (getCtxtPtr(), &msgData);
}

ASN1T_ATTRCERT_V2Form* new_ASN1T_ATTRCERT_V2Form (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_ATTRCERT_V2Form));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_ATTRCERT_V2Form;
}

ASN1C_ATTRCERT_V2Form::ASN1C_ATTRCERT_V2Form (ASN1T_ATTRCERT_V2Form& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT_V2Form::ASN1C_ATTRCERT_V2Form (OSRTMessageBufferIF& msgBuf
   , ASN1T_ATTRCERT_V2Form& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT_V2Form::ASN1C_ATTRCERT_V2Form (OSRTContext &context
   , ASN1T_ATTRCERT_V2Form& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_ATTRCERT_V2Form::ASN1T_ATTRCERT_V2Form ()
{
   m.issuerNamePresent = 0;
   m.baseCertificateIDPresent = 0;
   m.objectDigestInfoPresent = 0;
}

ASN1T_ATTRCERT_V2Form::~ASN1T_ATTRCERT_V2Form ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_ATTRCERT_V2Form (pctxt, this);
   }
}

int ASN1C_ATTRCERT_V2Form::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT_V2Form (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT_V2Form::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_ATTRCERT_V2Form;
   msgData.setContext (msgBuf.getContext());
   return asn1D_ATTRCERT_V2Form (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_ATTRCERT_V2Form (ASN1T_ATTRCERT_V2Form* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_ATTRCERT_V2Form;
}

void asn1Free_ATTRCERT_V2Form (OSCTXT *pctxt, ASN1T_ATTRCERT_V2Form* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.issuerNamePresent) {
      asn1Free_IMP_GeneralNames (pctxt, &pvalue->issuerName);
   }
   if (pvalue->m.baseCertificateIDPresent) {
      asn1Free_ATTRCERT_IssuerSerial (pctxt, &pvalue->baseCertificateID);
   }
   if (pvalue->m.objectDigestInfoPresent) {
      asn1Free_ATTRCERT_ObjectDigestInfo (pctxt, &pvalue->objectDigestInfo);
   }
}

void ASN1C_ATTRCERT_V2Form::MemFree ()
{
   asn1Free_ATTRCERT_V2Form (getCtxtPtr(), &msgData);
}

ASN1T_ATTRCERT_AttCertIssuer* 
   new_ASN1T_ATTRCERT_AttCertIssuer (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_ATTRCERT_AttCertIssuer));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_ATTRCERT_AttCertIssuer;
}

ASN1C_ATTRCERT_AttCertIssuer::ASN1C_ATTRCERT_AttCertIssuer
    (ASN1T_ATTRCERT_AttCertIssuer& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT_AttCertIssuer::ASN1C_ATTRCERT_AttCertIssuer (
   OSRTMessageBufferIF& msgBuf, ASN1T_ATTRCERT_AttCertIssuer& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT_AttCertIssuer::ASN1C_ATTRCERT_AttCertIssuer (
   OSRTContext &context, ASN1T_ATTRCERT_AttCertIssuer& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_ATTRCERT_AttCertIssuer::~ASN1T_ATTRCERT_AttCertIssuer ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_ATTRCERT_AttCertIssuer (pctxt, this);
   }
}

int ASN1C_ATTRCERT_AttCertIssuer::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT_AttCertIssuer (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT_AttCertIssuer::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_ATTRCERT_AttCertIssuer;
   msgData.setContext (msgBuf.getContext());
   return asn1D_ATTRCERT_AttCertIssuer (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_ATTRCERT_AttCertIssuer (ASN1T_ATTRCERT_AttCertIssuer* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_ATTRCERT_AttCertIssuer;
}

void asn1Free_ATTRCERT_AttCertIssuer (OSCTXT *pctxt, 
   ASN1T_ATTRCERT_AttCertIssuer* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.v1Form) {
            asn1Free_IMP_GeneralNames (pctxt, pvalue->u.v1Form);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.v1Form);
         }
         break;

      case 2:
         if (0 != pvalue->u.v2Form) {
            asn1Free_ATTRCERT_V2Form (pctxt, pvalue->u.v2Form);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.v2Form);
         }
         break;

   }
}

void ASN1C_ATTRCERT_AttCertIssuer::MemFree ()
{
   asn1Free_ATTRCERT_AttCertIssuer (getCtxtPtr(), &msgData);
}

ASN1T_ATTRCERT_AttCertValidityPeriod* 
   new_ASN1T_ATTRCERT_AttCertValidityPeriod (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_ATTRCERT_AttCertValidityPeriod));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_ATTRCERT_AttCertValidityPeriod;
}

ASN1C_ATTRCERT_AttCertValidityPeriod::ASN1C_ATTRCERT_AttCertValidityPeriod
    (ASN1T_ATTRCERT_AttCertValidityPeriod& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT_AttCertValidityPeriod::ASN1C_ATTRCERT_AttCertValidityPeriod (
   OSRTMessageBufferIF& msgBuf, ASN1T_ATTRCERT_AttCertValidityPeriod& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT_AttCertValidityPeriod::ASN1C_ATTRCERT_AttCertValidityPeriod (
   OSRTContext &context, ASN1T_ATTRCERT_AttCertValidityPeriod& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_ATTRCERT_AttCertValidityPeriod::ASN1T_ATTRCERT_AttCertValidityPeriod ()
{
   notBeforeTime = 0;
   notAfterTime = 0;
}

ASN1T_ATTRCERT_AttCertValidityPeriod::~ASN1T_ATTRCERT_AttCertValidityPeriod ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_ATTRCERT_AttCertValidityPeriod (pctxt, this);
   }
}

int ASN1C_ATTRCERT_AttCertValidityPeriod::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT_AttCertValidityPeriod (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT_AttCertValidityPeriod::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_ATTRCERT_AttCertValidityPeriod;
   msgData.setContext (msgBuf.getContext());
   return asn1D_ATTRCERT_AttCertValidityPeriod (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_ATTRCERT_AttCertValidityPeriod (
   ASN1T_ATTRCERT_AttCertValidityPeriod* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_ATTRCERT_AttCertValidityPeriod;
}

void asn1Free_ATTRCERT_AttCertValidityPeriod (OSCTXT *pctxt, 
   ASN1T_ATTRCERT_AttCertValidityPeriod* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreePtr (pctxt, (void*)pvalue->notBeforeTime);
   rtxMemFreePtr (pctxt, (void*)pvalue->notAfterTime);
}

void ASN1C_ATTRCERT_AttCertValidityPeriod::MemFree ()
{
   asn1Free_ATTRCERT_AttCertValidityPeriod (getCtxtPtr(), &msgData);
}

ASN1C_ATTRCERT__SeqOfATTRCERT_Attribute::
   ASN1C_ATTRCERT__SeqOfATTRCERT_Attribute
    (ASN1T_ATTRCERT__SeqOfATTRCERT_Attribute& data) : ASN1CSeqOfList(data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT__SeqOfATTRCERT_Attribute::
   ASN1C_ATTRCERT__SeqOfATTRCERT_Attribute (OSRTMessageBufferIF& msgBuf
   , ASN1T_ATTRCERT__SeqOfATTRCERT_Attribute& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT__SeqOfATTRCERT_Attribute::
   ASN1C_ATTRCERT__SeqOfATTRCERT_Attribute (OSRTContext &context
   , ASN1T_ATTRCERT__SeqOfATTRCERT_Attribute& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_ATTRCERT__SeqOfATTRCERT_Attribute::
   ASN1C_ATTRCERT__SeqOfATTRCERT_Attribute (ASN1CType& ccobj
   , ASN1T_ATTRCERT__SeqOfATTRCERT_Attribute& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_ATTRCERT__SeqOfATTRCERT_Attribute::Append (ASN1T_EXP_Attribute* elem)
{
   append ((void*)elem);
}

ASN1T_EXP_Attribute* ASN1C_ATTRCERT__SeqOfATTRCERT_Attribute::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_EXP_Attribute));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_EXP_Attribute;
}

ASN1T_EXP_Attribute* ASN1C_ATTRCERT__SeqOfATTRCERT_Attribute::AppendNewElement ()
{
   ASN1T_EXP_Attribute* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_ATTRCERT__SeqOfATTRCERT_Attribute::~ASN1T_ATTRCERT__SeqOfATTRCERT_Attribute ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_ATTRCERT__SeqOfATTRCERT_Attribute (pctxt, this);
   }
}

int ASN1C_ATTRCERT__SeqOfATTRCERT_Attribute::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT__SeqOfATTRCERT_Attribute (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT__SeqOfATTRCERT_Attribute::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_ATTRCERT__SeqOfATTRCERT_Attribute;
   msgData.setContext (msgBuf.getContext());
   return asn1D_ATTRCERT__SeqOfATTRCERT_Attribute (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_ATTRCERT__SeqOfATTRCERT_Attribute (
   ASN1T_ATTRCERT__SeqOfATTRCERT_Attribute* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_ATTRCERT__SeqOfATTRCERT_Attribute;
   rtxDListFastInit (pvalue);
}

void asn1Free_ATTRCERT__SeqOfATTRCERT_Attribute (OSCTXT *pctxt, 
   ASN1T_ATTRCERT__SeqOfATTRCERT_Attribute* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_EXP_Attribute* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_EXP_Attribute*)pnode->data;
      asn1Free_EXP_Attribute (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_ATTRCERT__SeqOfATTRCERT_Attribute::MemFree ()
{
   asn1Free_ATTRCERT__SeqOfATTRCERT_Attribute (getCtxtPtr(), &msgData);
}

ASN1T_ATTRCERT_AttributeCertificateInfo* 
   new_ASN1T_ATTRCERT_AttributeCertificateInfo (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_ATTRCERT_AttributeCertificateInfo));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_ATTRCERT_AttributeCertificateInfo;
}

ASN1C_ATTRCERT_AttributeCertificateInfo::
   ASN1C_ATTRCERT_AttributeCertificateInfo
    (ASN1T_ATTRCERT_AttributeCertificateInfo& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT_AttributeCertificateInfo::
   ASN1C_ATTRCERT_AttributeCertificateInfo (OSRTMessageBufferIF& msgBuf
   , ASN1T_ATTRCERT_AttributeCertificateInfo& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT_AttributeCertificateInfo::
   ASN1C_ATTRCERT_AttributeCertificateInfo (OSRTContext &context
   , ASN1T_ATTRCERT_AttributeCertificateInfo& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_ATTRCERT_AttributeCertificateInfo::ASN1T_ATTRCERT_AttributeCertificateInfo ()
{
   m.issuerUniqueIDPresent = 0;
   m.extensionsPresent = 0;
}

ASN1T_ATTRCERT_AttributeCertificateInfo::~ASN1T_ATTRCERT_AttributeCertificateInfo ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_ATTRCERT_AttributeCertificateInfo (pctxt, this);
   }
}

int ASN1C_ATTRCERT_AttributeCertificateInfo::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT_AttributeCertificateInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT_AttributeCertificateInfo::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_ATTRCERT_AttributeCertificateInfo;
   msgData.setContext (msgBuf.getContext());
   return asn1D_ATTRCERT_AttributeCertificateInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_ATTRCERT_AttributeCertificateInfo (
   ASN1T_ATTRCERT_AttributeCertificateInfo* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_ATTRCERT_AttributeCertificateInfo;
}

void asn1Free_ATTRCERT_AttributeCertificateInfo (OSCTXT *pctxt, 
   ASN1T_ATTRCERT_AttributeCertificateInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ATTRCERT_Holder (pctxt, &pvalue->holder);
   asn1Free_ATTRCERT_AttCertIssuer (pctxt, &pvalue->issuer);
   asn1Free_EXP_AlgorithmIdentifier (pctxt, &pvalue->signature_);
   asn1Free_ATTRCERT_AttCertValidityPeriod (pctxt, &pvalue->attrCertValidityPeriod);
   asn1Free_ATTRCERT__SeqOfATTRCERT_Attribute (pctxt, &pvalue->attributes);
   if (pvalue->m.issuerUniqueIDPresent) {
      asn1Free_EXP_UniqueIdentifier (pctxt, &pvalue->issuerUniqueID);
   }
   if (pvalue->m.extensionsPresent) {
      asn1Free_EXP_Extensions (pctxt, &pvalue->extensions);
   }
}

void ASN1C_ATTRCERT_AttributeCertificateInfo::MemFree ()
{
   asn1Free_ATTRCERT_AttributeCertificateInfo (getCtxtPtr(), &msgData);
}

ASN1T_ATTRCERT_AttributeCertificate* 
   new_ASN1T_ATTRCERT_AttributeCertificate (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_ATTRCERT_AttributeCertificate));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_ATTRCERT_AttributeCertificate;
}

ASN1C_ATTRCERT_AttributeCertificate::ASN1C_ATTRCERT_AttributeCertificate
    (ASN1T_ATTRCERT_AttributeCertificate& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT_AttributeCertificate::ASN1C_ATTRCERT_AttributeCertificate (
   OSRTMessageBufferIF& msgBuf, ASN1T_ATTRCERT_AttributeCertificate& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT_AttributeCertificate::ASN1C_ATTRCERT_AttributeCertificate (
   OSRTContext &context, ASN1T_ATTRCERT_AttributeCertificate& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_ATTRCERT_AttributeCertificate::ASN1T_ATTRCERT_AttributeCertificate ()
{
}

ASN1T_ATTRCERT_AttributeCertificate::~ASN1T_ATTRCERT_AttributeCertificate ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_ATTRCERT_AttributeCertificate (pctxt, this);
   }
}

int ASN1C_ATTRCERT_AttributeCertificate::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT_AttributeCertificate (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT_AttributeCertificate::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_ATTRCERT_AttributeCertificate;
   msgData.setContext (msgBuf.getContext());
   return asn1D_ATTRCERT_AttributeCertificate (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_ATTRCERT_AttributeCertificate (
   ASN1T_ATTRCERT_AttributeCertificate* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_ATTRCERT_AttributeCertificate;
}

void asn1Free_ATTRCERT_AttributeCertificate (OSCTXT *pctxt, 
   ASN1T_ATTRCERT_AttributeCertificate* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ATTRCERT_AttributeCertificateInfo (pctxt, &pvalue->acinfo);
   asn1Free_EXP_AlgorithmIdentifier (pctxt, &pvalue->signatureAlgorithm);
   if (pvalue->signatureValue.numbits > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->signatureValue.data);
      pvalue->signatureValue.numbits = 0;
      pvalue->signatureValue.data = 0;
   }
}

void ASN1C_ATTRCERT_AttributeCertificate::MemFree ()
{
   asn1Free_ATTRCERT_AttributeCertificate (getCtxtPtr(), &msgData);
}

ASN1T_ATTRCERT_TargetCert* new_ASN1T_ATTRCERT_TargetCert (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_ATTRCERT_TargetCert));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_ATTRCERT_TargetCert;
}

ASN1C_ATTRCERT_TargetCert::ASN1C_ATTRCERT_TargetCert
    (ASN1T_ATTRCERT_TargetCert& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT_TargetCert::ASN1C_ATTRCERT_TargetCert (
   OSRTMessageBufferIF& msgBuf, ASN1T_ATTRCERT_TargetCert& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT_TargetCert::ASN1C_ATTRCERT_TargetCert (OSRTContext &context
   , ASN1T_ATTRCERT_TargetCert& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_ATTRCERT_TargetCert::ASN1T_ATTRCERT_TargetCert ()
{
   m.targetNamePresent = 0;
   m.certDigestInfoPresent = 0;
}

ASN1T_ATTRCERT_TargetCert::~ASN1T_ATTRCERT_TargetCert ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_ATTRCERT_TargetCert (pctxt, this);
   }
}

int ASN1C_ATTRCERT_TargetCert::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT_TargetCert (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT_TargetCert::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_ATTRCERT_TargetCert;
   msgData.setContext (msgBuf.getContext());
   return asn1D_ATTRCERT_TargetCert (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_ATTRCERT_TargetCert (ASN1T_ATTRCERT_TargetCert* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_ATTRCERT_TargetCert;
}

void asn1Free_ATTRCERT_TargetCert (OSCTXT *pctxt, 
   ASN1T_ATTRCERT_TargetCert* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ATTRCERT_IssuerSerial (pctxt, &pvalue->targetCertificate);
   if (pvalue->m.targetNamePresent) {
      asn1Free_IMP_GeneralName (pctxt, &pvalue->targetName);
   }
   if (pvalue->m.certDigestInfoPresent) {
      asn1Free_ATTRCERT_ObjectDigestInfo (pctxt, &pvalue->certDigestInfo);
   }
}

void ASN1C_ATTRCERT_TargetCert::MemFree ()
{
   asn1Free_ATTRCERT_TargetCert (getCtxtPtr(), &msgData);
}

ASN1T_ATTRCERT_Target* new_ASN1T_ATTRCERT_Target (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_ATTRCERT_Target));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_ATTRCERT_Target;
}

ASN1C_ATTRCERT_Target::ASN1C_ATTRCERT_Target (ASN1T_ATTRCERT_Target& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT_Target::ASN1C_ATTRCERT_Target (OSRTMessageBufferIF& msgBuf
   , ASN1T_ATTRCERT_Target& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT_Target::ASN1C_ATTRCERT_Target (OSRTContext &context
   , ASN1T_ATTRCERT_Target& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_ATTRCERT_Target::~ASN1T_ATTRCERT_Target ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_ATTRCERT_Target (pctxt, this);
   }
}

int ASN1C_ATTRCERT_Target::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT_Target (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT_Target::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_ATTRCERT_Target;
   msgData.setContext (msgBuf.getContext());
   return asn1D_ATTRCERT_Target (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_ATTRCERT_Target (ASN1T_ATTRCERT_Target* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_ATTRCERT_Target;
}

void asn1Free_ATTRCERT_Target (OSCTXT *pctxt, ASN1T_ATTRCERT_Target* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.targetName) {
            asn1Free_IMP_GeneralName (pctxt, pvalue->u.targetName);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.targetName);
         }
         break;

      case 2:
         if (0 != pvalue->u.targetGroup) {
            asn1Free_IMP_GeneralName (pctxt, pvalue->u.targetGroup);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.targetGroup);
         }
         break;

      case 3:
         if (0 != pvalue->u.targetCert) {
            asn1Free_ATTRCERT_TargetCert (pctxt, pvalue->u.targetCert);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.targetCert);
         }
         break;

   }
}

void ASN1C_ATTRCERT_Target::MemFree ()
{
   asn1Free_ATTRCERT_Target (getCtxtPtr(), &msgData);
}

ASN1C_ATTRCERT_Targets::ASN1C_ATTRCERT_Targets (ASN1T_ATTRCERT_Targets& data)
    : ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT_Targets::ASN1C_ATTRCERT_Targets (OSRTMessageBufferIF& msgBuf
   , ASN1T_ATTRCERT_Targets& data) : ASN1CSeqOfList(msgBuf, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT_Targets::ASN1C_ATTRCERT_Targets (OSRTContext &context
   , ASN1T_ATTRCERT_Targets& data) : ASN1CSeqOfList(context, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_ATTRCERT_Targets::ASN1C_ATTRCERT_Targets (ASN1CType& ccobj
   , ASN1T_ATTRCERT_Targets& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_ATTRCERT_Targets::Append (ASN1T_ATTRCERT_Target* elem)
{
   append ((void*)elem);
}

ASN1T_ATTRCERT_Target* ASN1C_ATTRCERT_Targets::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_ATTRCERT_Target));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_ATTRCERT_Target;
}

ASN1T_ATTRCERT_Target* ASN1C_ATTRCERT_Targets::AppendNewElement ()
{
   ASN1T_ATTRCERT_Target* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_ATTRCERT_Targets::~ASN1T_ATTRCERT_Targets ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_ATTRCERT_Targets (pctxt, this);
   }
}

int ASN1C_ATTRCERT_Targets::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT_Targets (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT_Targets::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_ATTRCERT_Targets;
   msgData.setContext (msgBuf.getContext());
   return asn1D_ATTRCERT_Targets (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_ATTRCERT_Targets (ASN1T_ATTRCERT_Targets* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_ATTRCERT_Targets;
   rtxDListFastInit (pvalue);
}

void asn1Free_ATTRCERT_Targets (OSCTXT *pctxt, ASN1T_ATTRCERT_Targets* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_ATTRCERT_Target* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_ATTRCERT_Target*)pnode->data;
      asn1Free_ATTRCERT_Target (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_ATTRCERT_Targets::MemFree ()
{
   asn1Free_ATTRCERT_Targets (getCtxtPtr(), &msgData);
}

ASN1T_ATTRCERT_IetfAttrSyntax_values_element* 
   new_ASN1T_ATTRCERT_IetfAttrSyntax_values_element (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_ATTRCERT_IetfAttrSyntax_values_element));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_ATTRCERT_IetfAttrSyntax_values_element;
}

ASN1C_ATTRCERT_IetfAttrSyntax_values_element::
   ASN1C_ATTRCERT_IetfAttrSyntax_values_element
    (ASN1T_ATTRCERT_IetfAttrSyntax_values_element& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT_IetfAttrSyntax_values_element::
   ASN1C_ATTRCERT_IetfAttrSyntax_values_element (OSRTMessageBufferIF& msgBuf
   , ASN1T_ATTRCERT_IetfAttrSyntax_values_element& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT_IetfAttrSyntax_values_element::
   ASN1C_ATTRCERT_IetfAttrSyntax_values_element (OSRTContext &context
   , ASN1T_ATTRCERT_IetfAttrSyntax_values_element& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_ATTRCERT_IetfAttrSyntax_values_element::~ASN1T_ATTRCERT_IetfAttrSyntax_values_element ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_ATTRCERT_IetfAttrSyntax_values_element (pctxt, this);
   }
}

int ASN1C_ATTRCERT_IetfAttrSyntax_values_element::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT_IetfAttrSyntax_values_element (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT_IetfAttrSyntax_values_element::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_ATTRCERT_IetfAttrSyntax_values_element;
   msgData.setContext (msgBuf.getContext());
   return asn1D_ATTRCERT_IetfAttrSyntax_values_element (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_ATTRCERT_IetfAttrSyntax_values_element (
   ASN1T_ATTRCERT_IetfAttrSyntax_values_element* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_ATTRCERT_IetfAttrSyntax_values_element;
}

void asn1Free_ATTRCERT_IetfAttrSyntax_values_element (OSCTXT *pctxt, 
   ASN1T_ATTRCERT_IetfAttrSyntax_values_element* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.octets) {
            if (pvalue->u.octets->numocts > 0) {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.octets->data);
               pvalue->u.octets->numocts = 0;
               pvalue->u.octets->data = 0;
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.octets);
         }
         break;

      case 2:
         if (0 != pvalue->u.oid) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.oid);
         }
         break;

      case 3:
         if (0 != &pvalue->u.string) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.string);
         }
         break;

   }
}

void ASN1C_ATTRCERT_IetfAttrSyntax_values_element::MemFree ()
{
   asn1Free_ATTRCERT_IetfAttrSyntax_values_element (getCtxtPtr(), &msgData);
}

ASN1C_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element::
   ASN1C_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element
    (ASN1T_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element& data) : 
   ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element::
   ASN1C_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element (
   OSRTMessageBufferIF& msgBuf
   , ASN1T_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element::
   ASN1C_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element (
   OSRTContext &context
   , ASN1T_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element::
   ASN1C_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element (ASN1CType& ccobj
   , ASN1T_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element::Append (ASN1T_ATTRCERT_IetfAttrSyntax_values_element* elem)
{
   append ((void*)elem);
}

ASN1T_ATTRCERT_IetfAttrSyntax_values_element* ASN1C_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_ATTRCERT_IetfAttrSyntax_values_element));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_ATTRCERT_IetfAttrSyntax_values_element;
}

ASN1T_ATTRCERT_IetfAttrSyntax_values_element* ASN1C_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element::AppendNewElement ()
{
   ASN1T_ATTRCERT_IetfAttrSyntax_values_element* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element::~ASN1T_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element (pctxt, this);
   }
}

int ASN1C_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element;
   msgData.setContext (msgBuf.getContext());
   return asn1D_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element (
   ASN1T_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element;
   rtxDListFastInit (pvalue);
}

void asn1Free_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element (OSCTXT *pctxt, 
   ASN1T_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_ATTRCERT_IetfAttrSyntax_values_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_ATTRCERT_IetfAttrSyntax_values_element*)pnode->data;
      asn1Free_ATTRCERT_IetfAttrSyntax_values_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element::MemFree ()
{
   asn1Free_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element (getCtxtPtr(), &msgData);
}

ASN1T_ATTRCERT_IetfAttrSyntax* 
   new_ASN1T_ATTRCERT_IetfAttrSyntax (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_ATTRCERT_IetfAttrSyntax));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_ATTRCERT_IetfAttrSyntax;
}

ASN1C_ATTRCERT_IetfAttrSyntax::ASN1C_ATTRCERT_IetfAttrSyntax
    (ASN1T_ATTRCERT_IetfAttrSyntax& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT_IetfAttrSyntax::ASN1C_ATTRCERT_IetfAttrSyntax (
   OSRTMessageBufferIF& msgBuf, ASN1T_ATTRCERT_IetfAttrSyntax& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT_IetfAttrSyntax::ASN1C_ATTRCERT_IetfAttrSyntax (
   OSRTContext &context, ASN1T_ATTRCERT_IetfAttrSyntax& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_ATTRCERT_IetfAttrSyntax::ASN1T_ATTRCERT_IetfAttrSyntax ()
{
   m.policyAuthorityPresent = 0;
}

ASN1T_ATTRCERT_IetfAttrSyntax::~ASN1T_ATTRCERT_IetfAttrSyntax ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_ATTRCERT_IetfAttrSyntax (pctxt, this);
   }
}

int ASN1C_ATTRCERT_IetfAttrSyntax::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT_IetfAttrSyntax (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT_IetfAttrSyntax::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_ATTRCERT_IetfAttrSyntax;
   msgData.setContext (msgBuf.getContext());
   return asn1D_ATTRCERT_IetfAttrSyntax (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_ATTRCERT_IetfAttrSyntax (ASN1T_ATTRCERT_IetfAttrSyntax* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_ATTRCERT_IetfAttrSyntax;
}

void asn1Free_ATTRCERT_IetfAttrSyntax (OSCTXT *pctxt, 
   ASN1T_ATTRCERT_IetfAttrSyntax* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.policyAuthorityPresent) {
      asn1Free_IMP_GeneralNames (pctxt, &pvalue->policyAuthority);
   }
   asn1Free_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element (pctxt, &pvalue->values);
}

void ASN1C_ATTRCERT_IetfAttrSyntax::MemFree ()
{
   asn1Free_ATTRCERT_IetfAttrSyntax (getCtxtPtr(), &msgData);
}

ASN1T_ATTRCERT_SvceAuthInfo* new_ASN1T_ATTRCERT_SvceAuthInfo (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_ATTRCERT_SvceAuthInfo));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_ATTRCERT_SvceAuthInfo;
}

ASN1C_ATTRCERT_SvceAuthInfo::ASN1C_ATTRCERT_SvceAuthInfo
    (ASN1T_ATTRCERT_SvceAuthInfo& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT_SvceAuthInfo::ASN1C_ATTRCERT_SvceAuthInfo (
   OSRTMessageBufferIF& msgBuf, ASN1T_ATTRCERT_SvceAuthInfo& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT_SvceAuthInfo::ASN1C_ATTRCERT_SvceAuthInfo (OSRTContext &context
   , ASN1T_ATTRCERT_SvceAuthInfo& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_ATTRCERT_SvceAuthInfo::ASN1T_ATTRCERT_SvceAuthInfo ()
{
   m.authInfoPresent = 0;
}

ASN1T_ATTRCERT_SvceAuthInfo::~ASN1T_ATTRCERT_SvceAuthInfo ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_ATTRCERT_SvceAuthInfo (pctxt, this);
   }
}

int ASN1C_ATTRCERT_SvceAuthInfo::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT_SvceAuthInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT_SvceAuthInfo::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_ATTRCERT_SvceAuthInfo;
   msgData.setContext (msgBuf.getContext());
   return asn1D_ATTRCERT_SvceAuthInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_ATTRCERT_SvceAuthInfo (ASN1T_ATTRCERT_SvceAuthInfo* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_ATTRCERT_SvceAuthInfo;
}

void asn1Free_ATTRCERT_SvceAuthInfo (OSCTXT *pctxt, 
   ASN1T_ATTRCERT_SvceAuthInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_IMP_GeneralName (pctxt, &pvalue->service);
   asn1Free_IMP_GeneralName (pctxt, &pvalue->ident);
   if (pvalue->m.authInfoPresent) {
      if (pvalue->authInfo.numocts > 0) {
         rtxMemFreePtr (pctxt, (void*)pvalue->authInfo.data);
         pvalue->authInfo.numocts = 0;
         pvalue->authInfo.data = 0;
      }
   }
}

void ASN1C_ATTRCERT_SvceAuthInfo::MemFree ()
{
   asn1Free_ATTRCERT_SvceAuthInfo (getCtxtPtr(), &msgData);
}

ASN1T_ATTRCERT_RoleSyntax* new_ASN1T_ATTRCERT_RoleSyntax (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_ATTRCERT_RoleSyntax));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_ATTRCERT_RoleSyntax;
}

ASN1C_ATTRCERT_RoleSyntax::ASN1C_ATTRCERT_RoleSyntax
    (ASN1T_ATTRCERT_RoleSyntax& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT_RoleSyntax::ASN1C_ATTRCERT_RoleSyntax (
   OSRTMessageBufferIF& msgBuf, ASN1T_ATTRCERT_RoleSyntax& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT_RoleSyntax::ASN1C_ATTRCERT_RoleSyntax (OSRTContext &context
   , ASN1T_ATTRCERT_RoleSyntax& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_ATTRCERT_RoleSyntax::ASN1T_ATTRCERT_RoleSyntax ()
{
   m.roleAuthorityPresent = 0;
}

ASN1T_ATTRCERT_RoleSyntax::~ASN1T_ATTRCERT_RoleSyntax ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_ATTRCERT_RoleSyntax (pctxt, this);
   }
}

int ASN1C_ATTRCERT_RoleSyntax::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT_RoleSyntax (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT_RoleSyntax::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_ATTRCERT_RoleSyntax;
   msgData.setContext (msgBuf.getContext());
   return asn1D_ATTRCERT_RoleSyntax (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_ATTRCERT_RoleSyntax (ASN1T_ATTRCERT_RoleSyntax* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_ATTRCERT_RoleSyntax;
}

void asn1Free_ATTRCERT_RoleSyntax (OSCTXT *pctxt, 
   ASN1T_ATTRCERT_RoleSyntax* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.roleAuthorityPresent) {
      asn1Free_IMP_GeneralNames (pctxt, &pvalue->roleAuthority);
   }
   asn1Free_IMP_GeneralName (pctxt, &pvalue->roleName);
}

void ASN1C_ATTRCERT_RoleSyntax::MemFree ()
{
   asn1Free_ATTRCERT_RoleSyntax (getCtxtPtr(), &msgData);
}

ASN1T_ATTRCERT_SecurityCategory* 
   new_ASN1T_ATTRCERT_SecurityCategory (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_ATTRCERT_SecurityCategory));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_ATTRCERT_SecurityCategory;
}

ASN1C_ATTRCERT_SecurityCategory::ASN1C_ATTRCERT_SecurityCategory
    (ASN1T_ATTRCERT_SecurityCategory& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT_SecurityCategory::ASN1C_ATTRCERT_SecurityCategory (
   OSRTMessageBufferIF& msgBuf, ASN1T_ATTRCERT_SecurityCategory& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT_SecurityCategory::ASN1C_ATTRCERT_SecurityCategory (
   OSRTContext &context, ASN1T_ATTRCERT_SecurityCategory& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_ATTRCERT_SecurityCategory::ASN1T_ATTRCERT_SecurityCategory ()
{
}

ASN1T_ATTRCERT_SecurityCategory::~ASN1T_ATTRCERT_SecurityCategory ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_ATTRCERT_SecurityCategory (pctxt, this);
   }
}

int ASN1C_ATTRCERT_SecurityCategory::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT_SecurityCategory (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT_SecurityCategory::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_ATTRCERT_SecurityCategory;
   msgData.setContext (msgBuf.getContext());
   return asn1D_ATTRCERT_SecurityCategory (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_ATTRCERT_SecurityCategory (
   ASN1T_ATTRCERT_SecurityCategory* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_ATTRCERT_SecurityCategory;
}

void asn1Free_ATTRCERT_SecurityCategory (OSCTXT *pctxt, 
   ASN1T_ATTRCERT_SecurityCategory* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreePtr (pctxt, (void*)pvalue->value.data);
}

void ASN1C_ATTRCERT_SecurityCategory::MemFree ()
{
   asn1Free_ATTRCERT_SecurityCategory (getCtxtPtr(), &msgData);
}

ASN1C_ATTRCERT__SetOfATTRCERT_SecurityCategory::
   ASN1C_ATTRCERT__SetOfATTRCERT_SecurityCategory
    (ASN1T_ATTRCERT__SetOfATTRCERT_SecurityCategory& data) : 
   ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT__SetOfATTRCERT_SecurityCategory::
   ASN1C_ATTRCERT__SetOfATTRCERT_SecurityCategory (OSRTMessageBufferIF& msgBuf
   , ASN1T_ATTRCERT__SetOfATTRCERT_SecurityCategory& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT__SetOfATTRCERT_SecurityCategory::
   ASN1C_ATTRCERT__SetOfATTRCERT_SecurityCategory (OSRTContext &context
   , ASN1T_ATTRCERT__SetOfATTRCERT_SecurityCategory& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_ATTRCERT__SetOfATTRCERT_SecurityCategory::
   ASN1C_ATTRCERT__SetOfATTRCERT_SecurityCategory (ASN1CType& ccobj
   , ASN1T_ATTRCERT__SetOfATTRCERT_SecurityCategory& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_ATTRCERT__SetOfATTRCERT_SecurityCategory::Append (ASN1T_ATTRCERT_SecurityCategory* elem)
{
   append ((void*)elem);
}

ASN1T_ATTRCERT_SecurityCategory* ASN1C_ATTRCERT__SetOfATTRCERT_SecurityCategory::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_ATTRCERT_SecurityCategory));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_ATTRCERT_SecurityCategory;
}

ASN1T_ATTRCERT_SecurityCategory* ASN1C_ATTRCERT__SetOfATTRCERT_SecurityCategory::AppendNewElement ()
{
   ASN1T_ATTRCERT_SecurityCategory* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_ATTRCERT__SetOfATTRCERT_SecurityCategory::~ASN1T_ATTRCERT__SetOfATTRCERT_SecurityCategory ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_ATTRCERT__SetOfATTRCERT_SecurityCategory (pctxt, this);
   }
}

int ASN1C_ATTRCERT__SetOfATTRCERT_SecurityCategory::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT__SetOfATTRCERT_SecurityCategory (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT__SetOfATTRCERT_SecurityCategory::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_ATTRCERT__SetOfATTRCERT_SecurityCategory;
   msgData.setContext (msgBuf.getContext());
   return asn1D_ATTRCERT__SetOfATTRCERT_SecurityCategory (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_ATTRCERT__SetOfATTRCERT_SecurityCategory (
   ASN1T_ATTRCERT__SetOfATTRCERT_SecurityCategory* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_ATTRCERT__SetOfATTRCERT_SecurityCategory;
   rtxDListFastInit (pvalue);
}

void asn1Free_ATTRCERT__SetOfATTRCERT_SecurityCategory (OSCTXT *pctxt, 
   ASN1T_ATTRCERT__SetOfATTRCERT_SecurityCategory* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_ATTRCERT_SecurityCategory* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_ATTRCERT_SecurityCategory*)pnode->data;
      asn1Free_ATTRCERT_SecurityCategory (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_ATTRCERT__SetOfATTRCERT_SecurityCategory::MemFree ()
{
   asn1Free_ATTRCERT__SetOfATTRCERT_SecurityCategory (getCtxtPtr(), &msgData);
}

ASN1T_ATTRCERT_Clearance* new_ASN1T_ATTRCERT_Clearance (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_ATTRCERT_Clearance));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_ATTRCERT_Clearance;
}

ASN1C_ATTRCERT_Clearance::ASN1C_ATTRCERT_Clearance
    (ASN1T_ATTRCERT_Clearance& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT_Clearance::ASN1C_ATTRCERT_Clearance (OSRTMessageBufferIF& msgBuf
   , ASN1T_ATTRCERT_Clearance& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT_Clearance::ASN1C_ATTRCERT_Clearance (OSRTContext &context
   , ASN1T_ATTRCERT_Clearance& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_ATTRCERT_Clearance::ASN1T_ATTRCERT_Clearance ()
{
   m.classListPresent = 0;
   m.securityCategoriesPresent = 0;
}

ASN1T_ATTRCERT_Clearance::~ASN1T_ATTRCERT_Clearance ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_ATTRCERT_Clearance (pctxt, this);
   }
}

int ASN1C_ATTRCERT_Clearance::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT_Clearance (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT_Clearance::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_ATTRCERT_Clearance;
   msgData.setContext (msgBuf.getContext());
   return asn1D_ATTRCERT_Clearance (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_ATTRCERT_Clearance (ASN1T_ATTRCERT_Clearance* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_ATTRCERT_Clearance;
}

void asn1Free_ATTRCERT_Clearance (OSCTXT *pctxt, 
   ASN1T_ATTRCERT_Clearance* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.securityCategoriesPresent) {
      asn1Free_ATTRCERT__SetOfATTRCERT_SecurityCategory (pctxt, &pvalue->securityCategories);
   }
}

void ASN1C_ATTRCERT_Clearance::MemFree ()
{
   asn1Free_ATTRCERT_Clearance (getCtxtPtr(), &msgData);
}

ASN1C_ATTRCERT_AttrSpec::ASN1C_ATTRCERT_AttrSpec
    (ASN1T_ATTRCERT_AttrSpec& data) : ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT_AttrSpec::ASN1C_ATTRCERT_AttrSpec (OSRTMessageBufferIF& msgBuf
   , ASN1T_ATTRCERT_AttrSpec& data) : ASN1CSeqOfList(msgBuf, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT_AttrSpec::ASN1C_ATTRCERT_AttrSpec (OSRTContext &context
   , ASN1T_ATTRCERT_AttrSpec& data) : ASN1CSeqOfList(context, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_ATTRCERT_AttrSpec::ASN1C_ATTRCERT_AttrSpec (ASN1CType& ccobj
   , ASN1T_ATTRCERT_AttrSpec& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_ATTRCERT_AttrSpec::Append (ASN1TObjId* elem)
{
   append ((void*)elem);
}

ASN1TObjId* ASN1C_ATTRCERT_AttrSpec::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1TObjId));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1TObjId;
}

ASN1TObjId* ASN1C_ATTRCERT_AttrSpec::AppendNewElement ()
{
   ASN1TObjId* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_ATTRCERT_AttrSpec::~ASN1T_ATTRCERT_AttrSpec ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_ATTRCERT_AttrSpec (pctxt, this);
   }
}

int ASN1C_ATTRCERT_AttrSpec::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT_AttrSpec (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT_AttrSpec::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_ATTRCERT_AttrSpec;
   msgData.setContext (msgBuf.getContext());
   return asn1D_ATTRCERT_AttrSpec (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_ATTRCERT_AttrSpec (ASN1T_ATTRCERT_AttrSpec* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_ATTRCERT_AttrSpec;
   rtxDListFastInit (pvalue);
}

void asn1Free_ATTRCERT_AttrSpec (OSCTXT *pctxt, 
   ASN1T_ATTRCERT_AttrSpec* pvalue)
{
   if (0 == pvalue) return;
   { ASN1TObjId* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1TObjId*)pnode->data;
      OS_UNUSED_ARG(pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_ATTRCERT_AttrSpec::MemFree ()
{
   asn1Free_ATTRCERT_AttrSpec (getCtxtPtr(), &msgData);
}

ASN1T_ATTRCERT_AAControls* new_ASN1T_ATTRCERT_AAControls (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_ATTRCERT_AAControls));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_ATTRCERT_AAControls;
}

ASN1C_ATTRCERT_AAControls::ASN1C_ATTRCERT_AAControls
    (ASN1T_ATTRCERT_AAControls& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT_AAControls::ASN1C_ATTRCERT_AAControls (
   OSRTMessageBufferIF& msgBuf, ASN1T_ATTRCERT_AAControls& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT_AAControls::ASN1C_ATTRCERT_AAControls (OSRTContext &context
   , ASN1T_ATTRCERT_AAControls& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_ATTRCERT_AAControls::ASN1T_ATTRCERT_AAControls ()
{
   m.pathLenConstraintPresent = 0;
   m.permittedAttrsPresent = 0;
   m.excludedAttrsPresent = 0;
   permitUnSpecified = TRUE;
}

ASN1T_ATTRCERT_AAControls::~ASN1T_ATTRCERT_AAControls ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_ATTRCERT_AAControls (pctxt, this);
   }
}

int ASN1C_ATTRCERT_AAControls::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT_AAControls (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT_AAControls::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_ATTRCERT_AAControls;
   msgData.setContext (msgBuf.getContext());
   return asn1D_ATTRCERT_AAControls (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_ATTRCERT_AAControls (ASN1T_ATTRCERT_AAControls* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_ATTRCERT_AAControls;
}

void asn1Free_ATTRCERT_AAControls (OSCTXT *pctxt, 
   ASN1T_ATTRCERT_AAControls* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.permittedAttrsPresent) {
      asn1Free_ATTRCERT_AttrSpec (pctxt, &pvalue->permittedAttrs);
   }
   if (pvalue->m.excludedAttrsPresent) {
      asn1Free_ATTRCERT_AttrSpec (pctxt, &pvalue->excludedAttrs);
   }
}

void ASN1C_ATTRCERT_AAControls::MemFree ()
{
   asn1Free_ATTRCERT_AAControls (getCtxtPtr(), &msgData);
}

ASN1T_ATTRCERT_ACClearAttrs* new_ASN1T_ATTRCERT_ACClearAttrs (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_ATTRCERT_ACClearAttrs));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_ATTRCERT_ACClearAttrs;
}

ASN1C_ATTRCERT_ACClearAttrs::ASN1C_ATTRCERT_ACClearAttrs
    (ASN1T_ATTRCERT_ACClearAttrs& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT_ACClearAttrs::ASN1C_ATTRCERT_ACClearAttrs (
   OSRTMessageBufferIF& msgBuf, ASN1T_ATTRCERT_ACClearAttrs& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT_ACClearAttrs::ASN1C_ATTRCERT_ACClearAttrs (OSRTContext &context
   , ASN1T_ATTRCERT_ACClearAttrs& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_ATTRCERT_ACClearAttrs::ASN1T_ATTRCERT_ACClearAttrs ()
{
}

ASN1T_ATTRCERT_ACClearAttrs::~ASN1T_ATTRCERT_ACClearAttrs ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_ATTRCERT_ACClearAttrs (pctxt, this);
   }
}

int ASN1C_ATTRCERT_ACClearAttrs::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT_ACClearAttrs (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT_ACClearAttrs::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_ATTRCERT_ACClearAttrs;
   msgData.setContext (msgBuf.getContext());
   return asn1D_ATTRCERT_ACClearAttrs (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_ATTRCERT_ACClearAttrs (ASN1T_ATTRCERT_ACClearAttrs* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_ATTRCERT_ACClearAttrs;
}

void asn1Free_ATTRCERT_ACClearAttrs (OSCTXT *pctxt, 
   ASN1T_ATTRCERT_ACClearAttrs* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_IMP_GeneralName (pctxt, &pvalue->acIssuer);
   asn1Free_ATTRCERT__SeqOfATTRCERT_Attribute (pctxt, &pvalue->attrs);
}

void ASN1C_ATTRCERT_ACClearAttrs::MemFree ()
{
   asn1Free_ATTRCERT_ACClearAttrs (getCtxtPtr(), &msgData);
}

ASN1C_ATTRCERT_ProxyInfo::ASN1C_ATTRCERT_ProxyInfo
    (ASN1T_ATTRCERT_ProxyInfo& data) : ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT_ProxyInfo::ASN1C_ATTRCERT_ProxyInfo (OSRTMessageBufferIF& msgBuf
   , ASN1T_ATTRCERT_ProxyInfo& data) : ASN1CSeqOfList(msgBuf, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT_ProxyInfo::ASN1C_ATTRCERT_ProxyInfo (OSRTContext &context
   , ASN1T_ATTRCERT_ProxyInfo& data) : ASN1CSeqOfList(context, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_ATTRCERT_ProxyInfo::ASN1C_ATTRCERT_ProxyInfo (ASN1CType& ccobj
   , ASN1T_ATTRCERT_ProxyInfo& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_ATTRCERT_ProxyInfo::Append (ASN1T_ATTRCERT_Targets* elem)
{
   append ((void*)elem);
}

ASN1T_ATTRCERT_Targets* ASN1C_ATTRCERT_ProxyInfo::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_ATTRCERT_Targets));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_ATTRCERT_Targets;
}

ASN1T_ATTRCERT_Targets* ASN1C_ATTRCERT_ProxyInfo::AppendNewElement ()
{
   ASN1T_ATTRCERT_Targets* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_ATTRCERT_ProxyInfo::~ASN1T_ATTRCERT_ProxyInfo ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_ATTRCERT_ProxyInfo (pctxt, this);
   }
}

int ASN1C_ATTRCERT_ProxyInfo::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT_ProxyInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT_ProxyInfo::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_ATTRCERT_ProxyInfo;
   msgData.setContext (msgBuf.getContext());
   return asn1D_ATTRCERT_ProxyInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_ATTRCERT_ProxyInfo (ASN1T_ATTRCERT_ProxyInfo* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_ATTRCERT_ProxyInfo;
   rtxDListFastInit (pvalue);
}

void asn1Free_ATTRCERT_ProxyInfo (OSCTXT *pctxt, 
   ASN1T_ATTRCERT_ProxyInfo* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_ATTRCERT_Targets* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_ATTRCERT_Targets*)pnode->data;
      asn1Free_ATTRCERT_Targets (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_ATTRCERT_ProxyInfo::MemFree ()
{
   asn1Free_ATTRCERT_ProxyInfo (getCtxtPtr(), &msgData);
}

ASN1T_ATTRCERT_AttributeCertificateInfoV1_subject* 
   new_ASN1T_ATTRCERT_AttributeCertificateInfoV1_subject (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_ATTRCERT_AttributeCertificateInfoV1_subject));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_ATTRCERT_AttributeCertificateInfoV1_subject;
}

ASN1C_ATTRCERT_AttributeCertificateInfoV1_subject::
   ASN1C_ATTRCERT_AttributeCertificateInfoV1_subject
    (ASN1T_ATTRCERT_AttributeCertificateInfoV1_subject& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT_AttributeCertificateInfoV1_subject::
   ASN1C_ATTRCERT_AttributeCertificateInfoV1_subject (
   OSRTMessageBufferIF& msgBuf
   , ASN1T_ATTRCERT_AttributeCertificateInfoV1_subject& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT_AttributeCertificateInfoV1_subject::
   ASN1C_ATTRCERT_AttributeCertificateInfoV1_subject (OSRTContext &context
   , ASN1T_ATTRCERT_AttributeCertificateInfoV1_subject& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_ATTRCERT_AttributeCertificateInfoV1_subject::~ASN1T_ATTRCERT_AttributeCertificateInfoV1_subject ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_ATTRCERT_AttributeCertificateInfoV1_subject (pctxt, this);
   }
}

int ASN1C_ATTRCERT_AttributeCertificateInfoV1_subject::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT_AttributeCertificateInfoV1_subject (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT_AttributeCertificateInfoV1_subject::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_ATTRCERT_AttributeCertificateInfoV1_subject;
   msgData.setContext (msgBuf.getContext());
   return asn1D_ATTRCERT_AttributeCertificateInfoV1_subject (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_ATTRCERT_AttributeCertificateInfoV1_subject (
   ASN1T_ATTRCERT_AttributeCertificateInfoV1_subject* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_ATTRCERT_AttributeCertificateInfoV1_subject;
}

void asn1Free_ATTRCERT_AttributeCertificateInfoV1_subject (OSCTXT *pctxt, 
   ASN1T_ATTRCERT_AttributeCertificateInfoV1_subject* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.baseCertificateID) {
            asn1Free_ATTRCERT_IssuerSerial (pctxt, pvalue->u.baseCertificateID);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.baseCertificateID);
         }
         break;

      case 2:
         if (0 != pvalue->u.subjectName) {
            asn1Free_IMP_GeneralNames (pctxt, pvalue->u.subjectName);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.subjectName);
         }
         break;

   }
}

void ASN1C_ATTRCERT_AttributeCertificateInfoV1_subject::MemFree ()
{
   asn1Free_ATTRCERT_AttributeCertificateInfoV1_subject (getCtxtPtr(), &msgData);
}

ASN1T_ATTRCERT_AttributeCertificateInfoV1* 
   new_ASN1T_ATTRCERT_AttributeCertificateInfoV1 (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_ATTRCERT_AttributeCertificateInfoV1));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_ATTRCERT_AttributeCertificateInfoV1;
}

ASN1C_ATTRCERT_AttributeCertificateInfoV1::
   ASN1C_ATTRCERT_AttributeCertificateInfoV1
    (ASN1T_ATTRCERT_AttributeCertificateInfoV1& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT_AttributeCertificateInfoV1::
   ASN1C_ATTRCERT_AttributeCertificateInfoV1 (OSRTMessageBufferIF& msgBuf
   , ASN1T_ATTRCERT_AttributeCertificateInfoV1& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT_AttributeCertificateInfoV1::
   ASN1C_ATTRCERT_AttributeCertificateInfoV1 (OSRTContext &context
   , ASN1T_ATTRCERT_AttributeCertificateInfoV1& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_ATTRCERT_AttributeCertificateInfoV1::ASN1T_ATTRCERT_AttributeCertificateInfoV1 ()
{
   version = ATTRCERT_AttCertVersionV1::v1;
   m.issuerUniqueIDPresent = 0;
   m.extensionsPresent = 0;
}

ASN1T_ATTRCERT_AttributeCertificateInfoV1::~ASN1T_ATTRCERT_AttributeCertificateInfoV1 ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_ATTRCERT_AttributeCertificateInfoV1 (pctxt, this);
   }
}

int ASN1C_ATTRCERT_AttributeCertificateInfoV1::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT_AttributeCertificateInfoV1 (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT_AttributeCertificateInfoV1::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_ATTRCERT_AttributeCertificateInfoV1;
   msgData.setContext (msgBuf.getContext());
   return asn1D_ATTRCERT_AttributeCertificateInfoV1 (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_ATTRCERT_AttributeCertificateInfoV1 (
   ASN1T_ATTRCERT_AttributeCertificateInfoV1* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_ATTRCERT_AttributeCertificateInfoV1;
}

void asn1Free_ATTRCERT_AttributeCertificateInfoV1 (OSCTXT *pctxt, 
   ASN1T_ATTRCERT_AttributeCertificateInfoV1* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ATTRCERT_AttributeCertificateInfoV1_subject (pctxt, &pvalue->subject);
   asn1Free_IMP_GeneralNames (pctxt, &pvalue->issuer);
   asn1Free_EXP_AlgorithmIdentifier (pctxt, &pvalue->signature_);
   asn1Free_ATTRCERT_AttCertValidityPeriod (pctxt, &pvalue->attCertValidityPeriod);
   asn1Free_ATTRCERT__SeqOfATTRCERT_Attribute (pctxt, &pvalue->attributes);
   if (pvalue->m.issuerUniqueIDPresent) {
      asn1Free_EXP_UniqueIdentifier (pctxt, &pvalue->issuerUniqueID);
   }
   if (pvalue->m.extensionsPresent) {
      asn1Free_EXP_Extensions (pctxt, &pvalue->extensions);
   }
}

void ASN1C_ATTRCERT_AttributeCertificateInfoV1::MemFree ()
{
   asn1Free_ATTRCERT_AttributeCertificateInfoV1 (getCtxtPtr(), &msgData);
}

ASN1T_ATTRCERT_AttributeCertificateV1* 
   new_ASN1T_ATTRCERT_AttributeCertificateV1 (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_ATTRCERT_AttributeCertificateV1));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_ATTRCERT_AttributeCertificateV1;
}

ASN1C_ATTRCERT_AttributeCertificateV1::ASN1C_ATTRCERT_AttributeCertificateV1
    (ASN1T_ATTRCERT_AttributeCertificateV1& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_ATTRCERT_AttributeCertificateV1::ASN1C_ATTRCERT_AttributeCertificateV1 (
   OSRTMessageBufferIF& msgBuf, ASN1T_ATTRCERT_AttributeCertificateV1& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_ATTRCERT_AttributeCertificateV1::ASN1C_ATTRCERT_AttributeCertificateV1 (
   OSRTContext &context, ASN1T_ATTRCERT_AttributeCertificateV1& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_ATTRCERT_AttributeCertificateV1::ASN1T_ATTRCERT_AttributeCertificateV1 ()
{
}

ASN1T_ATTRCERT_AttributeCertificateV1::~ASN1T_ATTRCERT_AttributeCertificateV1 ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_ATTRCERT_AttributeCertificateV1 (pctxt, this);
   }
}

int ASN1C_ATTRCERT_AttributeCertificateV1::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_ATTRCERT_AttributeCertificateV1 (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_ATTRCERT_AttributeCertificateV1::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_ATTRCERT_AttributeCertificateV1;
   msgData.setContext (msgBuf.getContext());
   return asn1D_ATTRCERT_AttributeCertificateV1 (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_ATTRCERT_AttributeCertificateV1 (
   ASN1T_ATTRCERT_AttributeCertificateV1* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_ATTRCERT_AttributeCertificateV1;
}

void asn1Free_ATTRCERT_AttributeCertificateV1 (OSCTXT *pctxt, 
   ASN1T_ATTRCERT_AttributeCertificateV1* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ATTRCERT_AttributeCertificateInfoV1 (pctxt, &pvalue->acInfo);
   asn1Free_EXP_AlgorithmIdentifier (pctxt, &pvalue->signatureAlgorithm);
   if (pvalue->signature_.numbits > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->signature_.data);
      pvalue->signature_.numbits = 0;
      pvalue->signature_.data = 0;
   }
}

void ASN1C_ATTRCERT_AttributeCertificateV1::MemFree ()
{
   asn1Free_ATTRCERT_AttributeCertificateV1 (getCtxtPtr(), &msgData);
}

