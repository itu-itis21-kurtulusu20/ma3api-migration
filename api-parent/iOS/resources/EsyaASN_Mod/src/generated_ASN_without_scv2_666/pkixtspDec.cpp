/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.6, Date: 20-Feb-2014.
 */
#include "pkixtsp.h"
#include "rtxsrc/rtxCommon.h"

EXTERN int asn1D_TSP_BIGINTEGER (OSCTXT* pctxt, ASN1T_TSP_BIGINTEGER* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BIGINTEGER");

   stat = xd_bigint (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_TSP_TSAPolicyId (OSCTXT* pctxt, 
   ASN1T_TSP_TSAPolicyId* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TSAPolicyId");

   stat = xd_objid (pctxt, (ASN1OBJID*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_TSP_PKIStatus (OSCTXT* pctxt, ASN1T_TSP_PKIStatus* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PKIStatus");

   stat = xd_integer (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_TSP_PKIFailureInfo (OSCTXT* pctxt, 
   ASN1T_TSP_PKIFailureInfo* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PKIFailureInfo");

   pvalue->numbits = 26;
   stat = xd_bitstr_s (pctxt, pvalue->data, &pvalue->numbits, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_TSP_TimeStampToken (OSCTXT* pctxt, 
   ASN1T_TSP_TimeStampToken* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TimeStampToken");

   stat = asn1D_CMS_ContentInfo (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_TSP_TimeStampReq_version (OSCTXT* pctxt, 
   ASN1T_TSP_TimeStampReq_version* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_integer (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1D_TSP_TSTInfo_version (OSCTXT* pctxt, 
   ASN1T_TSP_TSTInfo_version* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_integer (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1D_TSP_MessageImprint (OSCTXT* pctxt, 
   ASN1T_TSP_MessageImprint* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "MessageImprint");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode hashAlgorithm */
         RTXCTXTPUSHELEMNAME (pctxt, "hashAlgorithm");

         stat = asn1D_EXP_AlgorithmIdentifier (pctxt, &pvalue->hashAlgorithm, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode hashedMessage */
         RTXCTXTPUSHELEMNAME (pctxt, "hashedMessage");

         stat = xd_octstr (pctxt, &pvalue->hashedMessage.data, &pvalue->hashedMessage.numocts, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_CONS|16):
         case (TM_UNIV|TM_PRIM|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_TSP_TimeStampReq (OSCTXT* pctxt, 
   ASN1T_TSP_TimeStampReq* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "TimeStampReq");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
      pvalue->certReq = FALSE;
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode version */
         RTXCTXTPUSHELEMNAME (pctxt, "version");

         stat = asn1D_TSP_TimeStampReq_version (pctxt, &pvalue->version, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode messageImprint */
         RTXCTXTPUSHELEMNAME (pctxt, "messageImprint");

         stat = asn1D_TSP_MessageImprint (pctxt, &pvalue->messageImprint, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode reqPolicy */
         if (XD_PEEKTAG (pctxt, 0x6)) {
            RTXCTXTPUSHELEMNAME (pctxt, "reqPolicy");

            stat = asn1D_TSP_TSAPolicyId (pctxt, &pvalue->reqPolicy, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.reqPolicyPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 3:
         /* decode nonce */
         if (XD_PEEKTAG (pctxt, 0x2)) {
            RTXCTXTPUSHELEMNAME (pctxt, "nonce");

            stat = asn1D_TSP_BIGINTEGER (pctxt, &pvalue->nonce, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.noncePresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 4:
         /* decode certReq */
         if (XD_PEEKTAG (pctxt, 0x1)) {
            RTXCTXTPUSHELEMNAME (pctxt, "certReq");

            stat = xd_boolean (pctxt, &pvalue->certReq, ASN1EXPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 5:
         /* decode extensions */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "extensions");

            stat = asn1D_EXP_Extensions (pctxt, &pvalue->extensions, 
               ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.extensionsPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|2):
         case (TM_UNIV|TM_CONS|16):
         case (TM_UNIV|TM_PRIM|6):
         case (TM_UNIV|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_TSP_PKIStatusInfo (OSCTXT* pctxt, 
   ASN1T_TSP_PKIStatusInfo* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "PKIStatusInfo");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode status */
         RTXCTXTPUSHELEMNAME (pctxt, "status");

         stat = asn1D_TSP_PKIStatus (pctxt, &pvalue->status, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode statusString */
         if (XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "statusString");

            stat = asn1D_CMP_PKIFreeText (pctxt, &pvalue->statusString, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.statusStringPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 2:
         /* decode failInfo */
         if (XD_PEEKTAG (pctxt, 0x3)) {
            RTXCTXTPUSHELEMNAME (pctxt, "failInfo");

            stat = asn1D_TSP_PKIFailureInfo (pctxt, &pvalue->failInfo, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.failInfoPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|2):
         case (TM_UNIV|TM_CONS|16):
         case (TM_UNIV|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_TSP_TimeStampResp (OSCTXT* pctxt, 
   ASN1T_TSP_TimeStampResp* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "TimeStampResp");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode status */
         RTXCTXTPUSHELEMNAME (pctxt, "status");

         stat = asn1D_TSP_PKIStatusInfo (pctxt, &pvalue->status, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode timeStampToken */
         if (XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "timeStampToken");

            stat = asn1D_TSP_TimeStampToken (pctxt, &pvalue->timeStampToken, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.timeStampTokenPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_TSP_Accuracy (OSCTXT* pctxt, ASN1T_TSP_Accuracy* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "Accuracy");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode seconds */
         if (XD_PEEKTAG (pctxt, 0x2)) {
            RTXCTXTPUSHELEMNAME (pctxt, "seconds");

            stat = xd_integer (pctxt, &pvalue->seconds, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.secondsPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 1:
         /* decode millis */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "millis");

            stat = xd_uint16 (pctxt, &pvalue->millis, ASN1IMPL, length);
            if (stat == 0) {
               if (!((pvalue->millis >= OSUINTCONST(1) && pvalue->millis
                   <= OSUINTCONST(999)))) {
                  rtxErrAddElemNameParm (pctxt);
                  rtxErrAddIntParm (pctxt, (int)pvalue->millis);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

               pvalue->m.millisPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 2:
         /* decode micros */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "micros");

            stat = xd_uint16 (pctxt, &pvalue->micros, ASN1IMPL, length);
            if (stat == 0) {
               if (!((pvalue->micros >= OSUINTCONST(1) && pvalue->micros
                   <= OSUINTCONST(999)))) {
                  rtxErrAddElemNameParm (pctxt);
                  rtxErrAddIntParm (pctxt, (int)pvalue->micros);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

               pvalue->m.microsPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_TSP_TSTInfo (OSCTXT* pctxt, ASN1T_TSP_TSTInfo* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "TSTInfo");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
      pvalue->ordering = FALSE;
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode version */
         RTXCTXTPUSHELEMNAME (pctxt, "version");

         stat = asn1D_TSP_TSTInfo_version (pctxt, &pvalue->version, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode policy */
         RTXCTXTPUSHELEMNAME (pctxt, "policy");

         stat = asn1D_TSP_TSAPolicyId (pctxt, &pvalue->policy, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode messageImprint */
         RTXCTXTPUSHELEMNAME (pctxt, "messageImprint");

         stat = asn1D_TSP_MessageImprint (pctxt, &pvalue->messageImprint, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 3:
         /* decode serialNumber */
         RTXCTXTPUSHELEMNAME (pctxt, "serialNumber");

         stat = asn1D_TSP_BIGINTEGER (pctxt, &pvalue->serialNumber, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 4:
         /* decode genTime */
         RTXCTXTPUSHELEMNAME (pctxt, "genTime");

         stat = xd_charstr (pctxt, &pvalue->genTime, ASN1EXPL, 
            (TM_UNIV|TM_PRIM|24), length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 5:
         /* decode accuracy */
         if (XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "accuracy");

            stat = asn1D_TSP_Accuracy (pctxt, &pvalue->accuracy, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.accuracyPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 6:
         /* decode ordering */
         if (XD_PEEKTAG (pctxt, 0x1)) {
            RTXCTXTPUSHELEMNAME (pctxt, "ordering");

            stat = xd_boolean (pctxt, &pvalue->ordering, ASN1EXPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 7:
         /* decode nonce */
         if (XD_PEEKTAG (pctxt, 0x2)) {
            RTXCTXTPUSHELEMNAME (pctxt, "nonce");

            stat = asn1D_TSP_BIGINTEGER (pctxt, &pvalue->nonce, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.noncePresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 8:
         /* decode tsa */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "tsa");

            stat = asn1D_IMP_GeneralName (pctxt, &pvalue->tsa, 
               ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.tsaPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 9:
         /* decode extensions */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "extensions");

            stat = asn1D_EXP_Extensions (pctxt, &pvalue->extensions, 
               ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.extensionsPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|2):
         case (TM_UNIV|TM_PRIM|6):
         case (TM_UNIV|TM_CONS|16):
         case (TM_UNIV|TM_PRIM|24):
         case (TM_UNIV|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 5) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_TSP_ESYAReqEx (OSCTXT* pctxt, ASN1T_TSP_ESYAReqEx* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "ESYAReqEx");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode userid */
         RTXCTXTPUSHELEMNAME (pctxt, "userid");

         stat = xd_integer (pctxt, &pvalue->userid, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode salt */
         RTXCTXTPUSHELEMNAME (pctxt, "salt");

         stat = xd_octstr (pctxt, &pvalue->salt.data, &pvalue->salt.numocts, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode iterationCount */
         RTXCTXTPUSHELEMNAME (pctxt, "iterationCount");

         stat = xd_integer (pctxt, &pvalue->iterationCount, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 3:
         /* decode iv */
         RTXCTXTPUSHELEMNAME (pctxt, "iv");

         stat = xd_octstr (pctxt, &pvalue->iv.data, &pvalue->iv.numocts, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 4:
         /* decode encryptedMessageImprint */
         RTXCTXTPUSHELEMNAME (pctxt, "encryptedMessageImprint");

         stat = xd_octstr (pctxt, &pvalue->encryptedMessageImprint.data, &pvalue->encryptedMessageImprint.numocts, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|2):
         case (TM_UNIV|TM_PRIM|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 5) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

