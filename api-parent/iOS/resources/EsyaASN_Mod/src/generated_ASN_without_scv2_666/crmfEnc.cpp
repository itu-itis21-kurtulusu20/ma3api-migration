/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.6, Date: 20-Feb-2014.
 */
#include "crmf.h"
#include "rtxsrc/rtxCommon.h"

EXTERN int asn1E_CRMF_SubsequentMessage (OSCTXT* pctxt,
   ASN1T_CRMF_SubsequentMessage *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SubsequentMessage");

   ll = xe_integer (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_CRMF_PKIPublicationInfo_action (OSCTXT* pctxt,
   ASN1T_CRMF_PKIPublicationInfo_action *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = xe_integer (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

EXTERN int asn1E_CRMF_SinglePubInfo_pubMethod (OSCTXT* pctxt,
   ASN1T_CRMF_SinglePubInfo_pubMethod *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   ll = xe_integer (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

EXTERN int asn1E_CRMF_OptionalValidity (OSCTXT* pctxt,
   ASN1T_CRMF_OptionalValidity *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "OptionalValidity");

   /* encode notAfter */

   if (pvalue->m.notAfterPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "notAfter");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_EXP_Time (pctxt, &pvalue->notAfter, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode notBefore */

   if (pvalue->m.notBeforePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "notBefore");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_EXP_Time (pctxt, &pvalue->notBefore, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_CRMF_CertTemplate (OSCTXT* pctxt,
   ASN1T_CRMF_CertTemplate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CertTemplate");

   /* encode extensions */

   if (pvalue->m.extensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "extensions");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|9,
         asn1E_EXP_Extensions (pctxt, &pvalue->extensions, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode subjectUID */

   if (pvalue->m.subjectUIDPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "subjectUID");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|8,
         asn1E_EXP_UniqueIdentifier (pctxt, &pvalue->subjectUID, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode issuerUID */

   if (pvalue->m.issuerUIDPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "issuerUID");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|7,
         asn1E_EXP_UniqueIdentifier (pctxt, &pvalue->issuerUID, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode publicKey */

   if (pvalue->m.publicKeyPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "publicKey");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|6,
         asn1E_EXP_SubjectPublicKeyInfo (pctxt, &pvalue->publicKey, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode subject */

   if (pvalue->m.subjectPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "subject");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
         asn1E_EXP_Name (pctxt, &pvalue->subject, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode validity */

   if (pvalue->m.validityPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "validity");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
         asn1E_CRMF_OptionalValidity (pctxt, &pvalue->validity, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode issuer */

   if (pvalue->m.issuerPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "issuer");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_EXP_Name (pctxt, &pvalue->issuer, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode signingAlg */

   if (pvalue->m.signingAlgPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "signingAlg");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_EXP_AlgorithmIdentifier (pctxt, &pvalue->signingAlg, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode serialNumber */

   if (pvalue->m.serialNumberPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "serialNumber");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         asn1E_EXP_CertificateSerialNumber (pctxt, &pvalue->serialNumber, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode version */

   if (pvalue->m.versionPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "version");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         asn1E_EXP_Version (pctxt, &pvalue->version, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_CRMF_SinglePubInfo (OSCTXT* pctxt,
   ASN1T_CRMF_SinglePubInfo *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SinglePubInfo");

   /* encode pubLocation */

   if (pvalue->m.pubLocationPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "pubLocation");

      ll = asn1E_IMP_GeneralName (pctxt, &pvalue->pubLocation, ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode pubMethod */

   RTXCTXTPUSHELEMNAME (pctxt, "pubMethod");

   ll = asn1E_CRMF_SinglePubInfo_pubMethod (pctxt, &pvalue->pubMethod, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_CRMF_PKIPublicationInfo_pubInfos (OSCTXT* pctxt,
   ASN1T_CRMF_PKIPublicationInfo_pubInfos *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode;
   int xx1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   xx1 = (int)pvalue->count;
   pnode = pvalue->tail;
   while (0 != pnode) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SinglePubInfo", xx1);

      ll = asn1E_CRMF_SinglePubInfo (pctxt, ((ASN1T_CRMF_SinglePubInfo*)pnode->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      xx1--;

      pnode = pnode->prev;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

EXTERN int asn1E_CRMF_PKIPublicationInfo (OSCTXT* pctxt,
   ASN1T_CRMF_PKIPublicationInfo *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PKIPublicationInfo");

   /* encode pubInfos */

   if (pvalue->m.pubInfosPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "pubInfos");

      ll = asn1E_CRMF_PKIPublicationInfo_pubInfos (pctxt, &pvalue->pubInfos, ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode action */

   RTXCTXTPUSHELEMNAME (pctxt, "action");

   ll = asn1E_CRMF_PKIPublicationInfo_action (pctxt, &pvalue->action, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_CRMF_EncryptedValue (OSCTXT* pctxt,
   ASN1T_CRMF_EncryptedValue *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EncryptedValue");

   /* encode encValue */

   RTXCTXTPUSHELEMNAME (pctxt, "encValue");

   ll = xe_bitstr (pctxt, pvalue->encValue.data, pvalue->encValue.numbits, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode valueHint */

   if (pvalue->m.valueHintPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "valueHint");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_octstr (pctxt, pvalue->valueHint.data, pvalue->valueHint.numocts, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode keyAlg */

   if (pvalue->m.keyAlgPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "keyAlg");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
         asn1E_EXP_AlgorithmIdentifier (pctxt, &pvalue->keyAlg, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode encSymmKey */

   if (pvalue->m.encSymmKeyPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "encSymmKey");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_bitstr (pctxt, pvalue->encSymmKey.data, pvalue->encSymmKey.numbits, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode symmAlg */

   if (pvalue->m.symmAlgPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "symmAlg");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_EXP_AlgorithmIdentifier (pctxt, &pvalue->symmAlg, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode intendedAlg */

   if (pvalue->m.intendedAlgPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "intendedAlg");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_EXP_AlgorithmIdentifier (pctxt, &pvalue->intendedAlg, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_CRMF_CertId (OSCTXT* pctxt,
   ASN1T_CRMF_CertId *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CertId");

   /* encode serialNumber */

   RTXCTXTPUSHELEMNAME (pctxt, "serialNumber");

   ll = asn1E_EXP_CertificateSerialNumber (pctxt, &pvalue->serialNumber, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode issuer */

   RTXCTXTPUSHELEMNAME (pctxt, "issuer");

   ll = asn1E_IMP_GeneralName (pctxt, &pvalue->issuer, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_CRMF_Controls (OSCTXT* pctxt,
   ASN1T_CRMF_Controls *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode;
   int xx1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Controls");

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   xx1 = (int)pvalue->count;
   pnode = pvalue->tail;
   while (0 != pnode) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "AttributeTypeAndValue", xx1);

      ll = asn1E_EXP_AttributeTypeAndValue (pctxt, ((ASN1T_EXP_AttributeTypeAndValue*)pnode->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      xx1--;

      pnode = pnode->prev;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_CRMF_CertRequest (OSCTXT* pctxt,
   ASN1T_CRMF_CertRequest *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CertRequest");

   /* encode controls */

   if (pvalue->m.controlsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "controls");

      ll = asn1E_CRMF_Controls (pctxt, &pvalue->controls, ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode certTemplate */

   RTXCTXTPUSHELEMNAME (pctxt, "certTemplate");

   ll = asn1E_CRMF_CertTemplate (pctxt, &pvalue->certTemplate, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode certReqId */

   RTXCTXTPUSHELEMNAME (pctxt, "certReqId");

   ll = xe_integer (pctxt, &pvalue->certReqId, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_CRMF_PKMACValue (OSCTXT* pctxt,
   ASN1T_CRMF_PKMACValue *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PKMACValue");

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   ll = xe_bitstr (pctxt, pvalue->value.data, pvalue->value.numbits, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode algId */

   RTXCTXTPUSHELEMNAME (pctxt, "algId");

   ll = asn1E_EXP_AlgorithmIdentifier (pctxt, &pvalue->algId, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_CRMF_POPOSigningKeyInput_authInfo (OSCTXT* pctxt,
   ASN1T_CRMF_POPOSigningKeyInput_authInfo *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "publicKeyMAC");

         ll = asn1E_CRMF_PKMACValue (pctxt, pvalue->u.publicKeyMAC, ASN1EXPL);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "sender");

         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_IMP_GeneralName (pctxt, pvalue->u.sender, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         rtxErrAddIntParm (pctxt, pvalue->t);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

EXTERN int asn1E_CRMF_POPOSigningKeyInput (OSCTXT* pctxt,
   ASN1T_CRMF_POPOSigningKeyInput *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "POPOSigningKeyInput");

   /* encode publicKey */

   RTXCTXTPUSHELEMNAME (pctxt, "publicKey");

   ll = asn1E_EXP_SubjectPublicKeyInfo (pctxt, &pvalue->publicKey, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode authInfo */

   RTXCTXTPUSHELEMNAME (pctxt, "authInfo");

   ll = asn1E_CRMF_POPOSigningKeyInput_authInfo (pctxt, &pvalue->authInfo, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_CRMF_POPOSigningKey (OSCTXT* pctxt,
   ASN1T_CRMF_POPOSigningKey *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "POPOSigningKey");

   /* encode signature_ */

   RTXCTXTPUSHELEMNAME (pctxt, "signature");

   ll = xe_bitstr (pctxt, pvalue->signature_.data, pvalue->signature_.numbits, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode algorithmIdentifier */

   RTXCTXTPUSHELEMNAME (pctxt, "algorithmIdentifier");

   ll = asn1E_EXP_AlgorithmIdentifier (pctxt, &pvalue->algorithmIdentifier, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode poposkInput */

   if (pvalue->m.poposkInputPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "poposkInput");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_CRMF_POPOSigningKeyInput (pctxt, &pvalue->poposkInput, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_CRMF_POPOPrivKey (OSCTXT* pctxt,
   ASN1T_CRMF_POPOPrivKey *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "POPOPrivKey");

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "thisMessage");

         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
            xe_bitstr (pctxt, pvalue->u.thisMessage->data, pvalue->u.thisMessage->numbits, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "subsequentMessage");

         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
            asn1E_CRMF_SubsequentMessage (pctxt, &pvalue->u.subsequentMessage, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "dhMAC");

         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
            xe_bitstr (pctxt, pvalue->u.dhMAC->data, pvalue->u.dhMAC->numbits, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         rtxErrAddIntParm (pctxt, pvalue->t);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_CRMF_ProofOfPossession (OSCTXT* pctxt,
   ASN1T_CRMF_ProofOfPossession *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;
   OS_UNUSED_ARG (pvalue) ;

   RTXCTXTPUSHTYPENAME (pctxt, "ProofOfPossession");

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "raVerified");

         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
            xe_null (pctxt, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "signature");

         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_CRMF_POPOSigningKey (pctxt, pvalue->u.signature_, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "keyEncipherment");

         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_CRMF_POPOPrivKey (pctxt, pvalue->u.keyEncipherment, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "keyAgreement");

         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
            asn1E_CRMF_POPOPrivKey (pctxt, pvalue->u.keyAgreement, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         rtxErrAddIntParm (pctxt, pvalue->t);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_CRMF_CertReqMsg_regInfo (OSCTXT* pctxt,
   ASN1T_CRMF_CertReqMsg_regInfo *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode;
   int xx1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   xx1 = (int)pvalue->count;
   pnode = pvalue->tail;
   while (0 != pnode) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "AttributeTypeAndValue", xx1);

      ll = asn1E_EXP_AttributeTypeAndValue (pctxt, ((ASN1T_EXP_AttributeTypeAndValue*)pnode->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      xx1--;

      pnode = pnode->prev;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

EXTERN int asn1E_CRMF_CertReqMsg (OSCTXT* pctxt,
   ASN1T_CRMF_CertReqMsg *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CertReqMsg");

   /* encode regInfo */

   if (pvalue->m.regInfoPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "regInfo");

      ll = asn1E_CRMF_CertReqMsg_regInfo (pctxt, &pvalue->regInfo, ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode pop */

   if (pvalue->m.popPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "pop");

      ll = asn1E_CRMF_ProofOfPossession (pctxt, &pvalue->pop, ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode certReq */

   RTXCTXTPUSHELEMNAME (pctxt, "certReq");

   ll = asn1E_CRMF_CertRequest (pctxt, &pvalue->certReq, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_CRMF_CertReqMessages (OSCTXT* pctxt,
   ASN1T_CRMF_CertReqMessages *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode;
   int xx1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CertReqMessages");

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   xx1 = (int)pvalue->count;
   pnode = pvalue->tail;
   while (0 != pnode) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CertReqMsg", xx1);

      ll = asn1E_CRMF_CertReqMsg (pctxt, ((ASN1T_CRMF_CertReqMsg*)pnode->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      xx1--;

      pnode = pnode->prev;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

