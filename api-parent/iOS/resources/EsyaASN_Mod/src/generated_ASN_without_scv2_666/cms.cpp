/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.6, Date: 20-Feb-2014.
 */
#include <new>
#include "cms.h"
#include "rtxsrc/rtxCommon.h"

ASN1OBJID CMS_id_ct_contentInfo = {
   9,
   { 1, 2, 840, 113549, 1, 9, 16, 1, 6 }
} ;
ASN1OBJID CMS_id_data = {
   7,
   { 1, 2, 840, 113549, 1, 7, 1 }
} ;
ASN1OBJID CMS_id_signedData = {
   7,
   { 1, 2, 840, 113549, 1, 7, 2 }
} ;
ASN1OBJID CMS_id_envelopedData = {
   7,
   { 1, 2, 840, 113549, 1, 7, 3 }
} ;
ASN1OBJID CMS_id_digestedData = {
   7,
   { 1, 2, 840, 113549, 1, 7, 5 }
} ;
ASN1OBJID CMS_id_encryptedData = {
   7,
   { 1, 2, 840, 113549, 1, 7, 6 }
} ;
ASN1OBJID CMS_id_ct_authData = {
   9,
   { 1, 2, 840, 113549, 1, 9, 16, 1, 2 }
} ;
ASN1OBJID CMS_id_contentType = {
   7,
   { 1, 2, 840, 113549, 1, 9, 3 }
} ;
ASN1OBJID CMS_id_messageDigest = {
   7,
   { 1, 2, 840, 113549, 1, 9, 4 }
} ;
ASN1OBJID CMS_id_signingTime = {
   7,
   { 1, 2, 840, 113549, 1, 9, 5 }
} ;
ASN1OBJID CMS_id_countersignature = {
   7,
   { 1, 2, 840, 113549, 1, 9, 6 }
} ;
ASN1OBJID CMS_id_timeStamp = {
   9,
   { 1, 2, 840, 113549, 1, 9, 16, 2, 14 }
} ;
ASN1OBJID CMS_id_aa = {
   8,
   { 1, 2, 840, 113549, 1, 9, 16, 2 }
} ;
ASN1OBJID CMS_smimeCapabilities = {
   7,
   { 1, 2, 840, 113549, 1, 9, 15 }
} ;
ASN1OBJID CMS_id_aa_encrypKeyPref = {
   9,
   { 1, 2, 840, 113549, 1, 9, 16, 2, 11 }
} ;

ASN1T_CMS_ContentType* new_ASN1T_CMS_ContentType (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_ContentType));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_ContentType;
}

ASN1C_CMS_ContentType::ASN1C_CMS_ContentType (ASN1T_CMS_ContentType& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_ContentType::ASN1C_CMS_ContentType (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMS_ContentType& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_ContentType::ASN1C_CMS_ContentType (OSRTContext &context
   , ASN1T_CMS_ContentType& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_CMS_ContentType::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_ContentType (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_ContentType::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_CMS_ContentType (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_ContentType (ASN1T_CMS_ContentType* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_ContentType;
}

ASN1T_CMS_EncryptedKey* new_ASN1T_CMS_EncryptedKey (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_EncryptedKey));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_EncryptedKey;
}

ASN1C_CMS_EncryptedKey::ASN1C_CMS_EncryptedKey (ASN1T_CMS_EncryptedKey& data)
    : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_EncryptedKey::ASN1C_CMS_EncryptedKey (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMS_EncryptedKey& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_EncryptedKey::ASN1C_CMS_EncryptedKey (OSRTContext &context
   , ASN1T_CMS_EncryptedKey& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_CMS_EncryptedKey::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_EncryptedKey (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_EncryptedKey::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_CMS_EncryptedKey (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_EncryptedKey (ASN1T_CMS_EncryptedKey* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_EncryptedKey;
}

void asn1Free_CMS_EncryptedKey (OSCTXT *pctxt, ASN1T_CMS_EncryptedKey* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

void ASN1C_CMS_EncryptedKey::MemFree ()
{
   asn1Free_CMS_EncryptedKey (getCtxtPtr(), &msgData);
}

ASN1T_CMS_SubjectKeyIdentifier* 
   new_ASN1T_CMS_SubjectKeyIdentifier (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_SubjectKeyIdentifier));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_SubjectKeyIdentifier;
}

ASN1C_CMS_SubjectKeyIdentifier::ASN1C_CMS_SubjectKeyIdentifier
    (ASN1T_CMS_SubjectKeyIdentifier& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_SubjectKeyIdentifier::ASN1C_CMS_SubjectKeyIdentifier (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_SubjectKeyIdentifier& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_SubjectKeyIdentifier::ASN1C_CMS_SubjectKeyIdentifier (
   OSRTContext &context, ASN1T_CMS_SubjectKeyIdentifier& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_CMS_SubjectKeyIdentifier::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_SubjectKeyIdentifier (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_SubjectKeyIdentifier::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_CMS_SubjectKeyIdentifier (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_SubjectKeyIdentifier (ASN1T_CMS_SubjectKeyIdentifier* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_SubjectKeyIdentifier;
}

void asn1Free_CMS_SubjectKeyIdentifier (OSCTXT *pctxt, 
   ASN1T_CMS_SubjectKeyIdentifier* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

void ASN1C_CMS_SubjectKeyIdentifier::MemFree ()
{
   asn1Free_CMS_SubjectKeyIdentifier (getCtxtPtr(), &msgData);
}

ASN1T_CMS_Digest* new_ASN1T_CMS_Digest (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_Digest));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_Digest;
}

ASN1C_CMS_Digest::ASN1C_CMS_Digest (ASN1T_CMS_Digest& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_Digest::ASN1C_CMS_Digest (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMS_Digest& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_Digest::ASN1C_CMS_Digest (OSRTContext &context
   , ASN1T_CMS_Digest& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_CMS_Digest::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_Digest (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_Digest::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_CMS_Digest (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_Digest (ASN1T_CMS_Digest* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_Digest;
}

void asn1Free_CMS_Digest (OSCTXT *pctxt, ASN1T_CMS_Digest* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

void ASN1C_CMS_Digest::MemFree ()
{
   asn1Free_CMS_Digest (getCtxtPtr(), &msgData);
}

ASN1T_CMS_MessageAuthenticationCode* 
   new_ASN1T_CMS_MessageAuthenticationCode (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_MessageAuthenticationCode));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_MessageAuthenticationCode;
}

ASN1C_CMS_MessageAuthenticationCode::ASN1C_CMS_MessageAuthenticationCode
    (ASN1T_CMS_MessageAuthenticationCode& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_MessageAuthenticationCode::ASN1C_CMS_MessageAuthenticationCode (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_MessageAuthenticationCode& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_MessageAuthenticationCode::ASN1C_CMS_MessageAuthenticationCode (
   OSRTContext &context, ASN1T_CMS_MessageAuthenticationCode& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_CMS_MessageAuthenticationCode::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_MessageAuthenticationCode (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_MessageAuthenticationCode::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_CMS_MessageAuthenticationCode (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_MessageAuthenticationCode (
   ASN1T_CMS_MessageAuthenticationCode* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_MessageAuthenticationCode;
}

void asn1Free_CMS_MessageAuthenticationCode (OSCTXT *pctxt, 
   ASN1T_CMS_MessageAuthenticationCode* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

void ASN1C_CMS_MessageAuthenticationCode::MemFree ()
{
   asn1Free_CMS_MessageAuthenticationCode (getCtxtPtr(), &msgData);
}

ASN1T_CMS_DigestAlgorithmIdentifier* 
   new_ASN1T_CMS_DigestAlgorithmIdentifier (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_DigestAlgorithmIdentifier));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_DigestAlgorithmIdentifier;
}

ASN1C_CMS_DigestAlgorithmIdentifier::ASN1C_CMS_DigestAlgorithmIdentifier
    (ASN1T_CMS_DigestAlgorithmIdentifier& data) : 
   ASN1C_EXP_AlgorithmIdentifier (data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_DigestAlgorithmIdentifier::ASN1C_CMS_DigestAlgorithmIdentifier (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_DigestAlgorithmIdentifier& data) : 
   ASN1C_EXP_AlgorithmIdentifier (msgBuf, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_DigestAlgorithmIdentifier::ASN1C_CMS_DigestAlgorithmIdentifier (
   OSRTContext &context, ASN1T_CMS_DigestAlgorithmIdentifier& data) : 
   ASN1C_EXP_AlgorithmIdentifier (context, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_CMS_DigestAlgorithmIdentifier::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_DigestAlgorithmIdentifier (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_DigestAlgorithmIdentifier::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_DigestAlgorithmIdentifier;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_DigestAlgorithmIdentifier (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_DigestAlgorithmIdentifier (
   ASN1T_CMS_DigestAlgorithmIdentifier* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_DigestAlgorithmIdentifier;
}

void asn1Free_CMS_DigestAlgorithmIdentifier (OSCTXT *pctxt, 
   ASN1T_CMS_DigestAlgorithmIdentifier* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_EXP_AlgorithmIdentifier (pctxt, pvalue);
}

void ASN1C_CMS_DigestAlgorithmIdentifier::MemFree ()
{
   asn1Free_CMS_DigestAlgorithmIdentifier (getCtxtPtr(), &msgData);
}

ASN1T_CMS_SignatureAlgorithmIdentifier* 
   new_ASN1T_CMS_SignatureAlgorithmIdentifier (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_SignatureAlgorithmIdentifier));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_SignatureAlgorithmIdentifier;
}

ASN1C_CMS_SignatureAlgorithmIdentifier::ASN1C_CMS_SignatureAlgorithmIdentifier
    (ASN1T_CMS_SignatureAlgorithmIdentifier& data) : 
   ASN1C_EXP_AlgorithmIdentifier (data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_SignatureAlgorithmIdentifier::
   ASN1C_CMS_SignatureAlgorithmIdentifier (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMS_SignatureAlgorithmIdentifier& data) : 
   ASN1C_EXP_AlgorithmIdentifier (msgBuf, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_SignatureAlgorithmIdentifier::
   ASN1C_CMS_SignatureAlgorithmIdentifier (OSRTContext &context
   , ASN1T_CMS_SignatureAlgorithmIdentifier& data) : 
   ASN1C_EXP_AlgorithmIdentifier (context, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_CMS_SignatureAlgorithmIdentifier::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_SignatureAlgorithmIdentifier (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_SignatureAlgorithmIdentifier::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_SignatureAlgorithmIdentifier;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_SignatureAlgorithmIdentifier (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_SignatureAlgorithmIdentifier (
   ASN1T_CMS_SignatureAlgorithmIdentifier* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_SignatureAlgorithmIdentifier;
}

void asn1Free_CMS_SignatureAlgorithmIdentifier (OSCTXT *pctxt, 
   ASN1T_CMS_SignatureAlgorithmIdentifier* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_EXP_AlgorithmIdentifier (pctxt, pvalue);
}

void ASN1C_CMS_SignatureAlgorithmIdentifier::MemFree ()
{
   asn1Free_CMS_SignatureAlgorithmIdentifier (getCtxtPtr(), &msgData);
}

ASN1T_CMS_KeyEncryptionAlgorithmIdentifier* 
   new_ASN1T_CMS_KeyEncryptionAlgorithmIdentifier (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_KeyEncryptionAlgorithmIdentifier));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_KeyEncryptionAlgorithmIdentifier;
}

ASN1C_CMS_KeyEncryptionAlgorithmIdentifier::
   ASN1C_CMS_KeyEncryptionAlgorithmIdentifier
    (ASN1T_CMS_KeyEncryptionAlgorithmIdentifier& data) : 
   ASN1C_EXP_AlgorithmIdentifier (data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_KeyEncryptionAlgorithmIdentifier::
   ASN1C_CMS_KeyEncryptionAlgorithmIdentifier (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMS_KeyEncryptionAlgorithmIdentifier& data) : 
   ASN1C_EXP_AlgorithmIdentifier (msgBuf, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_KeyEncryptionAlgorithmIdentifier::
   ASN1C_CMS_KeyEncryptionAlgorithmIdentifier (OSRTContext &context
   , ASN1T_CMS_KeyEncryptionAlgorithmIdentifier& data) : 
   ASN1C_EXP_AlgorithmIdentifier (context, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_CMS_KeyEncryptionAlgorithmIdentifier::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_KeyEncryptionAlgorithmIdentifier (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_KeyEncryptionAlgorithmIdentifier::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_KeyEncryptionAlgorithmIdentifier;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_KeyEncryptionAlgorithmIdentifier (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_KeyEncryptionAlgorithmIdentifier (
   ASN1T_CMS_KeyEncryptionAlgorithmIdentifier* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_KeyEncryptionAlgorithmIdentifier;
}

void asn1Free_CMS_KeyEncryptionAlgorithmIdentifier (OSCTXT *pctxt, 
   ASN1T_CMS_KeyEncryptionAlgorithmIdentifier* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_EXP_AlgorithmIdentifier (pctxt, pvalue);
}

void ASN1C_CMS_KeyEncryptionAlgorithmIdentifier::MemFree ()
{
   asn1Free_CMS_KeyEncryptionAlgorithmIdentifier (getCtxtPtr(), &msgData);
}

ASN1T_CMS_ContentEncryptionAlgorithmIdentifier* 
   new_ASN1T_CMS_ContentEncryptionAlgorithmIdentifier (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_ContentEncryptionAlgorithmIdentifier));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_ContentEncryptionAlgorithmIdentifier;
}

ASN1C_CMS_ContentEncryptionAlgorithmIdentifier::
   ASN1C_CMS_ContentEncryptionAlgorithmIdentifier
    (ASN1T_CMS_ContentEncryptionAlgorithmIdentifier& data) : 
   ASN1C_EXP_AlgorithmIdentifier (data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_ContentEncryptionAlgorithmIdentifier::
   ASN1C_CMS_ContentEncryptionAlgorithmIdentifier (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMS_ContentEncryptionAlgorithmIdentifier& data) : 
   ASN1C_EXP_AlgorithmIdentifier (msgBuf, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_ContentEncryptionAlgorithmIdentifier::
   ASN1C_CMS_ContentEncryptionAlgorithmIdentifier (OSRTContext &context
   , ASN1T_CMS_ContentEncryptionAlgorithmIdentifier& data) : 
   ASN1C_EXP_AlgorithmIdentifier (context, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_CMS_ContentEncryptionAlgorithmIdentifier::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_ContentEncryptionAlgorithmIdentifier (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_ContentEncryptionAlgorithmIdentifier::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_ContentEncryptionAlgorithmIdentifier;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_ContentEncryptionAlgorithmIdentifier (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_ContentEncryptionAlgorithmIdentifier (
   ASN1T_CMS_ContentEncryptionAlgorithmIdentifier* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_ContentEncryptionAlgorithmIdentifier;
}

void asn1Free_CMS_ContentEncryptionAlgorithmIdentifier (OSCTXT *pctxt, 
   ASN1T_CMS_ContentEncryptionAlgorithmIdentifier* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_EXP_AlgorithmIdentifier (pctxt, pvalue);
}

void ASN1C_CMS_ContentEncryptionAlgorithmIdentifier::MemFree ()
{
   asn1Free_CMS_ContentEncryptionAlgorithmIdentifier (getCtxtPtr(), &msgData);
}

ASN1T_CMS_MessageAuthenticationCodeAlgorithm* 
   new_ASN1T_CMS_MessageAuthenticationCodeAlgorithm (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_MessageAuthenticationCodeAlgorithm));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_MessageAuthenticationCodeAlgorithm;
}

ASN1C_CMS_MessageAuthenticationCodeAlgorithm::
   ASN1C_CMS_MessageAuthenticationCodeAlgorithm
    (ASN1T_CMS_MessageAuthenticationCodeAlgorithm& data) : 
   ASN1C_EXP_AlgorithmIdentifier (data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_MessageAuthenticationCodeAlgorithm::
   ASN1C_CMS_MessageAuthenticationCodeAlgorithm (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMS_MessageAuthenticationCodeAlgorithm& data) : 
   ASN1C_EXP_AlgorithmIdentifier (msgBuf, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_MessageAuthenticationCodeAlgorithm::
   ASN1C_CMS_MessageAuthenticationCodeAlgorithm (OSRTContext &context
   , ASN1T_CMS_MessageAuthenticationCodeAlgorithm& data) : 
   ASN1C_EXP_AlgorithmIdentifier (context, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_CMS_MessageAuthenticationCodeAlgorithm::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_MessageAuthenticationCodeAlgorithm (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_MessageAuthenticationCodeAlgorithm::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_MessageAuthenticationCodeAlgorithm;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_MessageAuthenticationCodeAlgorithm (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_MessageAuthenticationCodeAlgorithm (
   ASN1T_CMS_MessageAuthenticationCodeAlgorithm* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_MessageAuthenticationCodeAlgorithm;
}

void asn1Free_CMS_MessageAuthenticationCodeAlgorithm (OSCTXT *pctxt, 
   ASN1T_CMS_MessageAuthenticationCodeAlgorithm* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_EXP_AlgorithmIdentifier (pctxt, pvalue);
}

void ASN1C_CMS_MessageAuthenticationCodeAlgorithm::MemFree ()
{
   asn1Free_CMS_MessageAuthenticationCodeAlgorithm (getCtxtPtr(), &msgData);
}

ASN1T_CMS_KeyDerivationAlgorithmIdentifier* 
   new_ASN1T_CMS_KeyDerivationAlgorithmIdentifier (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_KeyDerivationAlgorithmIdentifier));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_KeyDerivationAlgorithmIdentifier;
}

ASN1C_CMS_KeyDerivationAlgorithmIdentifier::
   ASN1C_CMS_KeyDerivationAlgorithmIdentifier
    (ASN1T_CMS_KeyDerivationAlgorithmIdentifier& data) : 
   ASN1C_EXP_AlgorithmIdentifier (data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_KeyDerivationAlgorithmIdentifier::
   ASN1C_CMS_KeyDerivationAlgorithmIdentifier (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMS_KeyDerivationAlgorithmIdentifier& data) : 
   ASN1C_EXP_AlgorithmIdentifier (msgBuf, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_KeyDerivationAlgorithmIdentifier::
   ASN1C_CMS_KeyDerivationAlgorithmIdentifier (OSRTContext &context
   , ASN1T_CMS_KeyDerivationAlgorithmIdentifier& data) : 
   ASN1C_EXP_AlgorithmIdentifier (context, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_CMS_KeyDerivationAlgorithmIdentifier::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_KeyDerivationAlgorithmIdentifier (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_KeyDerivationAlgorithmIdentifier::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_KeyDerivationAlgorithmIdentifier;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_KeyDerivationAlgorithmIdentifier (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_KeyDerivationAlgorithmIdentifier (
   ASN1T_CMS_KeyDerivationAlgorithmIdentifier* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_KeyDerivationAlgorithmIdentifier;
}

void asn1Free_CMS_KeyDerivationAlgorithmIdentifier (OSCTXT *pctxt, 
   ASN1T_CMS_KeyDerivationAlgorithmIdentifier* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_EXP_AlgorithmIdentifier (pctxt, pvalue);
}

void ASN1C_CMS_KeyDerivationAlgorithmIdentifier::MemFree ()
{
   asn1Free_CMS_KeyDerivationAlgorithmIdentifier (getCtxtPtr(), &msgData);
}

ASN1T_CMS_AttributeCertificateV2* 
   new_ASN1T_CMS_AttributeCertificateV2 (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_AttributeCertificateV2));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_AttributeCertificateV2;
}

ASN1C_CMS_AttributeCertificateV2::ASN1C_CMS_AttributeCertificateV2
    (ASN1T_CMS_AttributeCertificateV2& data) : 
   ASN1C_ATTRCERT_AttributeCertificate (data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_AttributeCertificateV2::ASN1C_CMS_AttributeCertificateV2 (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_AttributeCertificateV2& data) : 
   ASN1C_ATTRCERT_AttributeCertificate (msgBuf, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_AttributeCertificateV2::ASN1C_CMS_AttributeCertificateV2 (
   OSRTContext &context, ASN1T_CMS_AttributeCertificateV2& data) : 
   ASN1C_ATTRCERT_AttributeCertificate (context, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_CMS_AttributeCertificateV2::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_AttributeCertificateV2 (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_AttributeCertificateV2::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_AttributeCertificateV2;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_AttributeCertificateV2 (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_AttributeCertificateV2 (
   ASN1T_CMS_AttributeCertificateV2* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_AttributeCertificateV2;
}

void asn1Free_CMS_AttributeCertificateV2 (OSCTXT *pctxt, 
   ASN1T_CMS_AttributeCertificateV2* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_ATTRCERT_AttributeCertificate (pctxt, pvalue);
}

void ASN1C_CMS_AttributeCertificateV2::MemFree ()
{
   asn1Free_CMS_AttributeCertificateV2 (getCtxtPtr(), &msgData);
}

ASN1T_CMS_CMSVersion* new_ASN1T_CMS_CMSVersion (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_CMSVersion));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_CMSVersion;
}

ASN1C_CMS_CMSVersion::ASN1C_CMS_CMSVersion (ASN1T_CMS_CMSVersion& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_CMSVersion::ASN1C_CMS_CMSVersion (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMS_CMSVersion& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_CMSVersion::ASN1C_CMS_CMSVersion (OSRTContext &context
   , ASN1T_CMS_CMSVersion& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_CMS_CMSVersion::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_CMSVersion (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_CMSVersion::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_CMS_CMSVersion (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

ASN1T_CMS_UserKeyingMaterial* 
   new_ASN1T_CMS_UserKeyingMaterial (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_UserKeyingMaterial));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_UserKeyingMaterial;
}

ASN1C_CMS_UserKeyingMaterial::ASN1C_CMS_UserKeyingMaterial
    (ASN1T_CMS_UserKeyingMaterial& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_UserKeyingMaterial::ASN1C_CMS_UserKeyingMaterial (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_UserKeyingMaterial& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_UserKeyingMaterial::ASN1C_CMS_UserKeyingMaterial (
   OSRTContext &context, ASN1T_CMS_UserKeyingMaterial& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_CMS_UserKeyingMaterial::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_UserKeyingMaterial (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_UserKeyingMaterial::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_CMS_UserKeyingMaterial (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_UserKeyingMaterial (ASN1T_CMS_UserKeyingMaterial* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_UserKeyingMaterial;
}

void asn1Free_CMS_UserKeyingMaterial (OSCTXT *pctxt, 
   ASN1T_CMS_UserKeyingMaterial* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

void ASN1C_CMS_UserKeyingMaterial::MemFree ()
{
   asn1Free_CMS_UserKeyingMaterial (getCtxtPtr(), &msgData);
}

ASN1T_CMS_MessageDigest* new_ASN1T_CMS_MessageDigest (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_MessageDigest));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_MessageDigest;
}

ASN1C_CMS_MessageDigest::ASN1C_CMS_MessageDigest
    (ASN1T_CMS_MessageDigest& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_MessageDigest::ASN1C_CMS_MessageDigest (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMS_MessageDigest& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_MessageDigest::ASN1C_CMS_MessageDigest (OSRTContext &context
   , ASN1T_CMS_MessageDigest& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_CMS_MessageDigest::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_MessageDigest (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_MessageDigest::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_CMS_MessageDigest (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_MessageDigest (ASN1T_CMS_MessageDigest* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_MessageDigest;
}

void asn1Free_CMS_MessageDigest (OSCTXT *pctxt, 
   ASN1T_CMS_MessageDigest* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

void ASN1C_CMS_MessageDigest::MemFree ()
{
   asn1Free_CMS_MessageDigest (getCtxtPtr(), &msgData);
}

ASN1T_CMS_SignerIdentifier* new_ASN1T_CMS_SignerIdentifier (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_SignerIdentifier));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_SignerIdentifier;
}

ASN1C_CMS_SignerIdentifier::ASN1C_CMS_SignerIdentifier
    (ASN1T_CMS_SignerIdentifier& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_SignerIdentifier::ASN1C_CMS_SignerIdentifier (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_SignerIdentifier& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_SignerIdentifier::ASN1C_CMS_SignerIdentifier (OSRTContext &context
   , ASN1T_CMS_SignerIdentifier& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_SignerIdentifier::~ASN1T_CMS_SignerIdentifier ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_SignerIdentifier (pctxt, this);
   }
}

int ASN1C_CMS_SignerIdentifier::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_SignerIdentifier (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_SignerIdentifier::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_SignerIdentifier;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_SignerIdentifier (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_SignerIdentifier (ASN1T_CMS_SignerIdentifier* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_SignerIdentifier;
}

void asn1Free_CMS_SignerIdentifier (OSCTXT *pctxt, 
   ASN1T_CMS_SignerIdentifier* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.issuerAndSerialNumber) {
            asn1Free_PKCS7_IssuerAndSerialNumber (pctxt, pvalue->u.issuerAndSerialNumber);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.issuerAndSerialNumber);
         }
         break;

      case 2:
         if (0 != pvalue->u.subjectKeyIdentifier) {
            asn1Free_CMS_SubjectKeyIdentifier (pctxt, pvalue->u.subjectKeyIdentifier);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.subjectKeyIdentifier);
         }
         break;

   }
}

void ASN1C_CMS_SignerIdentifier::MemFree ()
{
   asn1Free_CMS_SignerIdentifier (getCtxtPtr(), &msgData);
}

ASN1C_CMS_UnsignedAttributes::ASN1C_CMS_UnsignedAttributes
    (ASN1T_CMS_UnsignedAttributes& data) : ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_UnsignedAttributes::ASN1C_CMS_UnsignedAttributes (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_UnsignedAttributes& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_UnsignedAttributes::ASN1C_CMS_UnsignedAttributes (
   OSRTContext &context, ASN1T_CMS_UnsignedAttributes& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CMS_UnsignedAttributes::ASN1C_CMS_UnsignedAttributes (ASN1CType& ccobj
   , ASN1T_CMS_UnsignedAttributes& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CMS_UnsignedAttributes::Append (ASN1T_EXP_Attribute* elem)
{
   append ((void*)elem);
}

ASN1T_EXP_Attribute* ASN1C_CMS_UnsignedAttributes::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_EXP_Attribute));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_EXP_Attribute;
}

ASN1T_EXP_Attribute* ASN1C_CMS_UnsignedAttributes::AppendNewElement ()
{
   ASN1T_EXP_Attribute* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CMS_UnsignedAttributes::~ASN1T_CMS_UnsignedAttributes ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_UnsignedAttributes (pctxt, this);
   }
}

int ASN1C_CMS_UnsignedAttributes::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_UnsignedAttributes (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_UnsignedAttributes::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_UnsignedAttributes;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_UnsignedAttributes (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_UnsignedAttributes (ASN1T_CMS_UnsignedAttributes* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_UnsignedAttributes;
   rtxDListFastInit (pvalue);
}

void asn1Free_CMS_UnsignedAttributes (OSCTXT *pctxt, 
   ASN1T_CMS_UnsignedAttributes* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_EXP_Attribute* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_EXP_Attribute*)pnode->data;
      asn1Free_EXP_Attribute (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CMS_UnsignedAttributes::MemFree ()
{
   asn1Free_CMS_UnsignedAttributes (getCtxtPtr(), &msgData);
}

ASN1T_CMS_SignerInfo* new_ASN1T_CMS_SignerInfo (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_SignerInfo));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_SignerInfo;
}

ASN1C_CMS_SignerInfo::ASN1C_CMS_SignerInfo (ASN1T_CMS_SignerInfo& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_SignerInfo::ASN1C_CMS_SignerInfo (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMS_SignerInfo& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_SignerInfo::ASN1C_CMS_SignerInfo (OSRTContext &context
   , ASN1T_CMS_SignerInfo& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_SignerInfo::ASN1T_CMS_SignerInfo ()
{
   m.signedAttrsPresent = 0;
   m.unsignedAttrsPresent = 0;
}

ASN1T_CMS_SignerInfo::~ASN1T_CMS_SignerInfo ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_SignerInfo (pctxt, this);
   }
}

int ASN1C_CMS_SignerInfo::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_SignerInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_SignerInfo::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_SignerInfo;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_SignerInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_SignerInfo (ASN1T_CMS_SignerInfo* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_SignerInfo;
}

void asn1Free_CMS_SignerInfo (OSCTXT *pctxt, ASN1T_CMS_SignerInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_CMS_SignerIdentifier (pctxt, &pvalue->sid);
   asn1Free_CMS_DigestAlgorithmIdentifier (pctxt, &pvalue->digestAlgorithm);
   if (pvalue->m.signedAttrsPresent) {
      asn1Free_DERCMS_SignedAttributes (pctxt, &pvalue->signedAttrs);
   }
   asn1Free_CMS_SignatureAlgorithmIdentifier (pctxt, &pvalue->signatureAlgorithm);
   asn1Free_DERCMS_SignatureValue (pctxt, &pvalue->signature_);
   if (pvalue->m.unsignedAttrsPresent) {
      asn1Free_CMS_UnsignedAttributes (pctxt, &pvalue->unsignedAttrs);
   }
}

void ASN1C_CMS_SignerInfo::MemFree ()
{
   asn1Free_CMS_SignerInfo (getCtxtPtr(), &msgData);
}

ASN1T_CMS_Countersignature* new_ASN1T_CMS_Countersignature (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_Countersignature));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_Countersignature;
}

ASN1C_CMS_Countersignature::ASN1C_CMS_Countersignature
    (ASN1T_CMS_Countersignature& data) : ASN1C_CMS_SignerInfo (data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_Countersignature::ASN1C_CMS_Countersignature (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_Countersignature& data) : 
   ASN1C_CMS_SignerInfo (msgBuf, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_Countersignature::ASN1C_CMS_Countersignature (OSRTContext &context
   , ASN1T_CMS_Countersignature& data) : ASN1C_CMS_SignerInfo (context, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_CMS_Countersignature::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_Countersignature (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_Countersignature::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_Countersignature;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_Countersignature (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_Countersignature (ASN1T_CMS_Countersignature* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_Countersignature;
}

void asn1Free_CMS_Countersignature (OSCTXT *pctxt, 
   ASN1T_CMS_Countersignature* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_CMS_SignerInfo (pctxt, pvalue);
}

void ASN1C_CMS_Countersignature::MemFree ()
{
   asn1Free_CMS_Countersignature (getCtxtPtr(), &msgData);
}

ASN1T_CMS_Signature* new_ASN1T_CMS_Signature (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_Signature));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_Signature;
}

ASN1C_CMS_Signature::ASN1C_CMS_Signature (ASN1T_CMS_Signature& data) : 
   ASN1CBitStr (data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_Signature::ASN1C_CMS_Signature (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMS_Signature& data) : ASN1CBitStr (msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_Signature::ASN1C_CMS_Signature (OSRTContext &context
   , ASN1T_CMS_Signature& data) : ASN1CBitStr (context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_CMS_Signature::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_Signature (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_Signature::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_CMS_Signature (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_Signature (ASN1T_CMS_Signature* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_Signature;
}

void asn1Free_CMS_Signature (OSCTXT *pctxt, ASN1T_CMS_Signature* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numbits > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numbits = 0;
      pvalue->data = 0;
   }
}

void ASN1C_CMS_Signature::MemFree ()
{
   asn1Free_CMS_Signature (getCtxtPtr(), &msgData);
}

ASN1T_CMS_ContentInfo* new_ASN1T_CMS_ContentInfo (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_ContentInfo));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_ContentInfo;
}

ASN1C_CMS_ContentInfo::ASN1C_CMS_ContentInfo (ASN1T_CMS_ContentInfo& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_ContentInfo::ASN1C_CMS_ContentInfo (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMS_ContentInfo& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_ContentInfo::ASN1C_CMS_ContentInfo (OSRTContext &context
   , ASN1T_CMS_ContentInfo& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_ContentInfo::ASN1T_CMS_ContentInfo ()
{
}

ASN1T_CMS_ContentInfo::~ASN1T_CMS_ContentInfo ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_ContentInfo (pctxt, this);
   }
}

int ASN1C_CMS_ContentInfo::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_ContentInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_ContentInfo::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_ContentInfo;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_ContentInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_ContentInfo (ASN1T_CMS_ContentInfo* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_ContentInfo;
}

void asn1Free_CMS_ContentInfo (OSCTXT *pctxt, ASN1T_CMS_ContentInfo* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreePtr (pctxt, (void*)pvalue->content.data);
}

void ASN1C_CMS_ContentInfo::MemFree ()
{
   asn1Free_CMS_ContentInfo (getCtxtPtr(), &msgData);
}

ASN1T_CMS_EncapsulatedContentInfo* 
   new_ASN1T_CMS_EncapsulatedContentInfo (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_EncapsulatedContentInfo));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_EncapsulatedContentInfo;
}

ASN1C_CMS_EncapsulatedContentInfo::ASN1C_CMS_EncapsulatedContentInfo
    (ASN1T_CMS_EncapsulatedContentInfo& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_EncapsulatedContentInfo::ASN1C_CMS_EncapsulatedContentInfo (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_EncapsulatedContentInfo& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_EncapsulatedContentInfo::ASN1C_CMS_EncapsulatedContentInfo (
   OSRTContext &context, ASN1T_CMS_EncapsulatedContentInfo& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_EncapsulatedContentInfo::ASN1T_CMS_EncapsulatedContentInfo ()
{
   m.eContentPresent = 0;
}

ASN1T_CMS_EncapsulatedContentInfo::~ASN1T_CMS_EncapsulatedContentInfo ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_EncapsulatedContentInfo (pctxt, this);
   }
}

int ASN1C_CMS_EncapsulatedContentInfo::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_EncapsulatedContentInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_EncapsulatedContentInfo::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_EncapsulatedContentInfo;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_EncapsulatedContentInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_EncapsulatedContentInfo (
   ASN1T_CMS_EncapsulatedContentInfo* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_EncapsulatedContentInfo;
}

void asn1Free_CMS_EncapsulatedContentInfo (OSCTXT *pctxt, 
   ASN1T_CMS_EncapsulatedContentInfo* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.eContentPresent) {
      if (pvalue->eContent.numocts > 0) {
         rtxMemFreePtr (pctxt, (void*)pvalue->eContent.data);
         pvalue->eContent.numocts = 0;
         pvalue->eContent.data = 0;
      }
   }
}

void ASN1C_CMS_EncapsulatedContentInfo::MemFree ()
{
   asn1Free_CMS_EncapsulatedContentInfo (getCtxtPtr(), &msgData);
}

ASN1C_CMS_UnauthAttributes::ASN1C_CMS_UnauthAttributes
    (ASN1T_CMS_UnauthAttributes& data) : ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_UnauthAttributes::ASN1C_CMS_UnauthAttributes (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_UnauthAttributes& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_UnauthAttributes::ASN1C_CMS_UnauthAttributes (OSRTContext &context
   , ASN1T_CMS_UnauthAttributes& data) : ASN1CSeqOfList(context, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CMS_UnauthAttributes::ASN1C_CMS_UnauthAttributes (ASN1CType& ccobj
   , ASN1T_CMS_UnauthAttributes& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CMS_UnauthAttributes::Append (ASN1T_EXP_Attribute* elem)
{
   append ((void*)elem);
}

ASN1T_EXP_Attribute* ASN1C_CMS_UnauthAttributes::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_EXP_Attribute));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_EXP_Attribute;
}

ASN1T_EXP_Attribute* ASN1C_CMS_UnauthAttributes::AppendNewElement ()
{
   ASN1T_EXP_Attribute* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CMS_UnauthAttributes::~ASN1T_CMS_UnauthAttributes ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_UnauthAttributes (pctxt, this);
   }
}

int ASN1C_CMS_UnauthAttributes::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_UnauthAttributes (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_UnauthAttributes::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_UnauthAttributes;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_UnauthAttributes (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_UnauthAttributes (ASN1T_CMS_UnauthAttributes* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_UnauthAttributes;
   rtxDListFastInit (pvalue);
}

void asn1Free_CMS_UnauthAttributes (OSCTXT *pctxt, 
   ASN1T_CMS_UnauthAttributes* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_EXP_Attribute* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_EXP_Attribute*)pnode->data;
      asn1Free_EXP_Attribute (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CMS_UnauthAttributes::MemFree ()
{
   asn1Free_CMS_UnauthAttributes (getCtxtPtr(), &msgData);
}

ASN1T_CMS_ExtendedCertificateInfo* 
   new_ASN1T_CMS_ExtendedCertificateInfo (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_ExtendedCertificateInfo));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_ExtendedCertificateInfo;
}

ASN1C_CMS_ExtendedCertificateInfo::ASN1C_CMS_ExtendedCertificateInfo
    (ASN1T_CMS_ExtendedCertificateInfo& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_ExtendedCertificateInfo::ASN1C_CMS_ExtendedCertificateInfo (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_ExtendedCertificateInfo& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_ExtendedCertificateInfo::ASN1C_CMS_ExtendedCertificateInfo (
   OSRTContext &context, ASN1T_CMS_ExtendedCertificateInfo& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_ExtendedCertificateInfo::ASN1T_CMS_ExtendedCertificateInfo ()
{
}

ASN1T_CMS_ExtendedCertificateInfo::~ASN1T_CMS_ExtendedCertificateInfo ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_ExtendedCertificateInfo (pctxt, this);
   }
}

int ASN1C_CMS_ExtendedCertificateInfo::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_ExtendedCertificateInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_ExtendedCertificateInfo::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_ExtendedCertificateInfo;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_ExtendedCertificateInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_ExtendedCertificateInfo (
   ASN1T_CMS_ExtendedCertificateInfo* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_ExtendedCertificateInfo;
}

void asn1Free_CMS_ExtendedCertificateInfo (OSCTXT *pctxt, 
   ASN1T_CMS_ExtendedCertificateInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_EXP_Certificate (pctxt, &pvalue->certificate);
   asn1Free_CMS_UnauthAttributes (pctxt, &pvalue->attributes);
}

void ASN1C_CMS_ExtendedCertificateInfo::MemFree ()
{
   asn1Free_CMS_ExtendedCertificateInfo (getCtxtPtr(), &msgData);
}

ASN1T_CMS_ExtendedCertificate* 
   new_ASN1T_CMS_ExtendedCertificate (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_ExtendedCertificate));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_ExtendedCertificate;
}

ASN1C_CMS_ExtendedCertificate::ASN1C_CMS_ExtendedCertificate
    (ASN1T_CMS_ExtendedCertificate& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_ExtendedCertificate::ASN1C_CMS_ExtendedCertificate (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_ExtendedCertificate& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_ExtendedCertificate::ASN1C_CMS_ExtendedCertificate (
   OSRTContext &context, ASN1T_CMS_ExtendedCertificate& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_ExtendedCertificate::ASN1T_CMS_ExtendedCertificate ()
{
}

ASN1T_CMS_ExtendedCertificate::~ASN1T_CMS_ExtendedCertificate ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_ExtendedCertificate (pctxt, this);
   }
}

int ASN1C_CMS_ExtendedCertificate::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_ExtendedCertificate (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_ExtendedCertificate::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_ExtendedCertificate;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_ExtendedCertificate (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_ExtendedCertificate (ASN1T_CMS_ExtendedCertificate* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_ExtendedCertificate;
}

void asn1Free_CMS_ExtendedCertificate (OSCTXT *pctxt, 
   ASN1T_CMS_ExtendedCertificate* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_CMS_ExtendedCertificateInfo (pctxt, &pvalue->extendedCertificateInfo);
   asn1Free_CMS_SignatureAlgorithmIdentifier (pctxt, &pvalue->signatureAlgorithm);
   asn1Free_CMS_Signature (pctxt, &pvalue->signature_);
}

void ASN1C_CMS_ExtendedCertificate::MemFree ()
{
   asn1Free_CMS_ExtendedCertificate (getCtxtPtr(), &msgData);
}

ASN1T_CMS_OtherCertificateFormat* 
   new_ASN1T_CMS_OtherCertificateFormat (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_OtherCertificateFormat));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_OtherCertificateFormat;
}

ASN1C_CMS_OtherCertificateFormat::ASN1C_CMS_OtherCertificateFormat
    (ASN1T_CMS_OtherCertificateFormat& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_OtherCertificateFormat::ASN1C_CMS_OtherCertificateFormat (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_OtherCertificateFormat& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_OtherCertificateFormat::ASN1C_CMS_OtherCertificateFormat (
   OSRTContext &context, ASN1T_CMS_OtherCertificateFormat& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_OtherCertificateFormat::ASN1T_CMS_OtherCertificateFormat ()
{
}

ASN1T_CMS_OtherCertificateFormat::~ASN1T_CMS_OtherCertificateFormat ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_OtherCertificateFormat (pctxt, this);
   }
}

int ASN1C_CMS_OtherCertificateFormat::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_OtherCertificateFormat (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_OtherCertificateFormat::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_OtherCertificateFormat;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_OtherCertificateFormat (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_OtherCertificateFormat (
   ASN1T_CMS_OtherCertificateFormat* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_OtherCertificateFormat;
}

void asn1Free_CMS_OtherCertificateFormat (OSCTXT *pctxt, 
   ASN1T_CMS_OtherCertificateFormat* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreePtr (pctxt, (void*)pvalue->otherCert.data);
}

void ASN1C_CMS_OtherCertificateFormat::MemFree ()
{
   asn1Free_CMS_OtherCertificateFormat (getCtxtPtr(), &msgData);
}

ASN1T_CMS_CertificateChoices* 
   new_ASN1T_CMS_CertificateChoices (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_CertificateChoices));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_CertificateChoices;
}

ASN1C_CMS_CertificateChoices::ASN1C_CMS_CertificateChoices
    (ASN1T_CMS_CertificateChoices& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_CertificateChoices::ASN1C_CMS_CertificateChoices (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_CertificateChoices& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_CertificateChoices::ASN1C_CMS_CertificateChoices (
   OSRTContext &context, ASN1T_CMS_CertificateChoices& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_CertificateChoices::~ASN1T_CMS_CertificateChoices ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_CertificateChoices (pctxt, this);
   }
}

int ASN1C_CMS_CertificateChoices::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_CertificateChoices (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_CertificateChoices::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_CertificateChoices;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_CertificateChoices (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_CertificateChoices (ASN1T_CMS_CertificateChoices* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_CertificateChoices;
}

void asn1Free_CMS_CertificateChoices (OSCTXT *pctxt, 
   ASN1T_CMS_CertificateChoices* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.certificate) {
            asn1Free_EXP_Certificate (pctxt, pvalue->u.certificate);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.certificate);
         }
         break;

      case 2:
         if (0 != pvalue->u.extendedCertificate) {
            asn1Free_CMS_ExtendedCertificate (pctxt, pvalue->u.extendedCertificate);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extendedCertificate);
         }
         break;

      case 3:
         if (0 != pvalue->u.v1AttrCert) {
            asn1Free_ATTRCERT_AttributeCertificateV1 (pctxt, pvalue->u.v1AttrCert);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.v1AttrCert);
         }
         break;

      case 4:
         if (0 != pvalue->u.v2AttrCert) {
            asn1Free_CMS_AttributeCertificateV2 (pctxt, pvalue->u.v2AttrCert);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.v2AttrCert);
         }
         break;

      case 5:
         if (0 != pvalue->u.other) {
            asn1Free_CMS_OtherCertificateFormat (pctxt, pvalue->u.other);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.other);
         }
         break;

   }
}

void ASN1C_CMS_CertificateChoices::MemFree ()
{
   asn1Free_CMS_CertificateChoices (getCtxtPtr(), &msgData);
}

ASN1C_CMS_CertificateSet::ASN1C_CMS_CertificateSet
    (ASN1T_CMS_CertificateSet& data) : ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_CertificateSet::ASN1C_CMS_CertificateSet (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMS_CertificateSet& data) : ASN1CSeqOfList(msgBuf, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_CertificateSet::ASN1C_CMS_CertificateSet (OSRTContext &context
   , ASN1T_CMS_CertificateSet& data) : ASN1CSeqOfList(context, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CMS_CertificateSet::ASN1C_CMS_CertificateSet (ASN1CType& ccobj
   , ASN1T_CMS_CertificateSet& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CMS_CertificateSet::Append (ASN1T_CMS_CertificateChoices* elem)
{
   append ((void*)elem);
}

ASN1T_CMS_CertificateChoices* ASN1C_CMS_CertificateSet::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_CMS_CertificateChoices));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_CertificateChoices;
}

ASN1T_CMS_CertificateChoices* ASN1C_CMS_CertificateSet::AppendNewElement ()
{
   ASN1T_CMS_CertificateChoices* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CMS_CertificateSet::~ASN1T_CMS_CertificateSet ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_CertificateSet (pctxt, this);
   }
}

int ASN1C_CMS_CertificateSet::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_CertificateSet (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_CertificateSet::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_CertificateSet;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_CertificateSet (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_CertificateSet (ASN1T_CMS_CertificateSet* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_CertificateSet;
   rtxDListFastInit (pvalue);
}

void asn1Free_CMS_CertificateSet (OSCTXT *pctxt, 
   ASN1T_CMS_CertificateSet* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_CMS_CertificateChoices* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_CMS_CertificateChoices*)pnode->data;
      asn1Free_CMS_CertificateChoices (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CMS_CertificateSet::MemFree ()
{
   asn1Free_CMS_CertificateSet (getCtxtPtr(), &msgData);
}

ASN1T_CMS_OtherRevocationInfoFormat* 
   new_ASN1T_CMS_OtherRevocationInfoFormat (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_OtherRevocationInfoFormat));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_OtherRevocationInfoFormat;
}

ASN1C_CMS_OtherRevocationInfoFormat::ASN1C_CMS_OtherRevocationInfoFormat
    (ASN1T_CMS_OtherRevocationInfoFormat& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_OtherRevocationInfoFormat::ASN1C_CMS_OtherRevocationInfoFormat (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_OtherRevocationInfoFormat& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_OtherRevocationInfoFormat::ASN1C_CMS_OtherRevocationInfoFormat (
   OSRTContext &context, ASN1T_CMS_OtherRevocationInfoFormat& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_OtherRevocationInfoFormat::ASN1T_CMS_OtherRevocationInfoFormat ()
{
}

ASN1T_CMS_OtherRevocationInfoFormat::~ASN1T_CMS_OtherRevocationInfoFormat ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_OtherRevocationInfoFormat (pctxt, this);
   }
}

int ASN1C_CMS_OtherRevocationInfoFormat::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_OtherRevocationInfoFormat (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_OtherRevocationInfoFormat::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_OtherRevocationInfoFormat;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_OtherRevocationInfoFormat (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_OtherRevocationInfoFormat (
   ASN1T_CMS_OtherRevocationInfoFormat* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_OtherRevocationInfoFormat;
}

void asn1Free_CMS_OtherRevocationInfoFormat (OSCTXT *pctxt, 
   ASN1T_CMS_OtherRevocationInfoFormat* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreePtr (pctxt, (void*)pvalue->otherRevInfo.data);
}

void ASN1C_CMS_OtherRevocationInfoFormat::MemFree ()
{
   asn1Free_CMS_OtherRevocationInfoFormat (getCtxtPtr(), &msgData);
}

ASN1T_CMS_RevocationInfoChoice* 
   new_ASN1T_CMS_RevocationInfoChoice (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_RevocationInfoChoice));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_RevocationInfoChoice;
}

ASN1C_CMS_RevocationInfoChoice::ASN1C_CMS_RevocationInfoChoice
    (ASN1T_CMS_RevocationInfoChoice& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_RevocationInfoChoice::ASN1C_CMS_RevocationInfoChoice (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_RevocationInfoChoice& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_RevocationInfoChoice::ASN1C_CMS_RevocationInfoChoice (
   OSRTContext &context, ASN1T_CMS_RevocationInfoChoice& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_RevocationInfoChoice::~ASN1T_CMS_RevocationInfoChoice ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_RevocationInfoChoice (pctxt, this);
   }
}

int ASN1C_CMS_RevocationInfoChoice::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_RevocationInfoChoice (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_RevocationInfoChoice::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_RevocationInfoChoice;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_RevocationInfoChoice (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_RevocationInfoChoice (ASN1T_CMS_RevocationInfoChoice* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_RevocationInfoChoice;
}

void asn1Free_CMS_RevocationInfoChoice (OSCTXT *pctxt, 
   ASN1T_CMS_RevocationInfoChoice* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.crl) {
            asn1Free_EXP_CertificateList (pctxt, pvalue->u.crl);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.crl);
         }
         break;

      case 2:
         if (0 != pvalue->u.other) {
            asn1Free_CMS_OtherRevocationInfoFormat (pctxt, pvalue->u.other);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.other);
         }
         break;

   }
}

void ASN1C_CMS_RevocationInfoChoice::MemFree ()
{
   asn1Free_CMS_RevocationInfoChoice (getCtxtPtr(), &msgData);
}

ASN1C_CMS_RevocationInfoChoices::ASN1C_CMS_RevocationInfoChoices
    (ASN1T_CMS_RevocationInfoChoices& data) : ASN1CSeqOfList(data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_RevocationInfoChoices::ASN1C_CMS_RevocationInfoChoices (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_RevocationInfoChoices& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_RevocationInfoChoices::ASN1C_CMS_RevocationInfoChoices (
   OSRTContext &context, ASN1T_CMS_RevocationInfoChoices& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CMS_RevocationInfoChoices::
   ASN1C_CMS_RevocationInfoChoices (ASN1CType& ccobj
   , ASN1T_CMS_RevocationInfoChoices& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CMS_RevocationInfoChoices::Append (ASN1T_CMS_RevocationInfoChoice* elem)
{
   append ((void*)elem);
}

ASN1T_CMS_RevocationInfoChoice* ASN1C_CMS_RevocationInfoChoices::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_CMS_RevocationInfoChoice));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_RevocationInfoChoice;
}

ASN1T_CMS_RevocationInfoChoice* ASN1C_CMS_RevocationInfoChoices::AppendNewElement ()
{
   ASN1T_CMS_RevocationInfoChoice* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CMS_RevocationInfoChoices::~ASN1T_CMS_RevocationInfoChoices ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_RevocationInfoChoices (pctxt, this);
   }
}

int ASN1C_CMS_RevocationInfoChoices::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_RevocationInfoChoices (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_RevocationInfoChoices::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_RevocationInfoChoices;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_RevocationInfoChoices (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_RevocationInfoChoices (
   ASN1T_CMS_RevocationInfoChoices* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_RevocationInfoChoices;
   rtxDListFastInit (pvalue);
}

void asn1Free_CMS_RevocationInfoChoices (OSCTXT *pctxt, 
   ASN1T_CMS_RevocationInfoChoices* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_CMS_RevocationInfoChoice* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_CMS_RevocationInfoChoice*)pnode->data;
      asn1Free_CMS_RevocationInfoChoice (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CMS_RevocationInfoChoices::MemFree ()
{
   asn1Free_CMS_RevocationInfoChoices (getCtxtPtr(), &msgData);
}

ASN1C_CMS_SignerInfos::ASN1C_CMS_SignerInfos (ASN1T_CMS_SignerInfos& data) : 
   ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_SignerInfos::ASN1C_CMS_SignerInfos (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMS_SignerInfos& data) : ASN1CSeqOfList(msgBuf, data), msgData(data)
   
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_SignerInfos::ASN1C_CMS_SignerInfos (OSRTContext &context
   , ASN1T_CMS_SignerInfos& data) : ASN1CSeqOfList(context, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CMS_SignerInfos::ASN1C_CMS_SignerInfos (ASN1CType& ccobj
   , ASN1T_CMS_SignerInfos& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CMS_SignerInfos::Append (ASN1T_CMS_SignerInfo* elem)
{
   append ((void*)elem);
}

ASN1T_CMS_SignerInfo* ASN1C_CMS_SignerInfos::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_CMS_SignerInfo));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_SignerInfo;
}

ASN1T_CMS_SignerInfo* ASN1C_CMS_SignerInfos::AppendNewElement ()
{
   ASN1T_CMS_SignerInfo* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CMS_SignerInfos::~ASN1T_CMS_SignerInfos ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_SignerInfos (pctxt, this);
   }
}

int ASN1C_CMS_SignerInfos::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_SignerInfos (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_SignerInfos::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_SignerInfos;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_SignerInfos (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_SignerInfos (ASN1T_CMS_SignerInfos* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_SignerInfos;
   rtxDListFastInit (pvalue);
}

void asn1Free_CMS_SignerInfos (OSCTXT *pctxt, ASN1T_CMS_SignerInfos* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_CMS_SignerInfo* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_CMS_SignerInfo*)pnode->data;
      asn1Free_CMS_SignerInfo (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CMS_SignerInfos::MemFree ()
{
   asn1Free_CMS_SignerInfos (getCtxtPtr(), &msgData);
}

ASN1T_CMS_SignedData* new_ASN1T_CMS_SignedData (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_SignedData));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_SignedData;
}

ASN1C_CMS_SignedData::ASN1C_CMS_SignedData (ASN1T_CMS_SignedData& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_SignedData::ASN1C_CMS_SignedData (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMS_SignedData& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_SignedData::ASN1C_CMS_SignedData (OSRTContext &context
   , ASN1T_CMS_SignedData& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_SignedData::ASN1T_CMS_SignedData ()
{
   m.certificatesPresent = 0;
   m.crlsPresent = 0;
}

ASN1T_CMS_SignedData::~ASN1T_CMS_SignedData ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_SignedData (pctxt, this);
   }
}

int ASN1C_CMS_SignedData::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_SignedData (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_SignedData::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_SignedData;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_SignedData (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_SignedData (ASN1T_CMS_SignedData* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_SignedData;
}

void asn1Free_CMS_SignedData (OSCTXT *pctxt, ASN1T_CMS_SignedData* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_PKCS7_DigestAlgorithmIdentifiers (pctxt, &pvalue->digestAlgorithms);
   asn1Free_CMS_EncapsulatedContentInfo (pctxt, &pvalue->encapContentInfo);
   if (pvalue->m.certificatesPresent) {
      asn1Free_CMS_CertificateSet (pctxt, &pvalue->certificates);
   }
   if (pvalue->m.crlsPresent) {
      asn1Free_CMS_RevocationInfoChoices (pctxt, &pvalue->crls);
   }
   asn1Free_CMS_SignerInfos (pctxt, &pvalue->signerInfos);
}

void ASN1C_CMS_SignedData::MemFree ()
{
   asn1Free_CMS_SignedData (getCtxtPtr(), &msgData);
}

ASN1T_CMS_OriginatorInfo* new_ASN1T_CMS_OriginatorInfo (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_OriginatorInfo));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_OriginatorInfo;
}

ASN1C_CMS_OriginatorInfo::ASN1C_CMS_OriginatorInfo
    (ASN1T_CMS_OriginatorInfo& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_OriginatorInfo::ASN1C_CMS_OriginatorInfo (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMS_OriginatorInfo& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_OriginatorInfo::ASN1C_CMS_OriginatorInfo (OSRTContext &context
   , ASN1T_CMS_OriginatorInfo& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_OriginatorInfo::ASN1T_CMS_OriginatorInfo ()
{
   m.certsPresent = 0;
   m.crlsPresent = 0;
}

ASN1T_CMS_OriginatorInfo::~ASN1T_CMS_OriginatorInfo ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_OriginatorInfo (pctxt, this);
   }
}

int ASN1C_CMS_OriginatorInfo::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_OriginatorInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_OriginatorInfo::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_OriginatorInfo;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_OriginatorInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_OriginatorInfo (ASN1T_CMS_OriginatorInfo* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_OriginatorInfo;
}

void asn1Free_CMS_OriginatorInfo (OSCTXT *pctxt, 
   ASN1T_CMS_OriginatorInfo* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.certsPresent) {
      asn1Free_CMS_CertificateSet (pctxt, &pvalue->certs);
   }
   if (pvalue->m.crlsPresent) {
      asn1Free_CMS_RevocationInfoChoices (pctxt, &pvalue->crls);
   }
}

void ASN1C_CMS_OriginatorInfo::MemFree ()
{
   asn1Free_CMS_OriginatorInfo (getCtxtPtr(), &msgData);
}

ASN1T_CMS_RecipientIdentifier* 
   new_ASN1T_CMS_RecipientIdentifier (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_RecipientIdentifier));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_RecipientIdentifier;
}

ASN1C_CMS_RecipientIdentifier::ASN1C_CMS_RecipientIdentifier
    (ASN1T_CMS_RecipientIdentifier& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_RecipientIdentifier::ASN1C_CMS_RecipientIdentifier (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_RecipientIdentifier& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_RecipientIdentifier::ASN1C_CMS_RecipientIdentifier (
   OSRTContext &context, ASN1T_CMS_RecipientIdentifier& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_RecipientIdentifier::~ASN1T_CMS_RecipientIdentifier ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_RecipientIdentifier (pctxt, this);
   }
}

int ASN1C_CMS_RecipientIdentifier::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_RecipientIdentifier (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_RecipientIdentifier::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_RecipientIdentifier;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_RecipientIdentifier (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_RecipientIdentifier (ASN1T_CMS_RecipientIdentifier* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_RecipientIdentifier;
}

void asn1Free_CMS_RecipientIdentifier (OSCTXT *pctxt, 
   ASN1T_CMS_RecipientIdentifier* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.issuerAndSerialNumber) {
            asn1Free_PKCS7_IssuerAndSerialNumber (pctxt, pvalue->u.issuerAndSerialNumber);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.issuerAndSerialNumber);
         }
         break;

      case 2:
         if (0 != pvalue->u.subjectKeyIdentifier) {
            asn1Free_CMS_SubjectKeyIdentifier (pctxt, pvalue->u.subjectKeyIdentifier);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.subjectKeyIdentifier);
         }
         break;

   }
}

void ASN1C_CMS_RecipientIdentifier::MemFree ()
{
   asn1Free_CMS_RecipientIdentifier (getCtxtPtr(), &msgData);
}

ASN1T_CMS_KeyTransRecipientInfo* 
   new_ASN1T_CMS_KeyTransRecipientInfo (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_KeyTransRecipientInfo));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_KeyTransRecipientInfo;
}

ASN1C_CMS_KeyTransRecipientInfo::ASN1C_CMS_KeyTransRecipientInfo
    (ASN1T_CMS_KeyTransRecipientInfo& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_KeyTransRecipientInfo::ASN1C_CMS_KeyTransRecipientInfo (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_KeyTransRecipientInfo& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_KeyTransRecipientInfo::ASN1C_CMS_KeyTransRecipientInfo (
   OSRTContext &context, ASN1T_CMS_KeyTransRecipientInfo& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_KeyTransRecipientInfo::ASN1T_CMS_KeyTransRecipientInfo ()
{
}

ASN1T_CMS_KeyTransRecipientInfo::~ASN1T_CMS_KeyTransRecipientInfo ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_KeyTransRecipientInfo (pctxt, this);
   }
}

int ASN1C_CMS_KeyTransRecipientInfo::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_KeyTransRecipientInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_KeyTransRecipientInfo::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_KeyTransRecipientInfo;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_KeyTransRecipientInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_KeyTransRecipientInfo (
   ASN1T_CMS_KeyTransRecipientInfo* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_KeyTransRecipientInfo;
}

void asn1Free_CMS_KeyTransRecipientInfo (OSCTXT *pctxt, 
   ASN1T_CMS_KeyTransRecipientInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_CMS_RecipientIdentifier (pctxt, &pvalue->rid);
   asn1Free_CMS_KeyEncryptionAlgorithmIdentifier (pctxt, &pvalue->keyEncryptionAlgorithm);
   asn1Free_CMS_EncryptedKey (pctxt, &pvalue->encryptedKey);
}

void ASN1C_CMS_KeyTransRecipientInfo::MemFree ()
{
   asn1Free_CMS_KeyTransRecipientInfo (getCtxtPtr(), &msgData);
}

ASN1T_CMS_OriginatorPublicKey* 
   new_ASN1T_CMS_OriginatorPublicKey (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_OriginatorPublicKey));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_OriginatorPublicKey;
}

ASN1C_CMS_OriginatorPublicKey::ASN1C_CMS_OriginatorPublicKey
    (ASN1T_CMS_OriginatorPublicKey& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_OriginatorPublicKey::ASN1C_CMS_OriginatorPublicKey (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_OriginatorPublicKey& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_OriginatorPublicKey::ASN1C_CMS_OriginatorPublicKey (
   OSRTContext &context, ASN1T_CMS_OriginatorPublicKey& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_OriginatorPublicKey::ASN1T_CMS_OriginatorPublicKey ()
{
}

ASN1T_CMS_OriginatorPublicKey::~ASN1T_CMS_OriginatorPublicKey ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_OriginatorPublicKey (pctxt, this);
   }
}

int ASN1C_CMS_OriginatorPublicKey::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_OriginatorPublicKey (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_OriginatorPublicKey::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_OriginatorPublicKey;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_OriginatorPublicKey (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_OriginatorPublicKey (ASN1T_CMS_OriginatorPublicKey* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_OriginatorPublicKey;
}

void asn1Free_CMS_OriginatorPublicKey (OSCTXT *pctxt, 
   ASN1T_CMS_OriginatorPublicKey* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_EXP_AlgorithmIdentifier (pctxt, &pvalue->algorithm);
   if (pvalue->publicKey.numbits > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->publicKey.data);
      pvalue->publicKey.numbits = 0;
      pvalue->publicKey.data = 0;
   }
}

void ASN1C_CMS_OriginatorPublicKey::MemFree ()
{
   asn1Free_CMS_OriginatorPublicKey (getCtxtPtr(), &msgData);
}

ASN1T_CMS_OriginatorIdentifierOrKey* 
   new_ASN1T_CMS_OriginatorIdentifierOrKey (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_OriginatorIdentifierOrKey));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_OriginatorIdentifierOrKey;
}

ASN1C_CMS_OriginatorIdentifierOrKey::ASN1C_CMS_OriginatorIdentifierOrKey
    (ASN1T_CMS_OriginatorIdentifierOrKey& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_OriginatorIdentifierOrKey::ASN1C_CMS_OriginatorIdentifierOrKey (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_OriginatorIdentifierOrKey& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_OriginatorIdentifierOrKey::ASN1C_CMS_OriginatorIdentifierOrKey (
   OSRTContext &context, ASN1T_CMS_OriginatorIdentifierOrKey& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_OriginatorIdentifierOrKey::~ASN1T_CMS_OriginatorIdentifierOrKey ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_OriginatorIdentifierOrKey (pctxt, this);
   }
}

int ASN1C_CMS_OriginatorIdentifierOrKey::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_OriginatorIdentifierOrKey (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_OriginatorIdentifierOrKey::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_OriginatorIdentifierOrKey;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_OriginatorIdentifierOrKey (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_OriginatorIdentifierOrKey (
   ASN1T_CMS_OriginatorIdentifierOrKey* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_OriginatorIdentifierOrKey;
}

void asn1Free_CMS_OriginatorIdentifierOrKey (OSCTXT *pctxt, 
   ASN1T_CMS_OriginatorIdentifierOrKey* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.issuerAndSerialNumber) {
            asn1Free_PKCS7_IssuerAndSerialNumber (pctxt, pvalue->u.issuerAndSerialNumber);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.issuerAndSerialNumber);
         }
         break;

      case 2:
         if (0 != pvalue->u.subjectKeyIdentifier) {
            asn1Free_CMS_SubjectKeyIdentifier (pctxt, pvalue->u.subjectKeyIdentifier);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.subjectKeyIdentifier);
         }
         break;

      case 3:
         if (0 != pvalue->u.originatorKey) {
            asn1Free_CMS_OriginatorPublicKey (pctxt, pvalue->u.originatorKey);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.originatorKey);
         }
         break;

   }
}

void ASN1C_CMS_OriginatorIdentifierOrKey::MemFree ()
{
   asn1Free_CMS_OriginatorIdentifierOrKey (getCtxtPtr(), &msgData);
}

ASN1T_CMS_OtherKeyAttribute* new_ASN1T_CMS_OtherKeyAttribute (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_OtherKeyAttribute));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_OtherKeyAttribute;
}

ASN1C_CMS_OtherKeyAttribute::ASN1C_CMS_OtherKeyAttribute
    (ASN1T_CMS_OtherKeyAttribute& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_OtherKeyAttribute::ASN1C_CMS_OtherKeyAttribute (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_OtherKeyAttribute& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_OtherKeyAttribute::ASN1C_CMS_OtherKeyAttribute (OSRTContext &context
   , ASN1T_CMS_OtherKeyAttribute& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_OtherKeyAttribute::ASN1T_CMS_OtherKeyAttribute ()
{
   m.keyAttrPresent = 0;
}

ASN1T_CMS_OtherKeyAttribute::~ASN1T_CMS_OtherKeyAttribute ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_OtherKeyAttribute (pctxt, this);
   }
}

int ASN1C_CMS_OtherKeyAttribute::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_OtherKeyAttribute (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_OtherKeyAttribute::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_OtherKeyAttribute;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_OtherKeyAttribute (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_OtherKeyAttribute (ASN1T_CMS_OtherKeyAttribute* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_OtherKeyAttribute;
}

void asn1Free_CMS_OtherKeyAttribute (OSCTXT *pctxt, 
   ASN1T_CMS_OtherKeyAttribute* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.keyAttrPresent) {
      rtxMemFreePtr (pctxt, (void*)pvalue->keyAttr.data);
   }
}

void ASN1C_CMS_OtherKeyAttribute::MemFree ()
{
   asn1Free_CMS_OtherKeyAttribute (getCtxtPtr(), &msgData);
}

ASN1T_CMS_RecipientKeyIdentifier* 
   new_ASN1T_CMS_RecipientKeyIdentifier (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_RecipientKeyIdentifier));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_RecipientKeyIdentifier;
}

ASN1C_CMS_RecipientKeyIdentifier::ASN1C_CMS_RecipientKeyIdentifier
    (ASN1T_CMS_RecipientKeyIdentifier& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_RecipientKeyIdentifier::ASN1C_CMS_RecipientKeyIdentifier (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_RecipientKeyIdentifier& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_RecipientKeyIdentifier::ASN1C_CMS_RecipientKeyIdentifier (
   OSRTContext &context, ASN1T_CMS_RecipientKeyIdentifier& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_RecipientKeyIdentifier::ASN1T_CMS_RecipientKeyIdentifier ()
{
   m.datePresent = 0;
   date = 0;
   m.otherPresent = 0;
}

ASN1T_CMS_RecipientKeyIdentifier::~ASN1T_CMS_RecipientKeyIdentifier ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_RecipientKeyIdentifier (pctxt, this);
   }
}

int ASN1C_CMS_RecipientKeyIdentifier::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_RecipientKeyIdentifier (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_RecipientKeyIdentifier::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_RecipientKeyIdentifier;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_RecipientKeyIdentifier (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_RecipientKeyIdentifier (
   ASN1T_CMS_RecipientKeyIdentifier* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_RecipientKeyIdentifier;
}

void asn1Free_CMS_RecipientKeyIdentifier (OSCTXT *pctxt, 
   ASN1T_CMS_RecipientKeyIdentifier* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_CMS_SubjectKeyIdentifier (pctxt, &pvalue->subjectKeyIdentifier);
   if (pvalue->m.datePresent) {
      rtxMemFreePtr (pctxt, (void*)pvalue->date);
   }
   if (pvalue->m.otherPresent) {
      asn1Free_CMS_OtherKeyAttribute (pctxt, &pvalue->other);
   }
}

void ASN1C_CMS_RecipientKeyIdentifier::MemFree ()
{
   asn1Free_CMS_RecipientKeyIdentifier (getCtxtPtr(), &msgData);
}

ASN1T_CMS_KeyAgreeRecipientIdentifier* 
   new_ASN1T_CMS_KeyAgreeRecipientIdentifier (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_KeyAgreeRecipientIdentifier));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_KeyAgreeRecipientIdentifier;
}

ASN1C_CMS_KeyAgreeRecipientIdentifier::ASN1C_CMS_KeyAgreeRecipientIdentifier
    (ASN1T_CMS_KeyAgreeRecipientIdentifier& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_KeyAgreeRecipientIdentifier::ASN1C_CMS_KeyAgreeRecipientIdentifier (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_KeyAgreeRecipientIdentifier& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_KeyAgreeRecipientIdentifier::ASN1C_CMS_KeyAgreeRecipientIdentifier (
   OSRTContext &context, ASN1T_CMS_KeyAgreeRecipientIdentifier& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_KeyAgreeRecipientIdentifier::~ASN1T_CMS_KeyAgreeRecipientIdentifier ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_KeyAgreeRecipientIdentifier (pctxt, this);
   }
}

int ASN1C_CMS_KeyAgreeRecipientIdentifier::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_KeyAgreeRecipientIdentifier (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_KeyAgreeRecipientIdentifier::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_KeyAgreeRecipientIdentifier;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_KeyAgreeRecipientIdentifier (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_KeyAgreeRecipientIdentifier (
   ASN1T_CMS_KeyAgreeRecipientIdentifier* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_KeyAgreeRecipientIdentifier;
}

void asn1Free_CMS_KeyAgreeRecipientIdentifier (OSCTXT *pctxt, 
   ASN1T_CMS_KeyAgreeRecipientIdentifier* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.issuerAndSerialNumber) {
            asn1Free_PKCS7_IssuerAndSerialNumber (pctxt, pvalue->u.issuerAndSerialNumber);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.issuerAndSerialNumber);
         }
         break;

      case 2:
         if (0 != pvalue->u.rKeyId) {
            asn1Free_CMS_RecipientKeyIdentifier (pctxt, pvalue->u.rKeyId);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.rKeyId);
         }
         break;

   }
}

void ASN1C_CMS_KeyAgreeRecipientIdentifier::MemFree ()
{
   asn1Free_CMS_KeyAgreeRecipientIdentifier (getCtxtPtr(), &msgData);
}

ASN1T_CMS_RecipientEncryptedKey* 
   new_ASN1T_CMS_RecipientEncryptedKey (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_RecipientEncryptedKey));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_RecipientEncryptedKey;
}

ASN1C_CMS_RecipientEncryptedKey::ASN1C_CMS_RecipientEncryptedKey
    (ASN1T_CMS_RecipientEncryptedKey& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_RecipientEncryptedKey::ASN1C_CMS_RecipientEncryptedKey (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_RecipientEncryptedKey& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_RecipientEncryptedKey::ASN1C_CMS_RecipientEncryptedKey (
   OSRTContext &context, ASN1T_CMS_RecipientEncryptedKey& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_RecipientEncryptedKey::ASN1T_CMS_RecipientEncryptedKey ()
{
}

ASN1T_CMS_RecipientEncryptedKey::~ASN1T_CMS_RecipientEncryptedKey ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_RecipientEncryptedKey (pctxt, this);
   }
}

int ASN1C_CMS_RecipientEncryptedKey::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_RecipientEncryptedKey (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_RecipientEncryptedKey::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_RecipientEncryptedKey;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_RecipientEncryptedKey (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_RecipientEncryptedKey (
   ASN1T_CMS_RecipientEncryptedKey* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_RecipientEncryptedKey;
}

void asn1Free_CMS_RecipientEncryptedKey (OSCTXT *pctxt, 
   ASN1T_CMS_RecipientEncryptedKey* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_CMS_KeyAgreeRecipientIdentifier (pctxt, &pvalue->rid);
   asn1Free_CMS_EncryptedKey (pctxt, &pvalue->encryptedKey);
}

void ASN1C_CMS_RecipientEncryptedKey::MemFree ()
{
   asn1Free_CMS_RecipientEncryptedKey (getCtxtPtr(), &msgData);
}

ASN1C_CMS_RecipientEncryptedKeys::ASN1C_CMS_RecipientEncryptedKeys
    (ASN1T_CMS_RecipientEncryptedKeys& data) : ASN1CSeqOfList(data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_RecipientEncryptedKeys::ASN1C_CMS_RecipientEncryptedKeys (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_RecipientEncryptedKeys& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_RecipientEncryptedKeys::ASN1C_CMS_RecipientEncryptedKeys (
   OSRTContext &context, ASN1T_CMS_RecipientEncryptedKeys& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CMS_RecipientEncryptedKeys::
   ASN1C_CMS_RecipientEncryptedKeys (ASN1CType& ccobj
   , ASN1T_CMS_RecipientEncryptedKeys& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CMS_RecipientEncryptedKeys::Append (ASN1T_CMS_RecipientEncryptedKey* elem)
{
   append ((void*)elem);
}

ASN1T_CMS_RecipientEncryptedKey* ASN1C_CMS_RecipientEncryptedKeys::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_CMS_RecipientEncryptedKey));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_RecipientEncryptedKey;
}

ASN1T_CMS_RecipientEncryptedKey* ASN1C_CMS_RecipientEncryptedKeys::AppendNewElement ()
{
   ASN1T_CMS_RecipientEncryptedKey* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CMS_RecipientEncryptedKeys::~ASN1T_CMS_RecipientEncryptedKeys ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_RecipientEncryptedKeys (pctxt, this);
   }
}

int ASN1C_CMS_RecipientEncryptedKeys::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_RecipientEncryptedKeys (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_RecipientEncryptedKeys::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_RecipientEncryptedKeys;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_RecipientEncryptedKeys (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_RecipientEncryptedKeys (
   ASN1T_CMS_RecipientEncryptedKeys* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_RecipientEncryptedKeys;
   rtxDListFastInit (pvalue);
}

void asn1Free_CMS_RecipientEncryptedKeys (OSCTXT *pctxt, 
   ASN1T_CMS_RecipientEncryptedKeys* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_CMS_RecipientEncryptedKey* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_CMS_RecipientEncryptedKey*)pnode->data;
      asn1Free_CMS_RecipientEncryptedKey (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CMS_RecipientEncryptedKeys::MemFree ()
{
   asn1Free_CMS_RecipientEncryptedKeys (getCtxtPtr(), &msgData);
}

ASN1T_CMS_KeyAgreeRecipientInfo* 
   new_ASN1T_CMS_KeyAgreeRecipientInfo (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_KeyAgreeRecipientInfo));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_KeyAgreeRecipientInfo;
}

ASN1C_CMS_KeyAgreeRecipientInfo::ASN1C_CMS_KeyAgreeRecipientInfo
    (ASN1T_CMS_KeyAgreeRecipientInfo& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_KeyAgreeRecipientInfo::ASN1C_CMS_KeyAgreeRecipientInfo (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_KeyAgreeRecipientInfo& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_KeyAgreeRecipientInfo::ASN1C_CMS_KeyAgreeRecipientInfo (
   OSRTContext &context, ASN1T_CMS_KeyAgreeRecipientInfo& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_KeyAgreeRecipientInfo::ASN1T_CMS_KeyAgreeRecipientInfo ()
{
   m.ukmPresent = 0;
}

ASN1T_CMS_KeyAgreeRecipientInfo::~ASN1T_CMS_KeyAgreeRecipientInfo ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_KeyAgreeRecipientInfo (pctxt, this);
   }
}

int ASN1C_CMS_KeyAgreeRecipientInfo::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_KeyAgreeRecipientInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_KeyAgreeRecipientInfo::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_KeyAgreeRecipientInfo;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_KeyAgreeRecipientInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_KeyAgreeRecipientInfo (
   ASN1T_CMS_KeyAgreeRecipientInfo* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_KeyAgreeRecipientInfo;
}

void asn1Free_CMS_KeyAgreeRecipientInfo (OSCTXT *pctxt, 
   ASN1T_CMS_KeyAgreeRecipientInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_CMS_OriginatorIdentifierOrKey (pctxt, &pvalue->originator);
   if (pvalue->m.ukmPresent) {
      asn1Free_CMS_UserKeyingMaterial (pctxt, &pvalue->ukm);
   }
   asn1Free_CMS_KeyEncryptionAlgorithmIdentifier (pctxt, &pvalue->keyEncryptionAlgorithm);
   asn1Free_CMS_RecipientEncryptedKeys (pctxt, &pvalue->recipientEncryptedKeys);
}

void ASN1C_CMS_KeyAgreeRecipientInfo::MemFree ()
{
   asn1Free_CMS_KeyAgreeRecipientInfo (getCtxtPtr(), &msgData);
}

ASN1T_CMS_KEKIdentifier* new_ASN1T_CMS_KEKIdentifier (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_KEKIdentifier));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_KEKIdentifier;
}

ASN1C_CMS_KEKIdentifier::ASN1C_CMS_KEKIdentifier
    (ASN1T_CMS_KEKIdentifier& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_KEKIdentifier::ASN1C_CMS_KEKIdentifier (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMS_KEKIdentifier& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_KEKIdentifier::ASN1C_CMS_KEKIdentifier (OSRTContext &context
   , ASN1T_CMS_KEKIdentifier& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_KEKIdentifier::ASN1T_CMS_KEKIdentifier ()
{
   m.datePresent = 0;
   date = 0;
   m.otherPresent = 0;
}

ASN1T_CMS_KEKIdentifier::~ASN1T_CMS_KEKIdentifier ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_KEKIdentifier (pctxt, this);
   }
}

int ASN1C_CMS_KEKIdentifier::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_KEKIdentifier (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_KEKIdentifier::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_KEKIdentifier;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_KEKIdentifier (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_KEKIdentifier (ASN1T_CMS_KEKIdentifier* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_KEKIdentifier;
}

void asn1Free_CMS_KEKIdentifier (OSCTXT *pctxt, 
   ASN1T_CMS_KEKIdentifier* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->keyIdentifier.numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->keyIdentifier.data);
      pvalue->keyIdentifier.numocts = 0;
      pvalue->keyIdentifier.data = 0;
   }
   if (pvalue->m.datePresent) {
      rtxMemFreePtr (pctxt, (void*)pvalue->date);
   }
   if (pvalue->m.otherPresent) {
      asn1Free_CMS_OtherKeyAttribute (pctxt, &pvalue->other);
   }
}

void ASN1C_CMS_KEKIdentifier::MemFree ()
{
   asn1Free_CMS_KEKIdentifier (getCtxtPtr(), &msgData);
}

ASN1T_CMS_KEKRecipientInfo* new_ASN1T_CMS_KEKRecipientInfo (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_KEKRecipientInfo));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_KEKRecipientInfo;
}

ASN1C_CMS_KEKRecipientInfo::ASN1C_CMS_KEKRecipientInfo
    (ASN1T_CMS_KEKRecipientInfo& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_KEKRecipientInfo::ASN1C_CMS_KEKRecipientInfo (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_KEKRecipientInfo& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_KEKRecipientInfo::ASN1C_CMS_KEKRecipientInfo (OSRTContext &context
   , ASN1T_CMS_KEKRecipientInfo& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_KEKRecipientInfo::ASN1T_CMS_KEKRecipientInfo ()
{
}

ASN1T_CMS_KEKRecipientInfo::~ASN1T_CMS_KEKRecipientInfo ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_KEKRecipientInfo (pctxt, this);
   }
}

int ASN1C_CMS_KEKRecipientInfo::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_KEKRecipientInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_KEKRecipientInfo::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_KEKRecipientInfo;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_KEKRecipientInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_KEKRecipientInfo (ASN1T_CMS_KEKRecipientInfo* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_KEKRecipientInfo;
}

void asn1Free_CMS_KEKRecipientInfo (OSCTXT *pctxt, 
   ASN1T_CMS_KEKRecipientInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_CMS_KEKIdentifier (pctxt, &pvalue->kekid);
   asn1Free_CMS_KeyEncryptionAlgorithmIdentifier (pctxt, &pvalue->keyEncryptionAlgorithm);
   asn1Free_CMS_EncryptedKey (pctxt, &pvalue->encryptedKey);
}

void ASN1C_CMS_KEKRecipientInfo::MemFree ()
{
   asn1Free_CMS_KEKRecipientInfo (getCtxtPtr(), &msgData);
}

ASN1T_CMS_PasswordRecipientInfo* 
   new_ASN1T_CMS_PasswordRecipientInfo (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_PasswordRecipientInfo));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_PasswordRecipientInfo;
}

ASN1C_CMS_PasswordRecipientInfo::ASN1C_CMS_PasswordRecipientInfo
    (ASN1T_CMS_PasswordRecipientInfo& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_PasswordRecipientInfo::ASN1C_CMS_PasswordRecipientInfo (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_PasswordRecipientInfo& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_PasswordRecipientInfo::ASN1C_CMS_PasswordRecipientInfo (
   OSRTContext &context, ASN1T_CMS_PasswordRecipientInfo& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_PasswordRecipientInfo::ASN1T_CMS_PasswordRecipientInfo ()
{
   m.keyDerivationAlgorithmPresent = 0;
}

ASN1T_CMS_PasswordRecipientInfo::~ASN1T_CMS_PasswordRecipientInfo ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_PasswordRecipientInfo (pctxt, this);
   }
}

int ASN1C_CMS_PasswordRecipientInfo::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_PasswordRecipientInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_PasswordRecipientInfo::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_PasswordRecipientInfo;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_PasswordRecipientInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_PasswordRecipientInfo (
   ASN1T_CMS_PasswordRecipientInfo* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_PasswordRecipientInfo;
}

void asn1Free_CMS_PasswordRecipientInfo (OSCTXT *pctxt, 
   ASN1T_CMS_PasswordRecipientInfo* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.keyDerivationAlgorithmPresent) {
      asn1Free_CMS_KeyDerivationAlgorithmIdentifier (pctxt, &pvalue->keyDerivationAlgorithm);
   }
   asn1Free_CMS_KeyEncryptionAlgorithmIdentifier (pctxt, &pvalue->keyEncryptionAlgorithm);
   asn1Free_CMS_EncryptedKey (pctxt, &pvalue->encryptedKey);
}

void ASN1C_CMS_PasswordRecipientInfo::MemFree ()
{
   asn1Free_CMS_PasswordRecipientInfo (getCtxtPtr(), &msgData);
}

ASN1T_CMS_OtherRecipientInfo* 
   new_ASN1T_CMS_OtherRecipientInfo (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_OtherRecipientInfo));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_OtherRecipientInfo;
}

ASN1C_CMS_OtherRecipientInfo::ASN1C_CMS_OtherRecipientInfo
    (ASN1T_CMS_OtherRecipientInfo& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_OtherRecipientInfo::ASN1C_CMS_OtherRecipientInfo (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_OtherRecipientInfo& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_OtherRecipientInfo::ASN1C_CMS_OtherRecipientInfo (
   OSRTContext &context, ASN1T_CMS_OtherRecipientInfo& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_OtherRecipientInfo::ASN1T_CMS_OtherRecipientInfo ()
{
}

ASN1T_CMS_OtherRecipientInfo::~ASN1T_CMS_OtherRecipientInfo ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_OtherRecipientInfo (pctxt, this);
   }
}

int ASN1C_CMS_OtherRecipientInfo::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_OtherRecipientInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_OtherRecipientInfo::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_OtherRecipientInfo;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_OtherRecipientInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_OtherRecipientInfo (ASN1T_CMS_OtherRecipientInfo* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_OtherRecipientInfo;
}

void asn1Free_CMS_OtherRecipientInfo (OSCTXT *pctxt, 
   ASN1T_CMS_OtherRecipientInfo* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreePtr (pctxt, (void*)pvalue->oriValue.data);
}

void ASN1C_CMS_OtherRecipientInfo::MemFree ()
{
   asn1Free_CMS_OtherRecipientInfo (getCtxtPtr(), &msgData);
}

ASN1T_CMS_RecipientInfo* new_ASN1T_CMS_RecipientInfo (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_RecipientInfo));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_RecipientInfo;
}

ASN1C_CMS_RecipientInfo::ASN1C_CMS_RecipientInfo
    (ASN1T_CMS_RecipientInfo& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_RecipientInfo::ASN1C_CMS_RecipientInfo (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMS_RecipientInfo& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_RecipientInfo::ASN1C_CMS_RecipientInfo (OSRTContext &context
   , ASN1T_CMS_RecipientInfo& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_RecipientInfo::~ASN1T_CMS_RecipientInfo ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_RecipientInfo (pctxt, this);
   }
}

int ASN1C_CMS_RecipientInfo::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_RecipientInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_RecipientInfo::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_RecipientInfo;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_RecipientInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_RecipientInfo (ASN1T_CMS_RecipientInfo* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_RecipientInfo;
}

void asn1Free_CMS_RecipientInfo (OSCTXT *pctxt, 
   ASN1T_CMS_RecipientInfo* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.ktri) {
            asn1Free_CMS_KeyTransRecipientInfo (pctxt, pvalue->u.ktri);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ktri);
         }
         break;

      case 2:
         if (0 != pvalue->u.kari) {
            asn1Free_CMS_KeyAgreeRecipientInfo (pctxt, pvalue->u.kari);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.kari);
         }
         break;

      case 3:
         if (0 != pvalue->u.kekri) {
            asn1Free_CMS_KEKRecipientInfo (pctxt, pvalue->u.kekri);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.kekri);
         }
         break;

      case 4:
         if (0 != pvalue->u.pwri) {
            asn1Free_CMS_PasswordRecipientInfo (pctxt, pvalue->u.pwri);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.pwri);
         }
         break;

      case 5:
         if (0 != pvalue->u.ori) {
            asn1Free_CMS_OtherRecipientInfo (pctxt, pvalue->u.ori);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ori);
         }
         break;

   }
}

void ASN1C_CMS_RecipientInfo::MemFree ()
{
   asn1Free_CMS_RecipientInfo (getCtxtPtr(), &msgData);
}

ASN1C_CMS_RecipientInfos::ASN1C_CMS_RecipientInfos
    (ASN1T_CMS_RecipientInfos& data) : ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_RecipientInfos::ASN1C_CMS_RecipientInfos (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMS_RecipientInfos& data) : ASN1CSeqOfList(msgBuf, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_RecipientInfos::ASN1C_CMS_RecipientInfos (OSRTContext &context
   , ASN1T_CMS_RecipientInfos& data) : ASN1CSeqOfList(context, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CMS_RecipientInfos::ASN1C_CMS_RecipientInfos (ASN1CType& ccobj
   , ASN1T_CMS_RecipientInfos& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CMS_RecipientInfos::Append (ASN1T_CMS_RecipientInfo* elem)
{
   append ((void*)elem);
}

ASN1T_CMS_RecipientInfo* ASN1C_CMS_RecipientInfos::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_CMS_RecipientInfo));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_RecipientInfo;
}

ASN1T_CMS_RecipientInfo* ASN1C_CMS_RecipientInfos::AppendNewElement ()
{
   ASN1T_CMS_RecipientInfo* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CMS_RecipientInfos::~ASN1T_CMS_RecipientInfos ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_RecipientInfos (pctxt, this);
   }
}

int ASN1C_CMS_RecipientInfos::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_RecipientInfos (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_RecipientInfos::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_RecipientInfos;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_RecipientInfos (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_RecipientInfos (ASN1T_CMS_RecipientInfos* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_RecipientInfos;
   rtxDListFastInit (pvalue);
}

void asn1Free_CMS_RecipientInfos (OSCTXT *pctxt, 
   ASN1T_CMS_RecipientInfos* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_CMS_RecipientInfo* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_CMS_RecipientInfo*)pnode->data;
      asn1Free_CMS_RecipientInfo (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CMS_RecipientInfos::MemFree ()
{
   asn1Free_CMS_RecipientInfos (getCtxtPtr(), &msgData);
}

ASN1C_CMS_UnprotectedAttributes::ASN1C_CMS_UnprotectedAttributes
    (ASN1T_CMS_UnprotectedAttributes& data) : ASN1CSeqOfList(data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_UnprotectedAttributes::ASN1C_CMS_UnprotectedAttributes (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_UnprotectedAttributes& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_UnprotectedAttributes::ASN1C_CMS_UnprotectedAttributes (
   OSRTContext &context, ASN1T_CMS_UnprotectedAttributes& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CMS_UnprotectedAttributes::
   ASN1C_CMS_UnprotectedAttributes (ASN1CType& ccobj
   , ASN1T_CMS_UnprotectedAttributes& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CMS_UnprotectedAttributes::Append (ASN1T_EXP_Attribute* elem)
{
   append ((void*)elem);
}

ASN1T_EXP_Attribute* ASN1C_CMS_UnprotectedAttributes::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_EXP_Attribute));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_EXP_Attribute;
}

ASN1T_EXP_Attribute* ASN1C_CMS_UnprotectedAttributes::AppendNewElement ()
{
   ASN1T_EXP_Attribute* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CMS_UnprotectedAttributes::~ASN1T_CMS_UnprotectedAttributes ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_UnprotectedAttributes (pctxt, this);
   }
}

int ASN1C_CMS_UnprotectedAttributes::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_UnprotectedAttributes (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_UnprotectedAttributes::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_UnprotectedAttributes;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_UnprotectedAttributes (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_UnprotectedAttributes (
   ASN1T_CMS_UnprotectedAttributes* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_UnprotectedAttributes;
   rtxDListFastInit (pvalue);
}

void asn1Free_CMS_UnprotectedAttributes (OSCTXT *pctxt, 
   ASN1T_CMS_UnprotectedAttributes* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_EXP_Attribute* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_EXP_Attribute*)pnode->data;
      asn1Free_EXP_Attribute (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CMS_UnprotectedAttributes::MemFree ()
{
   asn1Free_CMS_UnprotectedAttributes (getCtxtPtr(), &msgData);
}

ASN1T_CMS_EnvelopedData* new_ASN1T_CMS_EnvelopedData (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_EnvelopedData));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_EnvelopedData;
}

ASN1C_CMS_EnvelopedData::ASN1C_CMS_EnvelopedData
    (ASN1T_CMS_EnvelopedData& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_EnvelopedData::ASN1C_CMS_EnvelopedData (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMS_EnvelopedData& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_EnvelopedData::ASN1C_CMS_EnvelopedData (OSRTContext &context
   , ASN1T_CMS_EnvelopedData& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_EnvelopedData::ASN1T_CMS_EnvelopedData ()
{
   m.originatorInfoPresent = 0;
   m.unprotectedAttrsPresent = 0;
}

ASN1T_CMS_EnvelopedData::~ASN1T_CMS_EnvelopedData ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_EnvelopedData (pctxt, this);
   }
}

int ASN1C_CMS_EnvelopedData::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_EnvelopedData (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_EnvelopedData::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_EnvelopedData;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_EnvelopedData (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_EnvelopedData (ASN1T_CMS_EnvelopedData* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_EnvelopedData;
}

void asn1Free_CMS_EnvelopedData (OSCTXT *pctxt, 
   ASN1T_CMS_EnvelopedData* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.originatorInfoPresent) {
      asn1Free_CMS_OriginatorInfo (pctxt, &pvalue->originatorInfo);
   }
   asn1Free_CMS_RecipientInfos (pctxt, &pvalue->recipientInfos);
   asn1Free_PKCS7_EncryptedContentInfo (pctxt, &pvalue->encryptedContentInfo);
   if (pvalue->m.unprotectedAttrsPresent) {
      asn1Free_CMS_UnprotectedAttributes (pctxt, &pvalue->unprotectedAttrs);
   }
}

void ASN1C_CMS_EnvelopedData::MemFree ()
{
   asn1Free_CMS_EnvelopedData (getCtxtPtr(), &msgData);
}

ASN1T_CMS_DigestedData* new_ASN1T_CMS_DigestedData (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_DigestedData));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_DigestedData;
}

ASN1C_CMS_DigestedData::ASN1C_CMS_DigestedData (ASN1T_CMS_DigestedData& data)
    : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_DigestedData::ASN1C_CMS_DigestedData (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMS_DigestedData& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_DigestedData::ASN1C_CMS_DigestedData (OSRTContext &context
   , ASN1T_CMS_DigestedData& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_DigestedData::ASN1T_CMS_DigestedData ()
{
}

ASN1T_CMS_DigestedData::~ASN1T_CMS_DigestedData ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_DigestedData (pctxt, this);
   }
}

int ASN1C_CMS_DigestedData::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_DigestedData (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_DigestedData::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_DigestedData;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_DigestedData (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_DigestedData (ASN1T_CMS_DigestedData* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_DigestedData;
}

void asn1Free_CMS_DigestedData (OSCTXT *pctxt, ASN1T_CMS_DigestedData* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_CMS_DigestAlgorithmIdentifier (pctxt, &pvalue->digestAlgorithm);
   asn1Free_CMS_EncapsulatedContentInfo (pctxt, &pvalue->encapContentInfo);
   asn1Free_CMS_Digest (pctxt, &pvalue->digest);
}

void ASN1C_CMS_DigestedData::MemFree ()
{
   asn1Free_CMS_DigestedData (getCtxtPtr(), &msgData);
}

ASN1T_CMS_EncryptedData* new_ASN1T_CMS_EncryptedData (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_EncryptedData));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_EncryptedData;
}

ASN1C_CMS_EncryptedData::ASN1C_CMS_EncryptedData
    (ASN1T_CMS_EncryptedData& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_EncryptedData::ASN1C_CMS_EncryptedData (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMS_EncryptedData& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_EncryptedData::ASN1C_CMS_EncryptedData (OSRTContext &context
   , ASN1T_CMS_EncryptedData& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_EncryptedData::ASN1T_CMS_EncryptedData ()
{
   m.unprotectedAttrsPresent = 0;
}

ASN1T_CMS_EncryptedData::~ASN1T_CMS_EncryptedData ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_EncryptedData (pctxt, this);
   }
}

int ASN1C_CMS_EncryptedData::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_EncryptedData (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_EncryptedData::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_EncryptedData;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_EncryptedData (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_EncryptedData (ASN1T_CMS_EncryptedData* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_EncryptedData;
}

void asn1Free_CMS_EncryptedData (OSCTXT *pctxt, 
   ASN1T_CMS_EncryptedData* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_PKCS7_EncryptedContentInfo (pctxt, &pvalue->encryptedContentInfo);
   if (pvalue->m.unprotectedAttrsPresent) {
      asn1Free_CMS_UnprotectedAttributes (pctxt, &pvalue->unprotectedAttrs);
   }
}

void ASN1C_CMS_EncryptedData::MemFree ()
{
   asn1Free_CMS_EncryptedData (getCtxtPtr(), &msgData);
}

ASN1T_CMS_AuthenticatedData* new_ASN1T_CMS_AuthenticatedData (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_AuthenticatedData));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_AuthenticatedData;
}

ASN1C_CMS_AuthenticatedData::ASN1C_CMS_AuthenticatedData
    (ASN1T_CMS_AuthenticatedData& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_AuthenticatedData::ASN1C_CMS_AuthenticatedData (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_AuthenticatedData& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_AuthenticatedData::ASN1C_CMS_AuthenticatedData (OSRTContext &context
   , ASN1T_CMS_AuthenticatedData& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_AuthenticatedData::ASN1T_CMS_AuthenticatedData ()
{
   m.originatorInfoPresent = 0;
   m.digestAlgorithmPresent = 0;
   m.authAttrsPresent = 0;
   m.unauthAttrsPresent = 0;
}

ASN1T_CMS_AuthenticatedData::~ASN1T_CMS_AuthenticatedData ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_AuthenticatedData (pctxt, this);
   }
}

int ASN1C_CMS_AuthenticatedData::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_AuthenticatedData (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_AuthenticatedData::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_AuthenticatedData;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_AuthenticatedData (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_AuthenticatedData (ASN1T_CMS_AuthenticatedData* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_AuthenticatedData;
}

void asn1Free_CMS_AuthenticatedData (OSCTXT *pctxt, 
   ASN1T_CMS_AuthenticatedData* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.originatorInfoPresent) {
      asn1Free_CMS_OriginatorInfo (pctxt, &pvalue->originatorInfo);
   }
   asn1Free_CMS_RecipientInfos (pctxt, &pvalue->recipientInfos);
   asn1Free_CMS_MessageAuthenticationCodeAlgorithm (pctxt, &pvalue->macAlgorithm);
   if (pvalue->m.digestAlgorithmPresent) {
      asn1Free_CMS_DigestAlgorithmIdentifier (pctxt, &pvalue->digestAlgorithm);
   }
   asn1Free_CMS_EncapsulatedContentInfo (pctxt, &pvalue->encapContentInfo);
   if (pvalue->m.authAttrsPresent) {
      asn1Free_DERCMS_AuthAttributes (pctxt, &pvalue->authAttrs);
   }
   asn1Free_CMS_MessageAuthenticationCode (pctxt, &pvalue->mac);
   if (pvalue->m.unauthAttrsPresent) {
      asn1Free_CMS_UnauthAttributes (pctxt, &pvalue->unauthAttrs);
   }
}

void ASN1C_CMS_AuthenticatedData::MemFree ()
{
   asn1Free_CMS_AuthenticatedData (getCtxtPtr(), &msgData);
}

ASN1T_CMS_ExtendedCertificateOrCertificate* 
   new_ASN1T_CMS_ExtendedCertificateOrCertificate (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_ExtendedCertificateOrCertificate));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_ExtendedCertificateOrCertificate;
}

ASN1C_CMS_ExtendedCertificateOrCertificate::
   ASN1C_CMS_ExtendedCertificateOrCertificate
    (ASN1T_CMS_ExtendedCertificateOrCertificate& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_ExtendedCertificateOrCertificate::
   ASN1C_CMS_ExtendedCertificateOrCertificate (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMS_ExtendedCertificateOrCertificate& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_ExtendedCertificateOrCertificate::
   ASN1C_CMS_ExtendedCertificateOrCertificate (OSRTContext &context
   , ASN1T_CMS_ExtendedCertificateOrCertificate& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_ExtendedCertificateOrCertificate::~ASN1T_CMS_ExtendedCertificateOrCertificate ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_ExtendedCertificateOrCertificate (pctxt, this);
   }
}

int ASN1C_CMS_ExtendedCertificateOrCertificate::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_ExtendedCertificateOrCertificate (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_ExtendedCertificateOrCertificate::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_ExtendedCertificateOrCertificate;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_ExtendedCertificateOrCertificate (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_ExtendedCertificateOrCertificate (
   ASN1T_CMS_ExtendedCertificateOrCertificate* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_ExtendedCertificateOrCertificate;
}

void asn1Free_CMS_ExtendedCertificateOrCertificate (OSCTXT *pctxt, 
   ASN1T_CMS_ExtendedCertificateOrCertificate* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.certificate) {
            asn1Free_EXP_Certificate (pctxt, pvalue->u.certificate);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.certificate);
         }
         break;

      case 2:
         if (0 != pvalue->u.extendedCertificate) {
            asn1Free_CMS_ExtendedCertificate (pctxt, pvalue->u.extendedCertificate);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.extendedCertificate);
         }
         break;

   }
}

void ASN1C_CMS_ExtendedCertificateOrCertificate::MemFree ()
{
   asn1Free_CMS_ExtendedCertificateOrCertificate (getCtxtPtr(), &msgData);
}

ASN1T_CMS_SMIMECapability* new_ASN1T_CMS_SMIMECapability (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_SMIMECapability));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_SMIMECapability;
}

ASN1C_CMS_SMIMECapability::ASN1C_CMS_SMIMECapability
    (ASN1T_CMS_SMIMECapability& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_SMIMECapability::ASN1C_CMS_SMIMECapability (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_SMIMECapability& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_SMIMECapability::ASN1C_CMS_SMIMECapability (OSRTContext &context
   , ASN1T_CMS_SMIMECapability& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_SMIMECapability::ASN1T_CMS_SMIMECapability ()
{
   m.parametersPresent = 0;
}

ASN1T_CMS_SMIMECapability::~ASN1T_CMS_SMIMECapability ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_SMIMECapability (pctxt, this);
   }
}

int ASN1C_CMS_SMIMECapability::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_SMIMECapability (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_SMIMECapability::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_SMIMECapability;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_SMIMECapability (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_SMIMECapability (ASN1T_CMS_SMIMECapability* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_SMIMECapability;
}

void asn1Free_CMS_SMIMECapability (OSCTXT *pctxt, 
   ASN1T_CMS_SMIMECapability* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.parametersPresent) {
      rtxMemFreePtr (pctxt, (void*)pvalue->parameters.data);
   }
}

void ASN1C_CMS_SMIMECapability::MemFree ()
{
   asn1Free_CMS_SMIMECapability (getCtxtPtr(), &msgData);
}

ASN1C_CMS_SMIMECapabilities::ASN1C_CMS_SMIMECapabilities
    (ASN1T_CMS_SMIMECapabilities& data) : ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_SMIMECapabilities::ASN1C_CMS_SMIMECapabilities (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_SMIMECapabilities& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_SMIMECapabilities::ASN1C_CMS_SMIMECapabilities (OSRTContext &context
   , ASN1T_CMS_SMIMECapabilities& data) : ASN1CSeqOfList(context, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CMS_SMIMECapabilities::ASN1C_CMS_SMIMECapabilities (ASN1CType& ccobj
   , ASN1T_CMS_SMIMECapabilities& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CMS_SMIMECapabilities::Append (ASN1T_CMS_SMIMECapability* elem)
{
   append ((void*)elem);
}

ASN1T_CMS_SMIMECapability* ASN1C_CMS_SMIMECapabilities::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_CMS_SMIMECapability));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_SMIMECapability;
}

ASN1T_CMS_SMIMECapability* ASN1C_CMS_SMIMECapabilities::AppendNewElement ()
{
   ASN1T_CMS_SMIMECapability* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CMS_SMIMECapabilities::~ASN1T_CMS_SMIMECapabilities ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_SMIMECapabilities (pctxt, this);
   }
}

int ASN1C_CMS_SMIMECapabilities::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_SMIMECapabilities (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_SMIMECapabilities::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_SMIMECapabilities;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_SMIMECapabilities (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_SMIMECapabilities (ASN1T_CMS_SMIMECapabilities* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_SMIMECapabilities;
   rtxDListFastInit (pvalue);
}

void asn1Free_CMS_SMIMECapabilities (OSCTXT *pctxt, 
   ASN1T_CMS_SMIMECapabilities* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_CMS_SMIMECapability* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_CMS_SMIMECapability*)pnode->data;
      asn1Free_CMS_SMIMECapability (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CMS_SMIMECapabilities::MemFree ()
{
   asn1Free_CMS_SMIMECapabilities (getCtxtPtr(), &msgData);
}

ASN1T_CMS_SMIMEEncryptionKeyPreference* 
   new_ASN1T_CMS_SMIMEEncryptionKeyPreference (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_SMIMEEncryptionKeyPreference));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_SMIMEEncryptionKeyPreference;
}

ASN1C_CMS_SMIMEEncryptionKeyPreference::ASN1C_CMS_SMIMEEncryptionKeyPreference
    (ASN1T_CMS_SMIMEEncryptionKeyPreference& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_SMIMEEncryptionKeyPreference::
   ASN1C_CMS_SMIMEEncryptionKeyPreference (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMS_SMIMEEncryptionKeyPreference& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_SMIMEEncryptionKeyPreference::
   ASN1C_CMS_SMIMEEncryptionKeyPreference (OSRTContext &context
   , ASN1T_CMS_SMIMEEncryptionKeyPreference& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_SMIMEEncryptionKeyPreference::~ASN1T_CMS_SMIMEEncryptionKeyPreference ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_SMIMEEncryptionKeyPreference (pctxt, this);
   }
}

int ASN1C_CMS_SMIMEEncryptionKeyPreference::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_SMIMEEncryptionKeyPreference (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_SMIMEEncryptionKeyPreference::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_SMIMEEncryptionKeyPreference;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_SMIMEEncryptionKeyPreference (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_SMIMEEncryptionKeyPreference (
   ASN1T_CMS_SMIMEEncryptionKeyPreference* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_SMIMEEncryptionKeyPreference;
}

void asn1Free_CMS_SMIMEEncryptionKeyPreference (OSCTXT *pctxt, 
   ASN1T_CMS_SMIMEEncryptionKeyPreference* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.issuerAndSerialNumber) {
            asn1Free_PKCS7_IssuerAndSerialNumber (pctxt, pvalue->u.issuerAndSerialNumber);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.issuerAndSerialNumber);
         }
         break;

      case 2:
         if (0 != pvalue->u.receipentKeyId) {
            asn1Free_CMS_RecipientKeyIdentifier (pctxt, pvalue->u.receipentKeyId);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.receipentKeyId);
         }
         break;

      case 3:
         if (0 != pvalue->u.subjectAltKeyIdentifier) {
            asn1Free_CMS_SubjectKeyIdentifier (pctxt, pvalue->u.subjectAltKeyIdentifier);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.subjectAltKeyIdentifier);
         }
         break;

   }
}

void ASN1C_CMS_SMIMEEncryptionKeyPreference::MemFree ()
{
   asn1Free_CMS_SMIMEEncryptionKeyPreference (getCtxtPtr(), &msgData);
}

ASN1T_CMS_MQVuserKeyingMaterial* 
   new_ASN1T_CMS_MQVuserKeyingMaterial (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_MQVuserKeyingMaterial));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_MQVuserKeyingMaterial;
}

ASN1C_CMS_MQVuserKeyingMaterial::ASN1C_CMS_MQVuserKeyingMaterial
    (ASN1T_CMS_MQVuserKeyingMaterial& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_MQVuserKeyingMaterial::ASN1C_CMS_MQVuserKeyingMaterial (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_MQVuserKeyingMaterial& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_MQVuserKeyingMaterial::ASN1C_CMS_MQVuserKeyingMaterial (
   OSRTContext &context, ASN1T_CMS_MQVuserKeyingMaterial& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_MQVuserKeyingMaterial::ASN1T_CMS_MQVuserKeyingMaterial ()
{
   m.addedukmPresent = 0;
}

ASN1T_CMS_MQVuserKeyingMaterial::~ASN1T_CMS_MQVuserKeyingMaterial ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_MQVuserKeyingMaterial (pctxt, this);
   }
}

int ASN1C_CMS_MQVuserKeyingMaterial::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_MQVuserKeyingMaterial (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_MQVuserKeyingMaterial::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_MQVuserKeyingMaterial;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_MQVuserKeyingMaterial (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_MQVuserKeyingMaterial (
   ASN1T_CMS_MQVuserKeyingMaterial* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_MQVuserKeyingMaterial;
}

void asn1Free_CMS_MQVuserKeyingMaterial (OSCTXT *pctxt, 
   ASN1T_CMS_MQVuserKeyingMaterial* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_CMS_OriginatorPublicKey (pctxt, &pvalue->ephemeralPublicKey);
   if (pvalue->m.addedukmPresent) {
      asn1Free_CMS_UserKeyingMaterial (pctxt, &pvalue->addedukm);
   }
}

void ASN1C_CMS_MQVuserKeyingMaterial::MemFree ()
{
   asn1Free_CMS_MQVuserKeyingMaterial (getCtxtPtr(), &msgData);
}

ASN1T_CMS_ESSCertIDv2* new_ASN1T_CMS_ESSCertIDv2 (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_ESSCertIDv2));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_ESSCertIDv2;
}

ASN1C_CMS_ESSCertIDv2::ASN1C_CMS_ESSCertIDv2 (ASN1T_CMS_ESSCertIDv2& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_ESSCertIDv2::ASN1C_CMS_ESSCertIDv2 (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMS_ESSCertIDv2& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_ESSCertIDv2::ASN1C_CMS_ESSCertIDv2 (OSRTContext &context
   , ASN1T_CMS_ESSCertIDv2& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_ESSCertIDv2::ASN1T_CMS_ESSCertIDv2 ()
{
   m.hashAlgorithmPresent = 0;
   m.issuerSerialPresent = 0;
}

ASN1T_CMS_ESSCertIDv2::~ASN1T_CMS_ESSCertIDv2 ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_ESSCertIDv2 (pctxt, this);
   }
}

int ASN1C_CMS_ESSCertIDv2::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_ESSCertIDv2 (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_ESSCertIDv2::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_ESSCertIDv2;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_ESSCertIDv2 (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_ESSCertIDv2 (ASN1T_CMS_ESSCertIDv2* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_ESSCertIDv2;
}

void asn1Free_CMS_ESSCertIDv2 (OSCTXT *pctxt, ASN1T_CMS_ESSCertIDv2* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.hashAlgorithmPresent) {
      asn1Free_EXP_AlgorithmIdentifier (pctxt, &pvalue->hashAlgorithm);
   }
   if (pvalue->certHash.numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->certHash.data);
      pvalue->certHash.numocts = 0;
      pvalue->certHash.data = 0;
   }
   if (pvalue->m.issuerSerialPresent) {
      asn1Free_PKCS7_IssuerAndSerialNumber (pctxt, &pvalue->issuerSerial);
   }
}

void ASN1C_CMS_ESSCertIDv2::MemFree ()
{
   asn1Free_CMS_ESSCertIDv2 (getCtxtPtr(), &msgData);
}

ASN1T_CMS_AuthEnvelopedData* new_ASN1T_CMS_AuthEnvelopedData (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMS_AuthEnvelopedData));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMS_AuthEnvelopedData;
}

ASN1C_CMS_AuthEnvelopedData::ASN1C_CMS_AuthEnvelopedData
    (ASN1T_CMS_AuthEnvelopedData& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMS_AuthEnvelopedData::ASN1C_CMS_AuthEnvelopedData (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMS_AuthEnvelopedData& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMS_AuthEnvelopedData::ASN1C_CMS_AuthEnvelopedData (OSRTContext &context
   , ASN1T_CMS_AuthEnvelopedData& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMS_AuthEnvelopedData::ASN1T_CMS_AuthEnvelopedData ()
{
   m.originatorInfoPresent = 0;
   m.authAttrsPresent = 0;
   m.unauthAttrsPresent = 0;
}

ASN1T_CMS_AuthEnvelopedData::~ASN1T_CMS_AuthEnvelopedData ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMS_AuthEnvelopedData (pctxt, this);
   }
}

int ASN1C_CMS_AuthEnvelopedData::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMS_AuthEnvelopedData (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMS_AuthEnvelopedData::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMS_AuthEnvelopedData;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMS_AuthEnvelopedData (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMS_AuthEnvelopedData (ASN1T_CMS_AuthEnvelopedData* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMS_AuthEnvelopedData;
}

void asn1Free_CMS_AuthEnvelopedData (OSCTXT *pctxt, 
   ASN1T_CMS_AuthEnvelopedData* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.originatorInfoPresent) {
      asn1Free_CMS_OriginatorInfo (pctxt, &pvalue->originatorInfo);
   }
   asn1Free_CMS_RecipientInfos (pctxt, &pvalue->recipientInfos);
   asn1Free_PKCS7_EncryptedContentInfo (pctxt, &pvalue->authEncryptedContentInfo);
   if (pvalue->m.authAttrsPresent) {
      asn1Free_DERCMS_AuthAttributes (pctxt, &pvalue->authAttrs);
   }
   asn1Free_CMS_MessageAuthenticationCode (pctxt, &pvalue->mac);
   if (pvalue->m.unauthAttrsPresent) {
      asn1Free_CMS_UnauthAttributes (pctxt, &pvalue->unauthAttrs);
   }
}

void ASN1C_CMS_AuthEnvelopedData::MemFree ()
{
   asn1Free_CMS_AuthEnvelopedData (getCtxtPtr(), &msgData);
}

