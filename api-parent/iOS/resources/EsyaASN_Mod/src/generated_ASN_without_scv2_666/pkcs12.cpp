/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.6, Date: 20-Feb-2014.
 */
#include <new>
#include "pkcs12.h"
#include "rtxsrc/rtxCommon.h"

ASN1OBJID PKCS12_rsadsi = {
   4,
   { 1, 2, 840, 113549 }
} ;
ASN1OBJID PKCS12_pkcs = {
   5,
   { 1, 2, 840, 113549, 1 }
} ;
ASN1OBJID PKCS12_pkcs_12 = {
   6,
   { 1, 2, 840, 113549, 1, 12 }
} ;
ASN1OBJID PKCS12_pkcs_12PbeIds = {
   7,
   { 1, 2, 840, 113549, 1, 12, 1 }
} ;
ASN1OBJID PKCS12_pbeWithSHAAnd128BitRC4 = {
   8,
   { 1, 2, 840, 113549, 1, 12, 1, 1 }
} ;
ASN1OBJID PKCS12_pbeWithSHAAnd40BitRC4 = {
   8,
   { 1, 2, 840, 113549, 1, 12, 1, 2 }
} ;
ASN1OBJID PKCS12_pbeWithSHAAnd3_KeyTripleDES_CBC = {
   8,
   { 1, 2, 840, 113549, 1, 12, 1, 3 }
} ;
ASN1OBJID PKCS12_pbeWithSHAAnd2_KeyTripleDES_CBC = {
   8,
   { 1, 2, 840, 113549, 1, 12, 1, 4 }
} ;
ASN1OBJID PKCS12_pbeWithSHAAnd128BitRC2_CBC = {
   8,
   { 1, 2, 840, 113549, 1, 12, 1, 5 }
} ;
ASN1OBJID PKCS12_pbewithSHAAnd40BitRC2_CBC = {
   8,
   { 1, 2, 840, 113549, 1, 12, 1, 6 }
} ;
ASN1OBJID PKCS12_bagtypes = {
   8,
   { 1, 2, 840, 113549, 1, 12, 10, 1 }
} ;
ASN1OBJID PKCS12_certTypes = {
   7,
   { 1, 2, 840, 113549, 1, 9, 22 }
} ;
ASN1OBJID PKCS12_bagtypes_KeyBag = {
   9,
   { 1, 2, 840, 113549, 1, 12, 10, 1, 1 }
} ;
ASN1OBJID PKCS12_bagtypes_ShroudedKeyBag = {
   9,
   { 1, 2, 840, 113549, 1, 12, 10, 1, 2 }
} ;
ASN1OBJID PKCS12_bagtypes_CertBag = {
   9,
   { 1, 2, 840, 113549, 1, 12, 10, 1, 3 }
} ;
ASN1OBJID PKCS12_bagtypes_CRLBag = {
   9,
   { 1, 2, 840, 113549, 1, 12, 10, 1, 4 }
} ;
ASN1OBJID PKCS12_bagtypes_SecretBag = {
   9,
   { 1, 2, 840, 113549, 1, 12, 10, 1, 5 }
} ;
ASN1OBJID PKCS12_bagtypes_SafeContentsBag = {
   9,
   { 1, 2, 840, 113549, 1, 12, 10, 1, 6 }
} ;
ASN1OBJID PKCS12_certTypes_x509Certificate = {
   8,
   { 1, 2, 840, 113549, 1, 9, 22, 1 }
} ;
ASN1OBJID PKCS12_certTypes_sdsiCertificate = {
   8,
   { 1, 2, 840, 113549, 1, 9, 22, 2 }
} ;

ASN1T_PKCS12_KeyBag* new_ASN1T_PKCS12_KeyBag (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_PKCS12_KeyBag));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_PKCS12_KeyBag;
}

ASN1C_PKCS12_KeyBag::ASN1C_PKCS12_KeyBag (ASN1T_PKCS12_KeyBag& data) : 
   ASN1C_PKCS18_PrivateKeyInfo (data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_PKCS12_KeyBag::ASN1C_PKCS12_KeyBag (OSRTMessageBufferIF& msgBuf
   , ASN1T_PKCS12_KeyBag& data) : ASN1C_PKCS18_PrivateKeyInfo (msgBuf, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_PKCS12_KeyBag::ASN1C_PKCS12_KeyBag (OSRTContext &context
   , ASN1T_PKCS12_KeyBag& data) : ASN1C_PKCS18_PrivateKeyInfo (context, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_PKCS12_KeyBag::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_PKCS12_KeyBag (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_PKCS12_KeyBag::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_PKCS12_KeyBag;
   msgData.setContext (msgBuf.getContext());
   return asn1D_PKCS12_KeyBag (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_PKCS12_KeyBag (ASN1T_PKCS12_KeyBag* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_PKCS12_KeyBag;
}

void asn1Free_PKCS12_KeyBag (OSCTXT *pctxt, ASN1T_PKCS12_KeyBag* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_PKCS18_PrivateKeyInfo (pctxt, pvalue);
}

void ASN1C_PKCS12_KeyBag::MemFree ()
{
   asn1Free_PKCS12_KeyBag (getCtxtPtr(), &msgData);
}

ASN1T_PKCS12_PKCS8ShroudedKeyBag* 
   new_ASN1T_PKCS12_PKCS8ShroudedKeyBag (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_PKCS12_PKCS8ShroudedKeyBag));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_PKCS12_PKCS8ShroudedKeyBag;
}

ASN1C_PKCS12_PKCS8ShroudedKeyBag::ASN1C_PKCS12_PKCS8ShroudedKeyBag
    (ASN1T_PKCS12_PKCS8ShroudedKeyBag& data) : 
   ASN1C_PKCS18_EncryptedPrivateKeyInfo (data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_PKCS12_PKCS8ShroudedKeyBag::ASN1C_PKCS12_PKCS8ShroudedKeyBag (
   OSRTMessageBufferIF& msgBuf, ASN1T_PKCS12_PKCS8ShroudedKeyBag& data) : 
   ASN1C_PKCS18_EncryptedPrivateKeyInfo (msgBuf, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_PKCS12_PKCS8ShroudedKeyBag::ASN1C_PKCS12_PKCS8ShroudedKeyBag (
   OSRTContext &context, ASN1T_PKCS12_PKCS8ShroudedKeyBag& data) : 
   ASN1C_PKCS18_EncryptedPrivateKeyInfo (context, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_PKCS12_PKCS8ShroudedKeyBag::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_PKCS12_PKCS8ShroudedKeyBag (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_PKCS12_PKCS8ShroudedKeyBag::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_PKCS12_PKCS8ShroudedKeyBag;
   msgData.setContext (msgBuf.getContext());
   return asn1D_PKCS12_PKCS8ShroudedKeyBag (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_PKCS12_PKCS8ShroudedKeyBag (
   ASN1T_PKCS12_PKCS8ShroudedKeyBag* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_PKCS12_PKCS8ShroudedKeyBag;
}

void asn1Free_PKCS12_PKCS8ShroudedKeyBag (OSCTXT *pctxt, 
   ASN1T_PKCS12_PKCS8ShroudedKeyBag* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_PKCS18_EncryptedPrivateKeyInfo (pctxt, pvalue);
}

void ASN1C_PKCS12_PKCS8ShroudedKeyBag::MemFree ()
{
   asn1Free_PKCS12_PKCS8ShroudedKeyBag (getCtxtPtr(), &msgData);
}

ASN1T_PKCS12__x509Certificate_Type* 
   new_ASN1T_PKCS12__x509Certificate_Type (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_PKCS12__x509Certificate_Type));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_PKCS12__x509Certificate_Type;
}

ASN1C_PKCS12__x509Certificate_Type::ASN1C_PKCS12__x509Certificate_Type
    (ASN1T_PKCS12__x509Certificate_Type& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_PKCS12__x509Certificate_Type::ASN1C_PKCS12__x509Certificate_Type (
   OSRTMessageBufferIF& msgBuf, ASN1T_PKCS12__x509Certificate_Type& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_PKCS12__x509Certificate_Type::ASN1C_PKCS12__x509Certificate_Type (
   OSRTContext &context, ASN1T_PKCS12__x509Certificate_Type& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_PKCS12__x509Certificate_Type::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_PKCS12__x509Certificate_Type (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_PKCS12__x509Certificate_Type::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_PKCS12__x509Certificate_Type (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_PKCS12__x509Certificate_Type (
   ASN1T_PKCS12__x509Certificate_Type* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_PKCS12__x509Certificate_Type;
}

void asn1Free_PKCS12__x509Certificate_Type (OSCTXT *pctxt, 
   ASN1T_PKCS12__x509Certificate_Type* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

void ASN1C_PKCS12__x509Certificate_Type::MemFree ()
{
   asn1Free_PKCS12__x509Certificate_Type (getCtxtPtr(), &msgData);
}

ASN1T_PKCS12__x509CRL_Type* new_ASN1T_PKCS12__x509CRL_Type (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_PKCS12__x509CRL_Type));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_PKCS12__x509CRL_Type;
}

ASN1C_PKCS12__x509CRL_Type::ASN1C_PKCS12__x509CRL_Type
    (ASN1T_PKCS12__x509CRL_Type& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_PKCS12__x509CRL_Type::ASN1C_PKCS12__x509CRL_Type (
   OSRTMessageBufferIF& msgBuf, ASN1T_PKCS12__x509CRL_Type& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_PKCS12__x509CRL_Type::ASN1C_PKCS12__x509CRL_Type (OSRTContext &context
   , ASN1T_PKCS12__x509CRL_Type& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_PKCS12__x509CRL_Type::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_PKCS12__x509CRL_Type (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_PKCS12__x509CRL_Type::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_PKCS12__x509CRL_Type (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_PKCS12__x509CRL_Type (ASN1T_PKCS12__x509CRL_Type* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_PKCS12__x509CRL_Type;
}

void asn1Free_PKCS12__x509CRL_Type (OSCTXT *pctxt, 
   ASN1T_PKCS12__x509CRL_Type* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

void ASN1C_PKCS12__x509CRL_Type::MemFree ()
{
   asn1Free_PKCS12__x509CRL_Type (getCtxtPtr(), &msgData);
}

ASN1T_PKCS12_PFX_version* new_ASN1T_PKCS12_PFX_version (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_PKCS12_PFX_version));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_PKCS12_PFX_version;
}

ASN1C_PKCS12_PFX_version::ASN1C_PKCS12_PFX_version
    (ASN1T_PKCS12_PFX_version& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_PKCS12_PFX_version::ASN1C_PKCS12_PFX_version (OSRTMessageBufferIF& msgBuf
   , ASN1T_PKCS12_PFX_version& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_PKCS12_PFX_version::ASN1C_PKCS12_PFX_version (OSRTContext &context
   , ASN1T_PKCS12_PFX_version& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_PKCS12_PFX_version::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_PKCS12_PFX_version (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_PKCS12_PFX_version::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_PKCS12_PFX_version (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

ASN1T_PKCS12_MacData* new_ASN1T_PKCS12_MacData (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_PKCS12_MacData));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_PKCS12_MacData;
}

ASN1C_PKCS12_MacData::ASN1C_PKCS12_MacData (ASN1T_PKCS12_MacData& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_PKCS12_MacData::ASN1C_PKCS12_MacData (OSRTMessageBufferIF& msgBuf
   , ASN1T_PKCS12_MacData& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_PKCS12_MacData::ASN1C_PKCS12_MacData (OSRTContext &context
   , ASN1T_PKCS12_MacData& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_PKCS12_MacData::ASN1T_PKCS12_MacData ()
{
   iterations = 1;
}

ASN1T_PKCS12_MacData::~ASN1T_PKCS12_MacData ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_PKCS12_MacData (pctxt, this);
   }
}

int ASN1C_PKCS12_MacData::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_PKCS12_MacData (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_PKCS12_MacData::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_PKCS12_MacData;
   msgData.setContext (msgBuf.getContext());
   return asn1D_PKCS12_MacData (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_PKCS12_MacData (ASN1T_PKCS12_MacData* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_PKCS12_MacData;
}

void asn1Free_PKCS12_MacData (OSCTXT *pctxt, ASN1T_PKCS12_MacData* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_PKCS7_DigestInfo (pctxt, &pvalue->mac);
   if (pvalue->macSalt.numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->macSalt.data);
      pvalue->macSalt.numocts = 0;
      pvalue->macSalt.data = 0;
   }
}

void ASN1C_PKCS12_MacData::MemFree ()
{
   asn1Free_PKCS12_MacData (getCtxtPtr(), &msgData);
}

ASN1T_PKCS12_PFX* new_ASN1T_PKCS12_PFX (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_PKCS12_PFX));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_PKCS12_PFX;
}

ASN1C_PKCS12_PFX::ASN1C_PKCS12_PFX (ASN1T_PKCS12_PFX& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_PKCS12_PFX::ASN1C_PKCS12_PFX (OSRTMessageBufferIF& msgBuf
   , ASN1T_PKCS12_PFX& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_PKCS12_PFX::ASN1C_PKCS12_PFX (OSRTContext &context
   , ASN1T_PKCS12_PFX& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_PKCS12_PFX::ASN1T_PKCS12_PFX ()
{
   m.macDataPresent = 0;
}

ASN1T_PKCS12_PFX::~ASN1T_PKCS12_PFX ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_PKCS12_PFX (pctxt, this);
   }
}

int ASN1C_PKCS12_PFX::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_PKCS12_PFX (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_PKCS12_PFX::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_PKCS12_PFX;
   msgData.setContext (msgBuf.getContext());
   return asn1D_PKCS12_PFX (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_PKCS12_PFX (ASN1T_PKCS12_PFX* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_PKCS12_PFX;
}

void asn1Free_PKCS12_PFX (OSCTXT *pctxt, ASN1T_PKCS12_PFX* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_PKCS7_ContentInfo (pctxt, &pvalue->authSafe);
   if (pvalue->m.macDataPresent) {
      asn1Free_PKCS12_MacData (pctxt, &pvalue->macData);
   }
}

void ASN1C_PKCS12_PFX::MemFree ()
{
   asn1Free_PKCS12_PFX (getCtxtPtr(), &msgData);
}

ASN1C_PKCS12_AuthenticatedSafe::ASN1C_PKCS12_AuthenticatedSafe
    (ASN1T_PKCS12_AuthenticatedSafe& data) : ASN1CSeqOfList(data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_PKCS12_AuthenticatedSafe::ASN1C_PKCS12_AuthenticatedSafe (
   OSRTMessageBufferIF& msgBuf, ASN1T_PKCS12_AuthenticatedSafe& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_PKCS12_AuthenticatedSafe::ASN1C_PKCS12_AuthenticatedSafe (
   OSRTContext &context, ASN1T_PKCS12_AuthenticatedSafe& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_PKCS12_AuthenticatedSafe::
   ASN1C_PKCS12_AuthenticatedSafe (ASN1CType& ccobj
   , ASN1T_PKCS12_AuthenticatedSafe& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_PKCS12_AuthenticatedSafe::Append (ASN1T_PKCS7_ContentInfo* elem)
{
   append ((void*)elem);
}

ASN1T_PKCS7_ContentInfo* ASN1C_PKCS12_AuthenticatedSafe::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_PKCS7_ContentInfo));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_PKCS7_ContentInfo;
}

ASN1T_PKCS7_ContentInfo* ASN1C_PKCS12_AuthenticatedSafe::AppendNewElement ()
{
   ASN1T_PKCS7_ContentInfo* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_PKCS12_AuthenticatedSafe::~ASN1T_PKCS12_AuthenticatedSafe ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_PKCS12_AuthenticatedSafe (pctxt, this);
   }
}

int ASN1C_PKCS12_AuthenticatedSafe::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_PKCS12_AuthenticatedSafe (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_PKCS12_AuthenticatedSafe::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_PKCS12_AuthenticatedSafe;
   msgData.setContext (msgBuf.getContext());
   return asn1D_PKCS12_AuthenticatedSafe (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_PKCS12_AuthenticatedSafe (ASN1T_PKCS12_AuthenticatedSafe* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_PKCS12_AuthenticatedSafe;
   rtxDListFastInit (pvalue);
}

void asn1Free_PKCS12_AuthenticatedSafe (OSCTXT *pctxt, 
   ASN1T_PKCS12_AuthenticatedSafe* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_PKCS7_ContentInfo* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_PKCS7_ContentInfo*)pnode->data;
      asn1Free_PKCS7_ContentInfo (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_PKCS12_AuthenticatedSafe::MemFree ()
{
   asn1Free_PKCS12_AuthenticatedSafe (getCtxtPtr(), &msgData);
}

ASN1C_PKCS12_PKCS12Attribute_attrValues::
   ASN1C_PKCS12_PKCS12Attribute_attrValues
    (ASN1T_PKCS12_PKCS12Attribute_attrValues& data) : ASN1CSeqOfList(data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_PKCS12_PKCS12Attribute_attrValues::
   ASN1C_PKCS12_PKCS12Attribute_attrValues (OSRTMessageBufferIF& msgBuf
   , ASN1T_PKCS12_PKCS12Attribute_attrValues& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_PKCS12_PKCS12Attribute_attrValues::
   ASN1C_PKCS12_PKCS12Attribute_attrValues (OSRTContext &context
   , ASN1T_PKCS12_PKCS12Attribute_attrValues& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_PKCS12_PKCS12Attribute_attrValues::
   ASN1C_PKCS12_PKCS12Attribute_attrValues (ASN1CType& ccobj
   , ASN1T_PKCS12_PKCS12Attribute_attrValues& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_PKCS12_PKCS12Attribute_attrValues::Append (ASN1TOpenType* elem)
{
   append ((void*)elem);
}

ASN1TOpenType* ASN1C_PKCS12_PKCS12Attribute_attrValues::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1TOpenType));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1TOpenType;
}

ASN1TOpenType* ASN1C_PKCS12_PKCS12Attribute_attrValues::AppendNewElement ()
{
   ASN1TOpenType* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_PKCS12_PKCS12Attribute_attrValues::~ASN1T_PKCS12_PKCS12Attribute_attrValues ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_PKCS12_PKCS12Attribute_attrValues (pctxt, this);
   }
}

int ASN1C_PKCS12_PKCS12Attribute_attrValues::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_PKCS12_PKCS12Attribute_attrValues (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_PKCS12_PKCS12Attribute_attrValues::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_PKCS12_PKCS12Attribute_attrValues;
   msgData.setContext (msgBuf.getContext());
   return asn1D_PKCS12_PKCS12Attribute_attrValues (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_PKCS12_PKCS12Attribute_attrValues (
   ASN1T_PKCS12_PKCS12Attribute_attrValues* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_PKCS12_PKCS12Attribute_attrValues;
   rtxDListFastInit (pvalue);
}

void asn1Free_PKCS12_PKCS12Attribute_attrValues (OSCTXT *pctxt, 
   ASN1T_PKCS12_PKCS12Attribute_attrValues* pvalue)
{
   if (0 == pvalue) return;
   { ASN1TOpenType* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1TOpenType*)pnode->data;
      rtxMemFreePtr (pctxt, (void*)pdata->data);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_PKCS12_PKCS12Attribute_attrValues::MemFree ()
{
   asn1Free_PKCS12_PKCS12Attribute_attrValues (getCtxtPtr(), &msgData);
}

ASN1T_PKCS12_PKCS12Attribute* 
   new_ASN1T_PKCS12_PKCS12Attribute (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_PKCS12_PKCS12Attribute));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_PKCS12_PKCS12Attribute;
}

ASN1C_PKCS12_PKCS12Attribute::ASN1C_PKCS12_PKCS12Attribute
    (ASN1T_PKCS12_PKCS12Attribute& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_PKCS12_PKCS12Attribute::ASN1C_PKCS12_PKCS12Attribute (
   OSRTMessageBufferIF& msgBuf, ASN1T_PKCS12_PKCS12Attribute& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_PKCS12_PKCS12Attribute::ASN1C_PKCS12_PKCS12Attribute (
   OSRTContext &context, ASN1T_PKCS12_PKCS12Attribute& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_PKCS12_PKCS12Attribute::ASN1T_PKCS12_PKCS12Attribute ()
{
}

ASN1T_PKCS12_PKCS12Attribute::~ASN1T_PKCS12_PKCS12Attribute ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_PKCS12_PKCS12Attribute (pctxt, this);
   }
}

int ASN1C_PKCS12_PKCS12Attribute::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_PKCS12_PKCS12Attribute (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_PKCS12_PKCS12Attribute::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_PKCS12_PKCS12Attribute;
   msgData.setContext (msgBuf.getContext());
   return asn1D_PKCS12_PKCS12Attribute (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_PKCS12_PKCS12Attribute (ASN1T_PKCS12_PKCS12Attribute* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_PKCS12_PKCS12Attribute;
}

void asn1Free_PKCS12_PKCS12Attribute (OSCTXT *pctxt, 
   ASN1T_PKCS12_PKCS12Attribute* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_PKCS12_PKCS12Attribute_attrValues (pctxt, &pvalue->attrValues);
}

void ASN1C_PKCS12_PKCS12Attribute::MemFree ()
{
   asn1Free_PKCS12_PKCS12Attribute (getCtxtPtr(), &msgData);
}

ASN1C_PKCS12__SetOfPKCS12_PKCS12Attribute::
   ASN1C_PKCS12__SetOfPKCS12_PKCS12Attribute
    (ASN1T_PKCS12__SetOfPKCS12_PKCS12Attribute& data) : ASN1CSeqOfList(data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_PKCS12__SetOfPKCS12_PKCS12Attribute::
   ASN1C_PKCS12__SetOfPKCS12_PKCS12Attribute (OSRTMessageBufferIF& msgBuf
   , ASN1T_PKCS12__SetOfPKCS12_PKCS12Attribute& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_PKCS12__SetOfPKCS12_PKCS12Attribute::
   ASN1C_PKCS12__SetOfPKCS12_PKCS12Attribute (OSRTContext &context
   , ASN1T_PKCS12__SetOfPKCS12_PKCS12Attribute& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_PKCS12__SetOfPKCS12_PKCS12Attribute::
   ASN1C_PKCS12__SetOfPKCS12_PKCS12Attribute (ASN1CType& ccobj
   , ASN1T_PKCS12__SetOfPKCS12_PKCS12Attribute& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_PKCS12__SetOfPKCS12_PKCS12Attribute::Append (ASN1T_PKCS12_PKCS12Attribute* elem)
{
   append ((void*)elem);
}

ASN1T_PKCS12_PKCS12Attribute* ASN1C_PKCS12__SetOfPKCS12_PKCS12Attribute::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_PKCS12_PKCS12Attribute));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_PKCS12_PKCS12Attribute;
}

ASN1T_PKCS12_PKCS12Attribute* ASN1C_PKCS12__SetOfPKCS12_PKCS12Attribute::AppendNewElement ()
{
   ASN1T_PKCS12_PKCS12Attribute* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_PKCS12__SetOfPKCS12_PKCS12Attribute::~ASN1T_PKCS12__SetOfPKCS12_PKCS12Attribute ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_PKCS12__SetOfPKCS12_PKCS12Attribute (pctxt, this);
   }
}

int ASN1C_PKCS12__SetOfPKCS12_PKCS12Attribute::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_PKCS12__SetOfPKCS12_PKCS12Attribute (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_PKCS12__SetOfPKCS12_PKCS12Attribute::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_PKCS12__SetOfPKCS12_PKCS12Attribute;
   msgData.setContext (msgBuf.getContext());
   return asn1D_PKCS12__SetOfPKCS12_PKCS12Attribute (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_PKCS12__SetOfPKCS12_PKCS12Attribute (
   ASN1T_PKCS12__SetOfPKCS12_PKCS12Attribute* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_PKCS12__SetOfPKCS12_PKCS12Attribute;
   rtxDListFastInit (pvalue);
}

void asn1Free_PKCS12__SetOfPKCS12_PKCS12Attribute (OSCTXT *pctxt, 
   ASN1T_PKCS12__SetOfPKCS12_PKCS12Attribute* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_PKCS12_PKCS12Attribute* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_PKCS12_PKCS12Attribute*)pnode->data;
      asn1Free_PKCS12_PKCS12Attribute (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_PKCS12__SetOfPKCS12_PKCS12Attribute::MemFree ()
{
   asn1Free_PKCS12__SetOfPKCS12_PKCS12Attribute (getCtxtPtr(), &msgData);
}

ASN1T_PKCS12_SafeBag* new_ASN1T_PKCS12_SafeBag (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_PKCS12_SafeBag));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_PKCS12_SafeBag;
}

ASN1C_PKCS12_SafeBag::ASN1C_PKCS12_SafeBag (ASN1T_PKCS12_SafeBag& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_PKCS12_SafeBag::ASN1C_PKCS12_SafeBag (OSRTMessageBufferIF& msgBuf
   , ASN1T_PKCS12_SafeBag& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_PKCS12_SafeBag::ASN1C_PKCS12_SafeBag (OSRTContext &context
   , ASN1T_PKCS12_SafeBag& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_PKCS12_SafeBag::ASN1T_PKCS12_SafeBag ()
{
   m.bagAttributesPresent = 0;
}

ASN1T_PKCS12_SafeBag::~ASN1T_PKCS12_SafeBag ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_PKCS12_SafeBag (pctxt, this);
   }
}

int ASN1C_PKCS12_SafeBag::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_PKCS12_SafeBag (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_PKCS12_SafeBag::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_PKCS12_SafeBag;
   msgData.setContext (msgBuf.getContext());
   return asn1D_PKCS12_SafeBag (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_PKCS12_SafeBag (ASN1T_PKCS12_SafeBag* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_PKCS12_SafeBag;
}

void asn1Free_PKCS12_SafeBag (OSCTXT *pctxt, ASN1T_PKCS12_SafeBag* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreePtr (pctxt, (void*)pvalue->bagValue.data);
   if (pvalue->m.bagAttributesPresent) {
      asn1Free_PKCS12__SetOfPKCS12_PKCS12Attribute (pctxt, &pvalue->bagAttributes);
   }
}

void ASN1C_PKCS12_SafeBag::MemFree ()
{
   asn1Free_PKCS12_SafeBag (getCtxtPtr(), &msgData);
}

ASN1C_PKCS12_SafeContents::ASN1C_PKCS12_SafeContents
    (ASN1T_PKCS12_SafeContents& data) : ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_PKCS12_SafeContents::ASN1C_PKCS12_SafeContents (
   OSRTMessageBufferIF& msgBuf, ASN1T_PKCS12_SafeContents& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_PKCS12_SafeContents::ASN1C_PKCS12_SafeContents (OSRTContext &context
   , ASN1T_PKCS12_SafeContents& data) : ASN1CSeqOfList(context, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_PKCS12_SafeContents::ASN1C_PKCS12_SafeContents (ASN1CType& ccobj
   , ASN1T_PKCS12_SafeContents& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_PKCS12_SafeContents::Append (ASN1T_PKCS12_SafeBag* elem)
{
   append ((void*)elem);
}

ASN1T_PKCS12_SafeBag* ASN1C_PKCS12_SafeContents::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_PKCS12_SafeBag));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_PKCS12_SafeBag;
}

ASN1T_PKCS12_SafeBag* ASN1C_PKCS12_SafeContents::AppendNewElement ()
{
   ASN1T_PKCS12_SafeBag* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_PKCS12_SafeContents::~ASN1T_PKCS12_SafeContents ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_PKCS12_SafeContents (pctxt, this);
   }
}

int ASN1C_PKCS12_SafeContents::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_PKCS12_SafeContents (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_PKCS12_SafeContents::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_PKCS12_SafeContents;
   msgData.setContext (msgBuf.getContext());
   return asn1D_PKCS12_SafeContents (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_PKCS12_SafeContents (ASN1T_PKCS12_SafeContents* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_PKCS12_SafeContents;
   rtxDListFastInit (pvalue);
}

void asn1Free_PKCS12_SafeContents (OSCTXT *pctxt, 
   ASN1T_PKCS12_SafeContents* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_PKCS12_SafeBag* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_PKCS12_SafeBag*)pnode->data;
      asn1Free_PKCS12_SafeBag (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_PKCS12_SafeContents::MemFree ()
{
   asn1Free_PKCS12_SafeContents (getCtxtPtr(), &msgData);
}

ASN1T_PKCS12_CertBag* new_ASN1T_PKCS12_CertBag (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_PKCS12_CertBag));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_PKCS12_CertBag;
}

ASN1C_PKCS12_CertBag::ASN1C_PKCS12_CertBag (ASN1T_PKCS12_CertBag& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_PKCS12_CertBag::ASN1C_PKCS12_CertBag (OSRTMessageBufferIF& msgBuf
   , ASN1T_PKCS12_CertBag& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_PKCS12_CertBag::ASN1C_PKCS12_CertBag (OSRTContext &context
   , ASN1T_PKCS12_CertBag& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_PKCS12_CertBag::ASN1T_PKCS12_CertBag ()
{
}

ASN1T_PKCS12_CertBag::~ASN1T_PKCS12_CertBag ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_PKCS12_CertBag (pctxt, this);
   }
}

int ASN1C_PKCS12_CertBag::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_PKCS12_CertBag (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_PKCS12_CertBag::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_PKCS12_CertBag;
   msgData.setContext (msgBuf.getContext());
   return asn1D_PKCS12_CertBag (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_PKCS12_CertBag (ASN1T_PKCS12_CertBag* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_PKCS12_CertBag;
}

void asn1Free_PKCS12_CertBag (OSCTXT *pctxt, ASN1T_PKCS12_CertBag* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreePtr (pctxt, (void*)pvalue->certValue.data);
}

void ASN1C_PKCS12_CertBag::MemFree ()
{
   asn1Free_PKCS12_CertBag (getCtxtPtr(), &msgData);
}

ASN1T_PKCS12_CRLBag* new_ASN1T_PKCS12_CRLBag (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_PKCS12_CRLBag));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_PKCS12_CRLBag;
}

ASN1C_PKCS12_CRLBag::ASN1C_PKCS12_CRLBag (ASN1T_PKCS12_CRLBag& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_PKCS12_CRLBag::ASN1C_PKCS12_CRLBag (OSRTMessageBufferIF& msgBuf
   , ASN1T_PKCS12_CRLBag& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_PKCS12_CRLBag::ASN1C_PKCS12_CRLBag (OSRTContext &context
   , ASN1T_PKCS12_CRLBag& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_PKCS12_CRLBag::ASN1T_PKCS12_CRLBag ()
{
}

ASN1T_PKCS12_CRLBag::~ASN1T_PKCS12_CRLBag ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_PKCS12_CRLBag (pctxt, this);
   }
}

int ASN1C_PKCS12_CRLBag::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_PKCS12_CRLBag (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_PKCS12_CRLBag::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_PKCS12_CRLBag;
   msgData.setContext (msgBuf.getContext());
   return asn1D_PKCS12_CRLBag (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_PKCS12_CRLBag (ASN1T_PKCS12_CRLBag* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_PKCS12_CRLBag;
}

void asn1Free_PKCS12_CRLBag (OSCTXT *pctxt, ASN1T_PKCS12_CRLBag* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreePtr (pctxt, (void*)pvalue->crltValue.data);
}

void ASN1C_PKCS12_CRLBag::MemFree ()
{
   asn1Free_PKCS12_CRLBag (getCtxtPtr(), &msgData);
}

ASN1T_PKCS12_SecretBag* new_ASN1T_PKCS12_SecretBag (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_PKCS12_SecretBag));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_PKCS12_SecretBag;
}

ASN1C_PKCS12_SecretBag::ASN1C_PKCS12_SecretBag (ASN1T_PKCS12_SecretBag& data)
    : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_PKCS12_SecretBag::ASN1C_PKCS12_SecretBag (OSRTMessageBufferIF& msgBuf
   , ASN1T_PKCS12_SecretBag& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_PKCS12_SecretBag::ASN1C_PKCS12_SecretBag (OSRTContext &context
   , ASN1T_PKCS12_SecretBag& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_PKCS12_SecretBag::ASN1T_PKCS12_SecretBag ()
{
}

ASN1T_PKCS12_SecretBag::~ASN1T_PKCS12_SecretBag ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_PKCS12_SecretBag (pctxt, this);
   }
}

int ASN1C_PKCS12_SecretBag::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_PKCS12_SecretBag (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_PKCS12_SecretBag::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_PKCS12_SecretBag;
   msgData.setContext (msgBuf.getContext());
   return asn1D_PKCS12_SecretBag (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_PKCS12_SecretBag (ASN1T_PKCS12_SecretBag* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_PKCS12_SecretBag;
}

void asn1Free_PKCS12_SecretBag (OSCTXT *pctxt, ASN1T_PKCS12_SecretBag* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreePtr (pctxt, (void*)pvalue->secretValue.data);
}

void ASN1C_PKCS12_SecretBag::MemFree ()
{
   asn1Free_PKCS12_SecretBag (getCtxtPtr(), &msgData);
}

ASN1T_PKCS12_PKCS12PbeParams* 
   new_ASN1T_PKCS12_PKCS12PbeParams (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_PKCS12_PKCS12PbeParams));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_PKCS12_PKCS12PbeParams;
}

ASN1C_PKCS12_PKCS12PbeParams::ASN1C_PKCS12_PKCS12PbeParams
    (ASN1T_PKCS12_PKCS12PbeParams& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_PKCS12_PKCS12PbeParams::ASN1C_PKCS12_PKCS12PbeParams (
   OSRTMessageBufferIF& msgBuf, ASN1T_PKCS12_PKCS12PbeParams& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_PKCS12_PKCS12PbeParams::ASN1C_PKCS12_PKCS12PbeParams (
   OSRTContext &context, ASN1T_PKCS12_PKCS12PbeParams& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_PKCS12_PKCS12PbeParams::ASN1T_PKCS12_PKCS12PbeParams ()
{
}

ASN1T_PKCS12_PKCS12PbeParams::~ASN1T_PKCS12_PKCS12PbeParams ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_PKCS12_PKCS12PbeParams (pctxt, this);
   }
}

int ASN1C_PKCS12_PKCS12PbeParams::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_PKCS12_PKCS12PbeParams (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_PKCS12_PKCS12PbeParams::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_PKCS12_PKCS12PbeParams;
   msgData.setContext (msgBuf.getContext());
   return asn1D_PKCS12_PKCS12PbeParams (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_PKCS12_PKCS12PbeParams (ASN1T_PKCS12_PKCS12PbeParams* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_PKCS12_PKCS12PbeParams;
}

void asn1Free_PKCS12_PKCS12PbeParams (OSCTXT *pctxt, 
   ASN1T_PKCS12_PKCS12PbeParams* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->salt.numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->salt.data);
      pvalue->salt.numocts = 0;
      pvalue->salt.data = 0;
   }
}

void ASN1C_PKCS12_PKCS12PbeParams::MemFree ()
{
   asn1Free_PKCS12_PKCS12PbeParams (getCtxtPtr(), &msgData);
}

