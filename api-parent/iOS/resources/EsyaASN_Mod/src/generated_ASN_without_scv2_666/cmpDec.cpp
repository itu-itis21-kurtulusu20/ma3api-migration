/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.6, Date: 20-Feb-2014.
 */
#include "cmp.h"
#include "rtxsrc/rtxCommon.h"

EXTERN int asn1D_CMP_PKIProtection (OSCTXT* pctxt, 
   ASN1T_CMP_PKIProtection* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PKIProtection");

   stat = xd_bitstr (pctxt, &pvalue->data, &pvalue->numbits, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_PKIHeader_pvno (OSCTXT* pctxt, 
   ASN1T_CMP_PKIHeader_pvno* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_integer (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   return (stat);
}

EXTERN int asn1D_CMP_PKIFreeText (OSCTXT* pctxt, 
   ASN1T_CMP_PKIFreeText* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   const OSUTF8CHAR* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "PKIFreeText");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "UTF8String", pvalue->count);

      pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_utf8str (pctxt, &pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      pnode->data = (void*)pdata1;
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_InfoTypeAndValue (OSCTXT* pctxt, 
   ASN1T_CMP_InfoTypeAndValue* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "InfoTypeAndValue");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode infoType */
         RTXCTXTPUSHELEMNAME (pctxt, "infoType");

         stat = xd_objid (pctxt, (ASN1OBJID*)&pvalue->infoType, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode infoValue */
         RTXCTXTPUSHELEMNAME (pctxt, "infoValue");

         stat = xd_OpenType (pctxt, &pvalue->infoValue.data, &pvalue->infoValue.numocts);
         if (stat == 0) {
            pvalue->m.infoValuePresent = TRUE;
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_PKIHeader_generalInfo (OSCTXT* pctxt, 
   ASN1T_CMP_PKIHeader_generalInfo* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_CMP_InfoTypeAndValue* pdata1;
   OSRTDListNode* pnode;
   int len = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x88, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   len = length;

   stat = xd_match1 (pctxt, ASN_SEQ_TAG, &length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "InfoTypeAndValue", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_CMP_InfoTypeAndValue, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CMP_InfoTypeAndValue (pdata1);

      stat = asn1D_CMP_InfoTypeAndValue (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

EXTERN int asn1D_CMP_PKIHeader (OSCTXT* pctxt, ASN1T_CMP_PKIHeader* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "PKIHeader");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode pvno */
         RTXCTXTPUSHELEMNAME (pctxt, "pvno");

         stat = asn1D_CMP_PKIHeader_pvno (pctxt, &pvalue->pvno, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode sender */
         RTXCTXTPUSHELEMNAME (pctxt, "sender");

         stat = asn1D_IMP_GeneralName (pctxt, &pvalue->sender, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode recipient */
         RTXCTXTPUSHELEMNAME (pctxt, "recipient");

         stat = asn1D_IMP_GeneralName (pctxt, &pvalue->recipient, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 3:
         /* decode messageTime */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "messageTime");

            stat = xd_charstr (pctxt, &pvalue->messageTime, ASN1EXPL, 
               (TM_UNIV|TM_PRIM|24), length);
            if (stat == 0) {
               pvalue->m.messageTimePresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 4:
         /* decode protectionAlg */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "protectionAlg");

            stat = asn1D_EXP_AlgorithmIdentifier (pctxt, &pvalue->protectionAlg
               , ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.protectionAlgPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 5:
         /* decode senderKID */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "senderKID");

            stat = asn1D_IMP_KeyIdentifier (pctxt, &pvalue->senderKID, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.senderKIDPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 6:
         /* decode recipKID */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "recipKID");

            stat = asn1D_IMP_KeyIdentifier (pctxt, &pvalue->recipKID, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.recipKIDPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 7:
         /* decode transactionID */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "transactionID");

            stat = xd_octstr (pctxt, &pvalue->transactionID.data, &pvalue->transactionID.numocts, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.transactionIDPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 8:
         /* decode senderNonce */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "senderNonce");

            stat = xd_octstr (pctxt, &pvalue->senderNonce.data, &pvalue->senderNonce.numocts, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.senderNoncePresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 9:
         /* decode recipNonce */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "recipNonce");

            stat = xd_octstr (pctxt, &pvalue->recipNonce.data, &pvalue->recipNonce.numocts, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.recipNoncePresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 10:
         /* decode freeText */
         if (XD_PEEKTAG (pctxt, 0x87)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "freeText");

            stat = asn1D_CMP_PKIFreeText (pctxt, &pvalue->freeText, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.freeTextPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 11:
         /* decode generalInfo */
         if (XD_PEEKTAG (pctxt, 0x88)) {
            RTXCTXTPUSHELEMNAME (pctxt, "generalInfo");

            stat = asn1D_CMP_PKIHeader_generalInfo (pctxt, &pvalue->generalInfo
               , ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.generalInfoPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_CMPCertificate (OSCTXT* pctxt, 
   ASN1T_CMP_CMPCertificate* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "CMPCertificate");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_UNIV|TM_CONS|16):
         RTXCTXTPUSHELEMNAME (pctxt, "x509v3PKCert");

         pvalue->u.x509v3PKCert = rtxMemAllocType (pctxt, 
            ASN1T_EXP_Certificate);

         if (pvalue->u.x509v3PKCert == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_EXP_Certificate (pvalue->u.x509v3PKCert);
         stat = asn1D_EXP_Certificate (pctxt, pvalue->u.x509v3PKCert, 
            ASN1IMPL, length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_CertRepMessage_caPubs (OSCTXT* pctxt, 
   ASN1T_CMP_CertRepMessage_caPubs* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_CMP_CMPCertificate* pdata1;
   OSRTDListNode* pnode;
   int len = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x81, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   len = length;

   stat = xd_match1 (pctxt, ASN_SEQ_TAG, &length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CMPCertificate", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_CMP_CMPCertificate, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CMP_CMPCertificate (pdata1);

      stat = asn1D_CMP_CMPCertificate (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

EXTERN int asn1D_CMP_PKIStatus (OSCTXT* pctxt, ASN1T_CMP_PKIStatus* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PKIStatus");

   stat = xd_integer (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_PKIFailureInfo (OSCTXT* pctxt, 
   ASN1T_CMP_PKIFailureInfo* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PKIFailureInfo");

   pvalue->numbits = 27;
   stat = xd_bitstr_s (pctxt, pvalue->data, &pvalue->numbits, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_PKIStatusInfo (OSCTXT* pctxt, 
   ASN1T_CMP_PKIStatusInfo* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "PKIStatusInfo");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode status */
         RTXCTXTPUSHELEMNAME (pctxt, "status");

         stat = asn1D_CMP_PKIStatus (pctxt, &pvalue->status, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode statusString */
         if (XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "statusString");

            stat = asn1D_CMP_PKIFreeText (pctxt, &pvalue->statusString, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.statusStringPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 2:
         /* decode failInfo */
         if (XD_PEEKTAG (pctxt, 0x3)) {
            RTXCTXTPUSHELEMNAME (pctxt, "failInfo");

            stat = asn1D_CMP_PKIFailureInfo (pctxt, &pvalue->failInfo, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.failInfoPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|2):
         case (TM_UNIV|TM_CONS|16):
         case (TM_UNIV|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_CertOrEncCert (OSCTXT* pctxt, 
   ASN1T_CMP_CertOrEncCert* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "CertOrEncCert");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         RTXCTXTPUSHELEMNAME (pctxt, "certificate");

         pvalue->u.certificate = rtxMemAllocType (pctxt, 
            ASN1T_CMP_CMPCertificate);

         if (pvalue->u.certificate == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CMP_CMPCertificate (pvalue->u.certificate);
         stat = asn1D_CMP_CMPCertificate (pctxt, pvalue->u.certificate, 
            ASN1EXPL, length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|1):
         RTXCTXTPUSHELEMNAME (pctxt, "encryptedCert");

         pvalue->u.encryptedCert = rtxMemAllocType (pctxt, 
            ASN1T_CRMF_EncryptedValue);

         if (pvalue->u.encryptedCert == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CRMF_EncryptedValue (pvalue->u.encryptedCert);
         stat = asn1D_CRMF_EncryptedValue (pctxt, pvalue->u.encryptedCert, 
            ASN1EXPL, length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_CertifiedKeyPair (OSCTXT* pctxt, 
   ASN1T_CMP_CertifiedKeyPair* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "CertifiedKeyPair");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode certOrEncCert */
         RTXCTXTPUSHELEMNAME (pctxt, "certOrEncCert");

         stat = asn1D_CMP_CertOrEncCert (pctxt, &pvalue->certOrEncCert, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode privateKey */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "privateKey");

            stat = asn1D_CRMF_EncryptedValue (pctxt, &pvalue->privateKey, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.privateKeyPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 2:
         /* decode publicationInfo */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "publicationInfo");

            stat = asn1D_CRMF_PKIPublicationInfo (pctxt, &pvalue->
               publicationInfo, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.publicationInfoPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_CertResponse (OSCTXT* pctxt, 
   ASN1T_CMP_CertResponse* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "CertResponse");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode certReqId */
         RTXCTXTPUSHELEMNAME (pctxt, "certReqId");

         stat = xd_integer (pctxt, &pvalue->certReqId, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode status */
         RTXCTXTPUSHELEMNAME (pctxt, "status");

         stat = asn1D_CMP_PKIStatusInfo (pctxt, &pvalue->status, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode certifiedKeyPair */
         if (XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "certifiedKeyPair");

            stat = asn1D_CMP_CertifiedKeyPair (pctxt, &pvalue->certifiedKeyPair
               , ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.certifiedKeyPairPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 3:
         /* decode rspInfo */
         if (XD_PEEKTAG (pctxt, 0x4)) {
            RTXCTXTPUSHELEMNAME (pctxt, "rspInfo");

            stat = xd_octstr (pctxt, &pvalue->rspInfo.data, &pvalue->rspInfo.numocts, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.rspInfoPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|2):
         case (TM_UNIV|TM_CONS|16):
         case (TM_UNIV|TM_PRIM|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP__SeqOfCMP_CertResponse (OSCTXT* pctxt, 
   ASN1T_CMP__SeqOfCMP_CertResponse* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_CMP_CertResponse* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CertResponse", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_CMP_CertResponse, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CMP_CertResponse (pdata1);

      stat = asn1D_CMP_CertResponse (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1D_CMP_CertRepMessage (OSCTXT* pctxt, 
   ASN1T_CMP_CertRepMessage* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "CertRepMessage");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode caPubs */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            RTXCTXTPUSHELEMNAME (pctxt, "caPubs");

            stat = asn1D_CMP_CertRepMessage_caPubs (pctxt, &pvalue->caPubs, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.caPubsPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 1:
         /* decode response */
         RTXCTXTPUSHELEMNAME (pctxt, "response");

         stat = asn1D_CMP__SeqOfCMP_CertResponse (pctxt, &pvalue->response, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|1):
         case (TM_UNIV|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_Challenge (OSCTXT* pctxt, ASN1T_CMP_Challenge* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "Challenge");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode owf */
         if (XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "owf");

            stat = asn1D_EXP_AlgorithmIdentifier (pctxt, &pvalue->owf, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.owfPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 1:
         /* decode witness */
         RTXCTXTPUSHELEMNAME (pctxt, "witness");

         stat = xd_octstr (pctxt, &pvalue->witness.data, &pvalue->witness.numocts, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode challenge */
         RTXCTXTPUSHELEMNAME (pctxt, "challenge");

         stat = xd_octstr (pctxt, &pvalue->challenge.data, &pvalue->challenge.numocts, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_CONS|16):
         case (TM_UNIV|TM_PRIM|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_POPODecKeyChallContent (OSCTXT* pctxt, 
   ASN1T_CMP_POPODecKeyChallContent* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_CMP_Challenge* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "POPODecKeyChallContent");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "Challenge", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_CMP_Challenge, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CMP_Challenge (pdata1);

      stat = asn1D_CMP_Challenge (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_POPODecKeyRespContent (OSCTXT* pctxt, 
   ASN1T_CMP_POPODecKeyRespContent* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   OSINT32* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "POPODecKeyRespContent");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "INTEGER", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, OSINT32, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_integer (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_KeyRecRepContent_caCerts (OSCTXT* pctxt, 
   ASN1T_CMP_KeyRecRepContent_caCerts* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_CMP_CMPCertificate* pdata1;
   OSRTDListNode* pnode;
   int len = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x81, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   len = length;

   stat = xd_match1 (pctxt, ASN_SEQ_TAG, &length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CMPCertificate", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_CMP_CMPCertificate, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CMP_CMPCertificate (pdata1);

      stat = asn1D_CMP_CMPCertificate (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

EXTERN int asn1D_CMP_KeyRecRepContent_keyPairHist (OSCTXT* pctxt, 
   ASN1T_CMP_KeyRecRepContent_keyPairHist* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1T_CMP_CertifiedKeyPair* pdata1;
   OSRTDListNode* pnode;
   int len = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x82, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   len = length;

   stat = xd_match1 (pctxt, ASN_SEQ_TAG, &length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CertifiedKeyPair", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_CMP_CertifiedKeyPair, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CMP_CertifiedKeyPair (pdata1);

      stat = asn1D_CMP_CertifiedKeyPair (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

EXTERN int asn1D_CMP_KeyRecRepContent (OSCTXT* pctxt, 
   ASN1T_CMP_KeyRecRepContent* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "KeyRecRepContent");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode status */
         RTXCTXTPUSHELEMNAME (pctxt, "status");

         stat = asn1D_CMP_PKIStatusInfo (pctxt, &pvalue->status, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode newSigCert */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "newSigCert");

            stat = asn1D_CMP_CMPCertificate (pctxt, &pvalue->newSigCert, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.newSigCertPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 2:
         /* decode caCerts */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            RTXCTXTPUSHELEMNAME (pctxt, "caCerts");

            stat = asn1D_CMP_KeyRecRepContent_caCerts (pctxt, &pvalue->caCerts
               , ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.caCertsPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 3:
         /* decode keyPairHist */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            RTXCTXTPUSHELEMNAME (pctxt, "keyPairHist");

            stat = asn1D_CMP_KeyRecRepContent_keyPairHist (pctxt, &pvalue->
               keyPairHist, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.keyPairHistPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_CONS|16):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_RevDetails (OSCTXT* pctxt, ASN1T_CMP_RevDetails* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "RevDetails");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode certDetails */
         RTXCTXTPUSHELEMNAME (pctxt, "certDetails");

         stat = asn1D_CRMF_CertTemplate (pctxt, &pvalue->certDetails, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode crlEntryDetails */
         if (XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "crlEntryDetails");

            stat = asn1D_EXP_Extensions (pctxt, &pvalue->crlEntryDetails, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.crlEntryDetailsPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_RevReqContent (OSCTXT* pctxt, 
   ASN1T_CMP_RevReqContent* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_CMP_RevDetails* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "RevReqContent");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RevDetails", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_CMP_RevDetails, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CMP_RevDetails (pdata1);

      stat = asn1D_CMP_RevDetails (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_RevRepContent_status (OSCTXT* pctxt, 
   ASN1T_CMP_RevRepContent_status* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_CMP_PKIStatusInfo* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PKIStatusInfo", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_CMP_PKIStatusInfo, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CMP_PKIStatusInfo (pdata1);

      stat = asn1D_CMP_PKIStatusInfo (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

EXTERN int asn1D_CMP_RevRepContent_revCerts (OSCTXT* pctxt, 
   ASN1T_CMP_RevRepContent_revCerts* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_CRMF_CertId* pdata1;
   OSRTDListNode* pnode;
   int len = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x80, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   len = length;

   stat = xd_match1 (pctxt, ASN_SEQ_TAG, &length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CertId", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_CRMF_CertId, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CRMF_CertId (pdata1);

      stat = asn1D_CRMF_CertId (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

EXTERN int asn1D_CMP_RevRepContent_crls (OSCTXT* pctxt, 
   ASN1T_CMP_RevRepContent_crls* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_EXP_CertificateList* pdata1;
   OSRTDListNode* pnode;
   int len = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x81, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   len = length;

   stat = xd_match1 (pctxt, ASN_SEQ_TAG, &length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CertificateList", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_EXP_CertificateList, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EXP_CertificateList (pdata1);

      stat = asn1D_EXP_CertificateList (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

EXTERN int asn1D_CMP_RevRepContent (OSCTXT* pctxt, 
   ASN1T_CMP_RevRepContent* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "RevRepContent");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode status */
         RTXCTXTPUSHELEMNAME (pctxt, "status");

         stat = asn1D_CMP_RevRepContent_status (pctxt, &pvalue->status, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode revCerts */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            RTXCTXTPUSHELEMNAME (pctxt, "revCerts");

            stat = asn1D_CMP_RevRepContent_revCerts (pctxt, &pvalue->revCerts, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.revCertsPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 2:
         /* decode crls */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            RTXCTXTPUSHELEMNAME (pctxt, "crls");

            stat = asn1D_CMP_RevRepContent_crls (pctxt, &pvalue->crls, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.crlsPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_CONS|16):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_CAKeyUpdAnnContent (OSCTXT* pctxt, 
   ASN1T_CMP_CAKeyUpdAnnContent* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "CAKeyUpdAnnContent");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode oldWithNew */
         RTXCTXTPUSHELEMNAME (pctxt, "oldWithNew");

         stat = asn1D_CMP_CMPCertificate (pctxt, &pvalue->oldWithNew, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode newWithOld */
         RTXCTXTPUSHELEMNAME (pctxt, "newWithOld");

         stat = asn1D_CMP_CMPCertificate (pctxt, &pvalue->newWithOld, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode newWithNew */
         RTXCTXTPUSHELEMNAME (pctxt, "newWithNew");

         stat = asn1D_CMP_CMPCertificate (pctxt, &pvalue->newWithNew, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_CertAnnContent (OSCTXT* pctxt, 
   ASN1T_CMP_CertAnnContent* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CertAnnContent");

   stat = asn1D_CMP_CMPCertificate (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_RevAnnContent (OSCTXT* pctxt, 
   ASN1T_CMP_RevAnnContent* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "RevAnnContent");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode status */
         RTXCTXTPUSHELEMNAME (pctxt, "status");

         stat = asn1D_CMP_PKIStatus (pctxt, &pvalue->status, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode certId */
         RTXCTXTPUSHELEMNAME (pctxt, "certId");

         stat = asn1D_CRMF_CertId (pctxt, &pvalue->certId, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode willBeRevokedAt */
         RTXCTXTPUSHELEMNAME (pctxt, "willBeRevokedAt");

         stat = xd_charstr (pctxt, &pvalue->willBeRevokedAt, ASN1EXPL, 
            (TM_UNIV|TM_PRIM|24), length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 3:
         /* decode badSinceDate */
         RTXCTXTPUSHELEMNAME (pctxt, "badSinceDate");

         stat = xd_charstr (pctxt, &pvalue->badSinceDate, ASN1EXPL, 
            (TM_UNIV|TM_PRIM|24), length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 4:
         /* decode crlDetails */
         if (XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "crlDetails");

            stat = asn1D_EXP_Extensions (pctxt, &pvalue->crlDetails, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.crlDetailsPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|2):
         case (TM_UNIV|TM_CONS|16):
         case (TM_UNIV|TM_PRIM|24):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 4) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_CRLAnnContent (OSCTXT* pctxt, 
   ASN1T_CMP_CRLAnnContent* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_EXP_CertificateList* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "CRLAnnContent");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CertificateList", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_EXP_CertificateList, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EXP_CertificateList (pdata1);

      stat = asn1D_EXP_CertificateList (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_PKIConfirmContent_ (OSCTXT* pctxt, void* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   OS_UNUSED_ARG(pvalue) ;
   OS_UNUSED_ARG(length) ;

   RTXCTXTPUSHTYPENAME (pctxt, "PKIConfirmContent");

   stat = xd_null (pctxt, tagging);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_GenMsgContent (OSCTXT* pctxt, 
   ASN1T_CMP_GenMsgContent* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_CMP_InfoTypeAndValue* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "GenMsgContent");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "InfoTypeAndValue", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_CMP_InfoTypeAndValue, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CMP_InfoTypeAndValue (pdata1);

      stat = asn1D_CMP_InfoTypeAndValue (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_GenRepContent (OSCTXT* pctxt, 
   ASN1T_CMP_GenRepContent* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_CMP_InfoTypeAndValue* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "GenRepContent");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "InfoTypeAndValue", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_CMP_InfoTypeAndValue, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CMP_InfoTypeAndValue (pdata1);

      stat = asn1D_CMP_InfoTypeAndValue (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_ErrorMsgContent (OSCTXT* pctxt, 
   ASN1T_CMP_ErrorMsgContent* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "ErrorMsgContent");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode pKIStatusInfo */
         RTXCTXTPUSHELEMNAME (pctxt, "pKIStatusInfo");

         stat = asn1D_CMP_PKIStatusInfo (pctxt, &pvalue->pKIStatusInfo, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode errorCode */
         if (XD_PEEKTAG (pctxt, 0x2)) {
            RTXCTXTPUSHELEMNAME (pctxt, "errorCode");

            stat = xd_integer (pctxt, &pvalue->errorCode, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.errorCodePresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 2:
         /* decode errorDetails */
         if (XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "errorDetails");

            stat = asn1D_CMP_PKIFreeText (pctxt, &pvalue->errorDetails, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.errorDetailsPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_CONS|16):
         case (TM_UNIV|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_CertStatus (OSCTXT* pctxt, ASN1T_CMP_CertStatus* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "CertStatus");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode certHash */
         RTXCTXTPUSHELEMNAME (pctxt, "certHash");

         stat = xd_octstr (pctxt, &pvalue->certHash.data, &pvalue->certHash.numocts, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode certReqId */
         RTXCTXTPUSHELEMNAME (pctxt, "certReqId");

         stat = xd_integer (pctxt, &pvalue->certReqId, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode statusInfo */
         if (XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "statusInfo");

            stat = asn1D_CMP_PKIStatusInfo (pctxt, &pvalue->statusInfo, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.statusInfoPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|4):
         case (TM_UNIV|TM_PRIM|2):
         case (TM_UNIV|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_CertConfirmContent (OSCTXT* pctxt, 
   ASN1T_CMP_CertConfirmContent* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_CMP_CertStatus* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "CertConfirmContent");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CertStatus", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_CMP_CertStatus, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CMP_CertStatus (pdata1);

      stat = asn1D_CMP_CertStatus (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_PollReqContent_element (OSCTXT* pctxt, 
   ASN1T_CMP_PollReqContent_element* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode certReqId */
         RTXCTXTPUSHELEMNAME (pctxt, "certReqId");

         stat = xd_integer (pctxt, &pvalue->certReqId, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   return (stat);
}

EXTERN int asn1D_CMP_PollReqContent (OSCTXT* pctxt, 
   ASN1T_CMP_PollReqContent* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_CMP_PollReqContent_element* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "PollReqContent");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_CMP_PollReqContent_element, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1D_CMP_PollReqContent_element (pctxt, pdata1, 
         ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_PollRepContent_element (OSCTXT* pctxt, 
   ASN1T_CMP_PollRepContent_element* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode certReqId */
         RTXCTXTPUSHELEMNAME (pctxt, "certReqId");

         stat = xd_integer (pctxt, &pvalue->certReqId, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode checkAfter */
         RTXCTXTPUSHELEMNAME (pctxt, "checkAfter");

         stat = xd_integer (pctxt, &pvalue->checkAfter, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode reason */
         if (XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "reason");

            stat = asn1D_CMP_PKIFreeText (pctxt, &pvalue->reason, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.reasonPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|2):
         case (TM_UNIV|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   return (stat);
}

EXTERN int asn1D_CMP_PollRepContent (OSCTXT* pctxt, 
   ASN1T_CMP_PollRepContent* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_CMP_PollRepContent_element* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "PollRepContent");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_CMP_PollRepContent_element, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CMP_PollRepContent_element (pdata1);

      stat = asn1D_CMP_PollRepContent_element (pctxt, pdata1, 
         ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_PKIBody (OSCTXT* pctxt, ASN1T_CMP_PKIBody* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "PKIBody");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         RTXCTXTPUSHELEMNAME (pctxt, "ir");

         pvalue->u.ir = rtxMemAllocType (pctxt, ASN1T_CRMF_CertReqMessages);

         if (pvalue->u.ir == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CRMF_CertReqMessages (pvalue->u.ir);
         stat = asn1D_CRMF_CertReqMessages (pctxt, pvalue->u.ir, 
            ASN1EXPL, length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|1):
         RTXCTXTPUSHELEMNAME (pctxt, "ip");

         pvalue->u.ip = rtxMemAllocType (pctxt, ASN1T_CMP_CertRepMessage);

         if (pvalue->u.ip == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CMP_CertRepMessage (pvalue->u.ip);
         stat = asn1D_CMP_CertRepMessage (pctxt, pvalue->u.ip, 
            ASN1EXPL, length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|2):
         RTXCTXTPUSHELEMNAME (pctxt, "cr");

         pvalue->u.cr = rtxMemAllocType (pctxt, ASN1T_CRMF_CertReqMessages);

         if (pvalue->u.cr == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CRMF_CertReqMessages (pvalue->u.cr);
         stat = asn1D_CRMF_CertReqMessages (pctxt, pvalue->u.cr, 
            ASN1EXPL, length);
         pvalue->t = 3;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|3):
         RTXCTXTPUSHELEMNAME (pctxt, "cp");

         pvalue->u.cp = rtxMemAllocType (pctxt, ASN1T_CMP_CertRepMessage);

         if (pvalue->u.cp == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CMP_CertRepMessage (pvalue->u.cp);
         stat = asn1D_CMP_CertRepMessage (pctxt, pvalue->u.cp, 
            ASN1EXPL, length);
         pvalue->t = 4;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|4):
         RTXCTXTPUSHELEMNAME (pctxt, "p10cr");

         pvalue->u.p10cr = rtxMemAllocType (pctxt, 
            ASN1T_PKCS10_CertificationRequest);

         if (pvalue->u.p10cr == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_PKCS10_CertificationRequest (pvalue->u.p10cr);
         stat = asn1D_PKCS10_CertificationRequest (pctxt, pvalue->u.p10cr, 
            ASN1EXPL, length);
         pvalue->t = 5;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|5):
         RTXCTXTPUSHELEMNAME (pctxt, "popdecc");

         pvalue->u.popdecc = rtxMemAllocType (pctxt, 
            ASN1T_CMP_POPODecKeyChallContent);

         if (pvalue->u.popdecc == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CMP_POPODecKeyChallContent (pvalue->u.popdecc);
         stat = asn1D_CMP_POPODecKeyChallContent (pctxt, pvalue->u.popdecc, 
            ASN1EXPL, length);
         pvalue->t = 6;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|6):
         RTXCTXTPUSHELEMNAME (pctxt, "popdecr");

         pvalue->u.popdecr = rtxMemAllocType (pctxt, 
            ASN1T_CMP_POPODecKeyRespContent);

         if (pvalue->u.popdecr == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CMP_POPODecKeyRespContent (pvalue->u.popdecr);
         stat = asn1D_CMP_POPODecKeyRespContent (pctxt, pvalue->u.popdecr, 
            ASN1EXPL, length);
         pvalue->t = 7;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|7):
         RTXCTXTPUSHELEMNAME (pctxt, "kur");

         pvalue->u.kur = rtxMemAllocType (pctxt, ASN1T_CRMF_CertReqMessages);

         if (pvalue->u.kur == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CRMF_CertReqMessages (pvalue->u.kur);
         stat = asn1D_CRMF_CertReqMessages (pctxt, pvalue->u.kur, 
            ASN1EXPL, length);
         pvalue->t = 8;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|8):
         RTXCTXTPUSHELEMNAME (pctxt, "kup");

         pvalue->u.kup = rtxMemAllocType (pctxt, ASN1T_CMP_CertRepMessage);

         if (pvalue->u.kup == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CMP_CertRepMessage (pvalue->u.kup);
         stat = asn1D_CMP_CertRepMessage (pctxt, pvalue->u.kup, 
            ASN1EXPL, length);
         pvalue->t = 9;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|9):
         RTXCTXTPUSHELEMNAME (pctxt, "krr");

         pvalue->u.krr = rtxMemAllocType (pctxt, ASN1T_CRMF_CertReqMessages);

         if (pvalue->u.krr == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CRMF_CertReqMessages (pvalue->u.krr);
         stat = asn1D_CRMF_CertReqMessages (pctxt, pvalue->u.krr, 
            ASN1EXPL, length);
         pvalue->t = 10;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|10):
         RTXCTXTPUSHELEMNAME (pctxt, "krp");

         pvalue->u.krp = rtxMemAllocType (pctxt, ASN1T_CMP_KeyRecRepContent);

         if (pvalue->u.krp == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CMP_KeyRecRepContent (pvalue->u.krp);
         stat = asn1D_CMP_KeyRecRepContent (pctxt, pvalue->u.krp, 
            ASN1EXPL, length);
         pvalue->t = 11;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|11):
         RTXCTXTPUSHELEMNAME (pctxt, "rr");

         pvalue->u.rr = rtxMemAllocType (pctxt, ASN1T_CMP_RevReqContent);

         if (pvalue->u.rr == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CMP_RevReqContent (pvalue->u.rr);
         stat = asn1D_CMP_RevReqContent (pctxt, pvalue->u.rr, 
            ASN1EXPL, length);
         pvalue->t = 12;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|12):
         RTXCTXTPUSHELEMNAME (pctxt, "rp");

         pvalue->u.rp = rtxMemAllocType (pctxt, ASN1T_CMP_RevRepContent);

         if (pvalue->u.rp == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CMP_RevRepContent (pvalue->u.rp);
         stat = asn1D_CMP_RevRepContent (pctxt, pvalue->u.rp, 
            ASN1EXPL, length);
         pvalue->t = 13;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|13):
         RTXCTXTPUSHELEMNAME (pctxt, "ccr");

         pvalue->u.ccr = rtxMemAllocType (pctxt, ASN1T_CRMF_CertReqMessages);

         if (pvalue->u.ccr == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CRMF_CertReqMessages (pvalue->u.ccr);
         stat = asn1D_CRMF_CertReqMessages (pctxt, pvalue->u.ccr, 
            ASN1EXPL, length);
         pvalue->t = 14;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|14):
         RTXCTXTPUSHELEMNAME (pctxt, "ccp");

         pvalue->u.ccp = rtxMemAllocType (pctxt, ASN1T_CMP_CertRepMessage);

         if (pvalue->u.ccp == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CMP_CertRepMessage (pvalue->u.ccp);
         stat = asn1D_CMP_CertRepMessage (pctxt, pvalue->u.ccp, 
            ASN1EXPL, length);
         pvalue->t = 15;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|15):
         RTXCTXTPUSHELEMNAME (pctxt, "ckuann");

         pvalue->u.ckuann = rtxMemAllocType (pctxt, 
            ASN1T_CMP_CAKeyUpdAnnContent);

         if (pvalue->u.ckuann == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CMP_CAKeyUpdAnnContent (pvalue->u.ckuann);
         stat = asn1D_CMP_CAKeyUpdAnnContent (pctxt, pvalue->u.ckuann, 
            ASN1EXPL, length);
         pvalue->t = 16;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|16):
         RTXCTXTPUSHELEMNAME (pctxt, "cann");

         pvalue->u.cann = rtxMemAllocType (pctxt, ASN1T_CMP_CertAnnContent);

         if (pvalue->u.cann == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CMP_CertAnnContent (pvalue->u.cann);
         stat = asn1D_CMP_CertAnnContent (pctxt, pvalue->u.cann, 
            ASN1EXPL, length);
         pvalue->t = 17;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|17):
         RTXCTXTPUSHELEMNAME (pctxt, "rann");

         pvalue->u.rann = rtxMemAllocType (pctxt, ASN1T_CMP_RevAnnContent);

         if (pvalue->u.rann == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CMP_RevAnnContent (pvalue->u.rann);
         stat = asn1D_CMP_RevAnnContent (pctxt, pvalue->u.rann, 
            ASN1EXPL, length);
         pvalue->t = 18;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|18):
         RTXCTXTPUSHELEMNAME (pctxt, "crlann");

         pvalue->u.crlann = rtxMemAllocType (pctxt, ASN1T_CMP_CRLAnnContent);

         if (pvalue->u.crlann == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CMP_CRLAnnContent (pvalue->u.crlann);
         stat = asn1D_CMP_CRLAnnContent (pctxt, pvalue->u.crlann, 
            ASN1EXPL, length);
         pvalue->t = 19;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|19):
         RTXCTXTPUSHELEMNAME (pctxt, "pkiconf");

         stat = asn1D_CMP_PKIConfirmContent (pctxt, ASN1EXPL, length);
         pvalue->t = 20;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|20):
         RTXCTXTPUSHELEMNAME (pctxt, "nested");

         pvalue->u.nested = rtxMemAllocType (pctxt, 
            ASN1T_CMP_NestedMessageContent);

         if (pvalue->u.nested == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CMP_NestedMessageContent ((ASN1T_CMP_NestedMessageContent*)pvalue->u.nested);
         stat = asn1D_CMP_NestedMessageContent (pctxt, 
            (ASN1T_CMP_NestedMessageContent*)pvalue->u.nested, 
            ASN1EXPL, length);
         pvalue->t = 21;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|21):
         RTXCTXTPUSHELEMNAME (pctxt, "genm");

         pvalue->u.genm = rtxMemAllocType (pctxt, ASN1T_CMP_GenMsgContent);

         if (pvalue->u.genm == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CMP_GenMsgContent (pvalue->u.genm);
         stat = asn1D_CMP_GenMsgContent (pctxt, pvalue->u.genm, 
            ASN1EXPL, length);
         pvalue->t = 22;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|22):
         RTXCTXTPUSHELEMNAME (pctxt, "genp");

         pvalue->u.genp = rtxMemAllocType (pctxt, ASN1T_CMP_GenRepContent);

         if (pvalue->u.genp == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CMP_GenRepContent (pvalue->u.genp);
         stat = asn1D_CMP_GenRepContent (pctxt, pvalue->u.genp, 
            ASN1EXPL, length);
         pvalue->t = 23;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|23):
         RTXCTXTPUSHELEMNAME (pctxt, "error");

         pvalue->u.error = rtxMemAllocType (pctxt, ASN1T_CMP_ErrorMsgContent);

         if (pvalue->u.error == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CMP_ErrorMsgContent (pvalue->u.error);
         stat = asn1D_CMP_ErrorMsgContent (pctxt, pvalue->u.error, 
            ASN1EXPL, length);
         pvalue->t = 24;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|24):
         RTXCTXTPUSHELEMNAME (pctxt, "certConf");

         pvalue->u.certConf = rtxMemAllocType (pctxt, 
            ASN1T_CMP_CertConfirmContent);

         if (pvalue->u.certConf == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CMP_CertConfirmContent (pvalue->u.certConf);
         stat = asn1D_CMP_CertConfirmContent (pctxt, pvalue->u.certConf, 
            ASN1EXPL, length);
         pvalue->t = 25;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|25):
         RTXCTXTPUSHELEMNAME (pctxt, "pollReq");

         pvalue->u.pollReq = rtxMemAllocType (pctxt, 
            ASN1T_CMP_PollReqContent);

         if (pvalue->u.pollReq == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CMP_PollReqContent (pvalue->u.pollReq);
         stat = asn1D_CMP_PollReqContent (pctxt, pvalue->u.pollReq, 
            ASN1EXPL, length);
         pvalue->t = 26;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|26):
         RTXCTXTPUSHELEMNAME (pctxt, "pollRep");

         pvalue->u.pollRep = rtxMemAllocType (pctxt, 
            ASN1T_CMP_PollRepContent);

         if (pvalue->u.pollRep == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CMP_PollRepContent (pvalue->u.pollRep);
         stat = asn1D_CMP_PollRepContent (pctxt, pvalue->u.pollRep, 
            ASN1EXPL, length);
         pvalue->t = 27;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|27):
         RTXCTXTPUSHELEMNAME (pctxt, "bcr");

         pvalue->u.bcr = rtxMemAllocType (pctxt, ASN1T_CRMF_CertReqMessages);

         if (pvalue->u.bcr == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_CRMF_CertReqMessages (pvalue->u.bcr);
         stat = asn1D_CRMF_CertReqMessages (pctxt, pvalue->u.bcr, 
            ASN1EXPL, length);
         pvalue->t = 28;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_PKIMessage_extraCerts (OSCTXT* pctxt, 
   ASN1T_CMP_PKIMessage_extraCerts* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_CMP_CMPCertificate* pdata1;
   OSRTDListNode* pnode;
   int len = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x81, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   len = length;

   stat = xd_match1 (pctxt, ASN_SEQ_TAG, &length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CMPCertificate", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_CMP_CMPCertificate, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CMP_CMPCertificate (pdata1);

      stat = asn1D_CMP_CMPCertificate (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

EXTERN int asn1D_CMP_PKIMessage (OSCTXT* pctxt, ASN1T_CMP_PKIMessage* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "PKIMessage");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode header */
         RTXCTXTPUSHELEMNAME (pctxt, "header");

         stat = asn1D_CMP_PKIHeader (pctxt, &pvalue->header, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode body */
         RTXCTXTPUSHELEMNAME (pctxt, "body");

         stat = asn1D_CMP_PKIBody (pctxt, &pvalue->body, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode protection */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "protection");

            stat = asn1D_CMP_PKIProtection (pctxt, &pvalue->protection, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.protectionPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 3:
         /* decode extraCerts */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            RTXCTXTPUSHELEMNAME (pctxt, "extraCerts");

            stat = asn1D_CMP_PKIMessage_extraCerts (pctxt, &pvalue->extraCerts
               , ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.extraCertsPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_CONS|16):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_CONS|17):
         case (TM_CTXT|TM_CONS|18):
         case (TM_CTXT|TM_CONS|19):
         case (TM_CTXT|TM_CONS|20):
         case (TM_CTXT|TM_CONS|21):
         case (TM_CTXT|TM_CONS|22):
         case (TM_CTXT|TM_CONS|23):
         case (TM_CTXT|TM_CONS|24):
         case (TM_CTXT|TM_CONS|25):
         case (TM_CTXT|TM_CONS|26):
         case (TM_CTXT|TM_CONS|27):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_PKIMessages (OSCTXT* pctxt, 
   ASN1T_CMP_PKIMessages* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_CMP_PKIMessage* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "PKIMessages");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PKIMessage", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_CMP_PKIMessage, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_CMP_PKIMessage (pdata1);

      stat = asn1D_CMP_PKIMessage (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_NestedMessageContent (OSCTXT* pctxt, 
   ASN1T_CMP_NestedMessageContent* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NestedMessageContent");

   stat = asn1D_CMP_PKIMessages (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_OOBCert (OSCTXT* pctxt, ASN1T_CMP_OOBCert* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "OOBCert");

   stat = asn1D_CMP_CMPCertificate (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_ProtectedPart (OSCTXT* pctxt, 
   ASN1T_CMP_ProtectedPart* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "ProtectedPart");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode header */
         RTXCTXTPUSHELEMNAME (pctxt, "header");

         stat = asn1D_CMP_PKIHeader (pctxt, &pvalue->header, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode body */
         RTXCTXTPUSHELEMNAME (pctxt, "body");

         stat = asn1D_CMP_PKIBody (pctxt, &pvalue->body, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_CONS|16):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
         case (TM_CTXT|TM_CONS|7):
         case (TM_CTXT|TM_CONS|8):
         case (TM_CTXT|TM_CONS|9):
         case (TM_CTXT|TM_CONS|10):
         case (TM_CTXT|TM_CONS|11):
         case (TM_CTXT|TM_CONS|12):
         case (TM_CTXT|TM_CONS|13):
         case (TM_CTXT|TM_CONS|14):
         case (TM_CTXT|TM_CONS|15):
         case (TM_CTXT|TM_CONS|16):
         case (TM_CTXT|TM_CONS|17):
         case (TM_CTXT|TM_CONS|18):
         case (TM_CTXT|TM_CONS|19):
         case (TM_CTXT|TM_CONS|20):
         case (TM_CTXT|TM_CONS|21):
         case (TM_CTXT|TM_CONS|22):
         case (TM_CTXT|TM_CONS|23):
         case (TM_CTXT|TM_CONS|24):
         case (TM_CTXT|TM_CONS|25):
         case (TM_CTXT|TM_CONS|26):
         case (TM_CTXT|TM_CONS|27):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_PBMParameter (OSCTXT* pctxt, 
   ASN1T_CMP_PBMParameter* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "PBMParameter");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode salt */
         RTXCTXTPUSHELEMNAME (pctxt, "salt");

         stat = xd_octstr (pctxt, &pvalue->salt.data, &pvalue->salt.numocts, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode owf */
         RTXCTXTPUSHELEMNAME (pctxt, "owf");

         stat = asn1D_EXP_AlgorithmIdentifier (pctxt, &pvalue->owf, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode iterationCount */
         RTXCTXTPUSHELEMNAME (pctxt, "iterationCount");

         stat = xd_integer (pctxt, &pvalue->iterationCount, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 3:
         /* decode mac */
         RTXCTXTPUSHELEMNAME (pctxt, "mac");

         stat = asn1D_EXP_AlgorithmIdentifier (pctxt, &pvalue->mac, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|4):
         case (TM_UNIV|TM_CONS|16):
         case (TM_UNIV|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 4) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_DHBMParameter (OSCTXT* pctxt, 
   ASN1T_CMP_DHBMParameter* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "DHBMParameter");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode owf */
         RTXCTXTPUSHELEMNAME (pctxt, "owf");

         stat = asn1D_EXP_AlgorithmIdentifier (pctxt, &pvalue->owf, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode mac */
         RTXCTXTPUSHELEMNAME (pctxt, "mac");

         stat = asn1D_EXP_AlgorithmIdentifier (pctxt, &pvalue->mac, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_CMP_OOBCertHash (OSCTXT* pctxt, 
   ASN1T_CMP_OOBCertHash* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "OOBCertHash");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode hashAlg */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "hashAlg");

            stat = asn1D_EXP_AlgorithmIdentifier (pctxt, &pvalue->hashAlg, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.hashAlgPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 1:
         /* decode certId */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "certId");

            stat = asn1D_CRMF_CertId (pctxt, &pvalue->certId, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.certIdPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 2:
         /* decode hashVal */
         RTXCTXTPUSHELEMNAME (pctxt, "hashVal");

         stat = xd_bitstr (pctxt, &pvalue->hashVal.data, &pvalue->hashVal.numbits, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_UNIV|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

