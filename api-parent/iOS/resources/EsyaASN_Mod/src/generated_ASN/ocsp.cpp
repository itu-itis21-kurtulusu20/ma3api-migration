/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.6, Date: 28-Feb-2014.
 */
#include <new>
#include "ocsp.h"
#include "UsefulDefinitions.h"
#include "rtxsrc/rtxCommon.h"

ASN1OBJID OCSP_id_at_initials = {
   4,
   { 2, 5, 4, 43 }
} ;
ASN1OBJID OCSP_id_at_generationQualifier = {
   4,
   { 2, 5, 4, 44 }
} ;
ASN1OBJID OCSP_id_pkix_ocsp = {
   9,
   { 1, 3, 6, 1, 5, 5, 7, 48, 1 }
} ;
ASN1OBJID OCSP_id_pkix_ocsp_basic = {
   10,
   { 1, 3, 6, 1, 5, 5, 7, 48, 1, 1 }
} ;
ASN1OBJID OCSP_id_pkix_ocsp_nonce = {
   10,
   { 1, 3, 6, 1, 5, 5, 7, 48, 1, 2 }
} ;
ASN1OBJID OCSP_id_pkix_ocsp_crl = {
   10,
   { 1, 3, 6, 1, 5, 5, 7, 48, 1, 3 }
} ;
ASN1OBJID OCSP_id_pkix_ocsp_response = {
   10,
   { 1, 3, 6, 1, 5, 5, 7, 48, 1, 4 }
} ;
ASN1OBJID OCSP_id_pkix_ocsp_nocheck = {
   10,
   { 1, 3, 6, 1, 5, 5, 7, 48, 1, 5 }
} ;
ASN1OBJID OCSP_id_pkix_ocsp_archive_cutoff = {
   10,
   { 1, 3, 6, 1, 5, 5, 7, 48, 1, 6 }
} ;
ASN1OBJID OCSP_id_pkix_ocsp_service_locator = {
   10,
   { 1, 3, 6, 1, 5, 5, 7, 48, 1, 7 }
} ;

ASN1T_OCSP_Version* new_ASN1T_OCSP_Version (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_OCSP_Version));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_OCSP_Version;
}

ASN1C_OCSP_Version::ASN1C_OCSP_Version (ASN1T_OCSP_Version& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_OCSP_Version::ASN1C_OCSP_Version (OSRTMessageBufferIF& msgBuf
   , ASN1T_OCSP_Version& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_OCSP_Version::ASN1C_OCSP_Version (OSRTContext &context
   , ASN1T_OCSP_Version& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_OCSP_Version::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_OCSP_Version (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_OCSP_Version::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_OCSP_Version (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

static const OSEnumItem ASN1T_OCSP_OCSPResponseStatus_ENUMTAB[] = {
   { OSUTF8("internalError"), 2, 13, 3 },
   { OSUTF8("malformedRequest"), 1, 16, 1 },
   { OSUTF8("sigRequired"), 5, 11, 0 },
   { OSUTF8("successful"), 0, 10, 4 },
   { OSUTF8("tryLater"), 3, 8, 2 },
   { OSUTF8("unauthorized"), 6, 12, 5 }
} ;
#define ASN1T_OCSP_OCSPResponseStatus_ENUMTABSIZE 6

const OSUTF8CHAR* ASN1T_OCSP_OCSPResponseStatus_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, 
      ASN1T_OCSP_OCSPResponseStatus_ENUMTAB, 
      ASN1T_OCSP_OCSPResponseStatus_ENUMTABSIZE);

   if (idx >= 0 && idx < ASN1T_OCSP_OCSPResponseStatus_ENUMTABSIZE) {
      return ASN1T_OCSP_OCSPResponseStatus_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ASN1T_OCSP_OCSPResponseStatus_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ASN1T_OCSP_OCSPResponseStatus* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ASN1T_OCSP_OCSPResponseStatus_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ASN1T_OCSP_OCSPResponseStatus_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, 
      ASN1T_OCSP_OCSPResponseStatus* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ASN1T_OCSP_OCSPResponseStatus_ENUMTAB, 
      ASN1T_OCSP_OCSPResponseStatus_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ASN1T_OCSP_OCSPResponseStatus)
         ASN1T_OCSP_OCSPResponseStatus_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

ASN1T_OCSP_OCSPResponseStatus* 
   new_ASN1T_OCSP_OCSPResponseStatus (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_OCSP_OCSPResponseStatus));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_OCSP_OCSPResponseStatus;
}

ASN1C_OCSP_OCSPResponseStatus::ASN1C_OCSP_OCSPResponseStatus
    (ASN1T_OCSP_OCSPResponseStatus& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_OCSP_OCSPResponseStatus::ASN1C_OCSP_OCSPResponseStatus (
   OSRTMessageBufferIF& msgBuf, ASN1T_OCSP_OCSPResponseStatus& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_OCSP_OCSPResponseStatus::ASN1C_OCSP_OCSPResponseStatus (
   OSRTContext &context, ASN1T_OCSP_OCSPResponseStatus& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_OCSP_OCSPResponseStatus::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_OCSP_OCSPResponseStatus (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_OCSP_OCSPResponseStatus::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_OCSP_OCSPResponseStatus (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

ASN1T_OCSP_KeyHash* new_ASN1T_OCSP_KeyHash (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_OCSP_KeyHash));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_OCSP_KeyHash;
}

ASN1C_OCSP_KeyHash::ASN1C_OCSP_KeyHash (ASN1T_OCSP_KeyHash& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_OCSP_KeyHash::ASN1C_OCSP_KeyHash (OSRTMessageBufferIF& msgBuf
   , ASN1T_OCSP_KeyHash& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_OCSP_KeyHash::ASN1C_OCSP_KeyHash (OSRTContext &context
   , ASN1T_OCSP_KeyHash& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_OCSP_KeyHash::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_OCSP_KeyHash (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_OCSP_KeyHash::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_OCSP_KeyHash (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_OCSP_KeyHash (ASN1T_OCSP_KeyHash* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_OCSP_KeyHash;
}

void asn1Free_OCSP_KeyHash (OSCTXT *pctxt, ASN1T_OCSP_KeyHash* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

void ASN1C_OCSP_KeyHash::MemFree ()
{
   asn1Free_OCSP_KeyHash (getCtxtPtr(), &msgData);
}

static const OSEnumItem ASN1T_OCSP_CRLReason_ENUMTAB[] = {
   { OSUTF8("affiliationChanged"), 3, 18, 7 },
   { OSUTF8("cACompromise"), 2, 12, 4 },
   { OSUTF8("certificateHold"), 6, 15, 1 },
   { OSUTF8("cessationOfOperation"), 5, 20, 0 },
   { OSUTF8("keyCompromise"), 1, 13, 6 },
   { OSUTF8("removeFromCRL"), 8, 13, 3 },
   { OSUTF8("superseded"), 4, 10, 2 },
   { OSUTF8("unspecified"), 0, 11, 5 }
} ;
#define ASN1T_OCSP_CRLReason_ENUMTABSIZE 8

const OSUTF8CHAR* ASN1T_OCSP_CRLReason_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, ASN1T_OCSP_CRLReason_ENUMTAB, 
      ASN1T_OCSP_CRLReason_ENUMTABSIZE);

   if (idx >= 0 && idx < ASN1T_OCSP_CRLReason_ENUMTABSIZE) {
      return ASN1T_OCSP_CRLReason_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ASN1T_OCSP_CRLReason_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ASN1T_OCSP_CRLReason* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ASN1T_OCSP_CRLReason_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ASN1T_OCSP_CRLReason_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ASN1T_OCSP_CRLReason* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ASN1T_OCSP_CRLReason_ENUMTAB, 
      ASN1T_OCSP_CRLReason_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ASN1T_OCSP_CRLReason)ASN1T_OCSP_CRLReason_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

ASN1T_OCSP_CRLReason* new_ASN1T_OCSP_CRLReason (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_OCSP_CRLReason));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_OCSP_CRLReason;
}

ASN1C_OCSP_CRLReason::ASN1C_OCSP_CRLReason (ASN1T_OCSP_CRLReason& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_OCSP_CRLReason::ASN1C_OCSP_CRLReason (OSRTMessageBufferIF& msgBuf
   , ASN1T_OCSP_CRLReason& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_OCSP_CRLReason::ASN1C_OCSP_CRLReason (OSRTContext &context
   , ASN1T_OCSP_CRLReason& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_OCSP_CRLReason::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_OCSP_CRLReason (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_OCSP_CRLReason::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_OCSP_CRLReason (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

ASN1T_OCSP_CertID* new_ASN1T_OCSP_CertID (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_OCSP_CertID));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_OCSP_CertID;
}

ASN1C_OCSP_CertID::ASN1C_OCSP_CertID (ASN1T_OCSP_CertID& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_OCSP_CertID::ASN1C_OCSP_CertID (OSRTMessageBufferIF& msgBuf
   , ASN1T_OCSP_CertID& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_OCSP_CertID::ASN1C_OCSP_CertID (OSRTContext &context
   , ASN1T_OCSP_CertID& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_OCSP_CertID::ASN1T_OCSP_CertID ()
{
}

ASN1T_OCSP_CertID::~ASN1T_OCSP_CertID ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_OCSP_CertID (pctxt, this);
   }
}

int ASN1C_OCSP_CertID::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_OCSP_CertID (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_OCSP_CertID::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_OCSP_CertID;
   msgData.setContext (msgBuf.getContext());
   return asn1D_OCSP_CertID (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_OCSP_CertID (ASN1T_OCSP_CertID* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_OCSP_CertID;
}

void asn1Free_OCSP_CertID (OSCTXT *pctxt, ASN1T_OCSP_CertID* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_EXP_AlgorithmIdentifier (pctxt, &pvalue->hashAlgorithm);
   if (pvalue->issuerNameHash.numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->issuerNameHash.data);
      pvalue->issuerNameHash.numocts = 0;
      pvalue->issuerNameHash.data = 0;
   }
   if (pvalue->issuerKeyHash.numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->issuerKeyHash.data);
      pvalue->issuerKeyHash.numocts = 0;
      pvalue->issuerKeyHash.data = 0;
   }
}

void ASN1C_OCSP_CertID::MemFree ()
{
   asn1Free_OCSP_CertID (getCtxtPtr(), &msgData);
}

ASN1T_OCSP_Request* new_ASN1T_OCSP_Request (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_OCSP_Request));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_OCSP_Request;
}

ASN1C_OCSP_Request::ASN1C_OCSP_Request (ASN1T_OCSP_Request& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_OCSP_Request::ASN1C_OCSP_Request (OSRTMessageBufferIF& msgBuf
   , ASN1T_OCSP_Request& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_OCSP_Request::ASN1C_OCSP_Request (OSRTContext &context
   , ASN1T_OCSP_Request& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_OCSP_Request::ASN1T_OCSP_Request ()
{
   m.singleRequestExtensionsPresent = 0;
}

ASN1T_OCSP_Request::~ASN1T_OCSP_Request ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_OCSP_Request (pctxt, this);
   }
}

int ASN1C_OCSP_Request::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_OCSP_Request (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_OCSP_Request::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_OCSP_Request;
   msgData.setContext (msgBuf.getContext());
   return asn1D_OCSP_Request (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_OCSP_Request (ASN1T_OCSP_Request* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_OCSP_Request;
}

void asn1Free_OCSP_Request (OSCTXT *pctxt, ASN1T_OCSP_Request* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_OCSP_CertID (pctxt, &pvalue->reqCert);
   if (pvalue->m.singleRequestExtensionsPresent) {
      asn1Free_EXP_Extensions (pctxt, &pvalue->singleRequestExtensions);
   }
}

void ASN1C_OCSP_Request::MemFree ()
{
   asn1Free_OCSP_Request (getCtxtPtr(), &msgData);
}

ASN1C_OCSP__SeqOfOCSP_Request::ASN1C_OCSP__SeqOfOCSP_Request
    (ASN1T_OCSP__SeqOfOCSP_Request& data) : ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_OCSP__SeqOfOCSP_Request::ASN1C_OCSP__SeqOfOCSP_Request (
   OSRTMessageBufferIF& msgBuf, ASN1T_OCSP__SeqOfOCSP_Request& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_OCSP__SeqOfOCSP_Request::ASN1C_OCSP__SeqOfOCSP_Request (
   OSRTContext &context, ASN1T_OCSP__SeqOfOCSP_Request& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_OCSP__SeqOfOCSP_Request::ASN1C_OCSP__SeqOfOCSP_Request (ASN1CType& ccobj
   , ASN1T_OCSP__SeqOfOCSP_Request& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_OCSP__SeqOfOCSP_Request::Append (ASN1T_OCSP_Request* elem)
{
   append ((void*)elem);
}

ASN1T_OCSP_Request* ASN1C_OCSP__SeqOfOCSP_Request::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_OCSP_Request));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_OCSP_Request;
}

ASN1T_OCSP_Request* ASN1C_OCSP__SeqOfOCSP_Request::AppendNewElement ()
{
   ASN1T_OCSP_Request* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_OCSP__SeqOfOCSP_Request::~ASN1T_OCSP__SeqOfOCSP_Request ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_OCSP__SeqOfOCSP_Request (pctxt, this);
   }
}

int ASN1C_OCSP__SeqOfOCSP_Request::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_OCSP__SeqOfOCSP_Request (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_OCSP__SeqOfOCSP_Request::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_OCSP__SeqOfOCSP_Request;
   msgData.setContext (msgBuf.getContext());
   return asn1D_OCSP__SeqOfOCSP_Request (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_OCSP__SeqOfOCSP_Request (ASN1T_OCSP__SeqOfOCSP_Request* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_OCSP__SeqOfOCSP_Request;
   rtxDListFastInit (pvalue);
}

void asn1Free_OCSP__SeqOfOCSP_Request (OSCTXT *pctxt, 
   ASN1T_OCSP__SeqOfOCSP_Request* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_OCSP_Request* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_OCSP_Request*)pnode->data;
      asn1Free_OCSP_Request (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_OCSP__SeqOfOCSP_Request::MemFree ()
{
   asn1Free_OCSP__SeqOfOCSP_Request (getCtxtPtr(), &msgData);
}

ASN1T_OCSP_TBSRequest* new_ASN1T_OCSP_TBSRequest (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_OCSP_TBSRequest));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_OCSP_TBSRequest;
}

ASN1C_OCSP_TBSRequest::ASN1C_OCSP_TBSRequest (ASN1T_OCSP_TBSRequest& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_OCSP_TBSRequest::ASN1C_OCSP_TBSRequest (OSRTMessageBufferIF& msgBuf
   , ASN1T_OCSP_TBSRequest& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_OCSP_TBSRequest::ASN1C_OCSP_TBSRequest (OSRTContext &context
   , ASN1T_OCSP_TBSRequest& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_OCSP_TBSRequest::ASN1T_OCSP_TBSRequest ()
{
   version = OCSP_Version::v1;
   m.requestorNamePresent = 0;
   m.requestExtensionsPresent = 0;
}

ASN1T_OCSP_TBSRequest::~ASN1T_OCSP_TBSRequest ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_OCSP_TBSRequest (pctxt, this);
   }
}

int ASN1C_OCSP_TBSRequest::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_OCSP_TBSRequest (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_OCSP_TBSRequest::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_OCSP_TBSRequest;
   msgData.setContext (msgBuf.getContext());
   return asn1D_OCSP_TBSRequest (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_OCSP_TBSRequest (ASN1T_OCSP_TBSRequest* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_OCSP_TBSRequest;
}

void asn1Free_OCSP_TBSRequest (OSCTXT *pctxt, ASN1T_OCSP_TBSRequest* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.requestorNamePresent) {
      asn1Free_IMP_GeneralName (pctxt, &pvalue->requestorName);
   }
   asn1Free_OCSP__SeqOfOCSP_Request (pctxt, &pvalue->requestList);
   if (pvalue->m.requestExtensionsPresent) {
      asn1Free_EXP_Extensions (pctxt, &pvalue->requestExtensions);
   }
}

void ASN1C_OCSP_TBSRequest::MemFree ()
{
   asn1Free_OCSP_TBSRequest (getCtxtPtr(), &msgData);
}

ASN1C_OCSP__SeqOfOCSP_Certificate::ASN1C_OCSP__SeqOfOCSP_Certificate
    (ASN1T_OCSP__SeqOfOCSP_Certificate& data) : ASN1CSeqOfList(data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_OCSP__SeqOfOCSP_Certificate::ASN1C_OCSP__SeqOfOCSP_Certificate (
   OSRTMessageBufferIF& msgBuf, ASN1T_OCSP__SeqOfOCSP_Certificate& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_OCSP__SeqOfOCSP_Certificate::ASN1C_OCSP__SeqOfOCSP_Certificate (
   OSRTContext &context, ASN1T_OCSP__SeqOfOCSP_Certificate& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_OCSP__SeqOfOCSP_Certificate::
   ASN1C_OCSP__SeqOfOCSP_Certificate (ASN1CType& ccobj
   , ASN1T_OCSP__SeqOfOCSP_Certificate& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_OCSP__SeqOfOCSP_Certificate::Append (ASN1T_EXP_Certificate* elem)
{
   append ((void*)elem);
}

ASN1T_EXP_Certificate* ASN1C_OCSP__SeqOfOCSP_Certificate::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_EXP_Certificate));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_EXP_Certificate;
}

ASN1T_EXP_Certificate* ASN1C_OCSP__SeqOfOCSP_Certificate::AppendNewElement ()
{
   ASN1T_EXP_Certificate* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_OCSP__SeqOfOCSP_Certificate::~ASN1T_OCSP__SeqOfOCSP_Certificate ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_OCSP__SeqOfOCSP_Certificate (pctxt, this);
   }
}

int ASN1C_OCSP__SeqOfOCSP_Certificate::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_OCSP__SeqOfOCSP_Certificate (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_OCSP__SeqOfOCSP_Certificate::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_OCSP__SeqOfOCSP_Certificate;
   msgData.setContext (msgBuf.getContext());
   return asn1D_OCSP__SeqOfOCSP_Certificate (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_OCSP__SeqOfOCSP_Certificate (
   ASN1T_OCSP__SeqOfOCSP_Certificate* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_OCSP__SeqOfOCSP_Certificate;
   rtxDListFastInit (pvalue);
}

void asn1Free_OCSP__SeqOfOCSP_Certificate (OSCTXT *pctxt, 
   ASN1T_OCSP__SeqOfOCSP_Certificate* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_EXP_Certificate* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_EXP_Certificate*)pnode->data;
      asn1Free_EXP_Certificate (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_OCSP__SeqOfOCSP_Certificate::MemFree ()
{
   asn1Free_OCSP__SeqOfOCSP_Certificate (getCtxtPtr(), &msgData);
}

ASN1T_OCSP_Signature* new_ASN1T_OCSP_Signature (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_OCSP_Signature));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_OCSP_Signature;
}

ASN1C_OCSP_Signature::ASN1C_OCSP_Signature (ASN1T_OCSP_Signature& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_OCSP_Signature::ASN1C_OCSP_Signature (OSRTMessageBufferIF& msgBuf
   , ASN1T_OCSP_Signature& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_OCSP_Signature::ASN1C_OCSP_Signature (OSRTContext &context
   , ASN1T_OCSP_Signature& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_OCSP_Signature::ASN1T_OCSP_Signature ()
{
   m.certsPresent = 0;
}

ASN1T_OCSP_Signature::~ASN1T_OCSP_Signature ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_OCSP_Signature (pctxt, this);
   }
}

int ASN1C_OCSP_Signature::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_OCSP_Signature (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_OCSP_Signature::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_OCSP_Signature;
   msgData.setContext (msgBuf.getContext());
   return asn1D_OCSP_Signature (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_OCSP_Signature (ASN1T_OCSP_Signature* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_OCSP_Signature;
}

void asn1Free_OCSP_Signature (OSCTXT *pctxt, ASN1T_OCSP_Signature* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_EXP_AlgorithmIdentifier (pctxt, &pvalue->signatureAlgorithm);
   if (pvalue->signature_.numbits > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->signature_.data);
      pvalue->signature_.numbits = 0;
      pvalue->signature_.data = 0;
   }
   if (pvalue->m.certsPresent) {
      asn1Free_OCSP__SeqOfOCSP_Certificate (pctxt, &pvalue->certs);
   }
}

void ASN1C_OCSP_Signature::MemFree ()
{
   asn1Free_OCSP_Signature (getCtxtPtr(), &msgData);
}

ASN1T_OCSP_OCSPRequest* new_ASN1T_OCSP_OCSPRequest (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_OCSP_OCSPRequest));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_OCSP_OCSPRequest;
}

ASN1C_OCSP_OCSPRequest::ASN1C_OCSP_OCSPRequest (ASN1T_OCSP_OCSPRequest& data)
    : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_OCSP_OCSPRequest::ASN1C_OCSP_OCSPRequest (OSRTMessageBufferIF& msgBuf
   , ASN1T_OCSP_OCSPRequest& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_OCSP_OCSPRequest::ASN1C_OCSP_OCSPRequest (OSRTContext &context
   , ASN1T_OCSP_OCSPRequest& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_OCSP_OCSPRequest::ASN1T_OCSP_OCSPRequest ()
{
   m.optionalSignaturePresent = 0;
}

ASN1T_OCSP_OCSPRequest::~ASN1T_OCSP_OCSPRequest ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_OCSP_OCSPRequest (pctxt, this);
   }
}

int ASN1C_OCSP_OCSPRequest::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_OCSP_OCSPRequest (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_OCSP_OCSPRequest::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_OCSP_OCSPRequest;
   msgData.setContext (msgBuf.getContext());
   return asn1D_OCSP_OCSPRequest (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_OCSP_OCSPRequest (ASN1T_OCSP_OCSPRequest* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_OCSP_OCSPRequest;
}

void asn1Free_OCSP_OCSPRequest (OSCTXT *pctxt, ASN1T_OCSP_OCSPRequest* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_OCSP_TBSRequest (pctxt, &pvalue->tbsRequest);
   if (pvalue->m.optionalSignaturePresent) {
      asn1Free_OCSP_Signature (pctxt, &pvalue->optionalSignature);
   }
}

void ASN1C_OCSP_OCSPRequest::MemFree ()
{
   asn1Free_OCSP_OCSPRequest (getCtxtPtr(), &msgData);
}

ASN1T_OCSP_ResponseBytes* new_ASN1T_OCSP_ResponseBytes (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_OCSP_ResponseBytes));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_OCSP_ResponseBytes;
}

ASN1C_OCSP_ResponseBytes::ASN1C_OCSP_ResponseBytes
    (ASN1T_OCSP_ResponseBytes& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_OCSP_ResponseBytes::ASN1C_OCSP_ResponseBytes (OSRTMessageBufferIF& msgBuf
   , ASN1T_OCSP_ResponseBytes& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_OCSP_ResponseBytes::ASN1C_OCSP_ResponseBytes (OSRTContext &context
   , ASN1T_OCSP_ResponseBytes& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_OCSP_ResponseBytes::ASN1T_OCSP_ResponseBytes ()
{
}

ASN1T_OCSP_ResponseBytes::~ASN1T_OCSP_ResponseBytes ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_OCSP_ResponseBytes (pctxt, this);
   }
}

int ASN1C_OCSP_ResponseBytes::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_OCSP_ResponseBytes (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_OCSP_ResponseBytes::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_OCSP_ResponseBytes;
   msgData.setContext (msgBuf.getContext());
   return asn1D_OCSP_ResponseBytes (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_OCSP_ResponseBytes (ASN1T_OCSP_ResponseBytes* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_OCSP_ResponseBytes;
}

void asn1Free_OCSP_ResponseBytes (OSCTXT *pctxt, 
   ASN1T_OCSP_ResponseBytes* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->response.numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->response.data);
      pvalue->response.numocts = 0;
      pvalue->response.data = 0;
   }
}

void ASN1C_OCSP_ResponseBytes::MemFree ()
{
   asn1Free_OCSP_ResponseBytes (getCtxtPtr(), &msgData);
}

ASN1T_OCSP_OCSPResponse* new_ASN1T_OCSP_OCSPResponse (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_OCSP_OCSPResponse));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_OCSP_OCSPResponse;
}

ASN1C_OCSP_OCSPResponse::ASN1C_OCSP_OCSPResponse
    (ASN1T_OCSP_OCSPResponse& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_OCSP_OCSPResponse::ASN1C_OCSP_OCSPResponse (OSRTMessageBufferIF& msgBuf
   , ASN1T_OCSP_OCSPResponse& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_OCSP_OCSPResponse::ASN1C_OCSP_OCSPResponse (OSRTContext &context
   , ASN1T_OCSP_OCSPResponse& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_OCSP_OCSPResponse::ASN1T_OCSP_OCSPResponse ()
{
   m.responseBytesPresent = 0;
}

ASN1T_OCSP_OCSPResponse::~ASN1T_OCSP_OCSPResponse ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_OCSP_OCSPResponse (pctxt, this);
   }
}

int ASN1C_OCSP_OCSPResponse::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_OCSP_OCSPResponse (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_OCSP_OCSPResponse::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_OCSP_OCSPResponse;
   msgData.setContext (msgBuf.getContext());
   return asn1D_OCSP_OCSPResponse (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_OCSP_OCSPResponse (ASN1T_OCSP_OCSPResponse* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_OCSP_OCSPResponse;
}

void asn1Free_OCSP_OCSPResponse (OSCTXT *pctxt, 
   ASN1T_OCSP_OCSPResponse* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.responseBytesPresent) {
      asn1Free_OCSP_ResponseBytes (pctxt, &pvalue->responseBytes);
   }
}

void ASN1C_OCSP_OCSPResponse::MemFree ()
{
   asn1Free_OCSP_OCSPResponse (getCtxtPtr(), &msgData);
}

ASN1T_OCSP_ResponderID* new_ASN1T_OCSP_ResponderID (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_OCSP_ResponderID));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_OCSP_ResponderID;
}

ASN1C_OCSP_ResponderID::ASN1C_OCSP_ResponderID (ASN1T_OCSP_ResponderID& data)
    : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_OCSP_ResponderID::ASN1C_OCSP_ResponderID (OSRTMessageBufferIF& msgBuf
   , ASN1T_OCSP_ResponderID& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_OCSP_ResponderID::ASN1C_OCSP_ResponderID (OSRTContext &context
   , ASN1T_OCSP_ResponderID& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_OCSP_ResponderID::~ASN1T_OCSP_ResponderID ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_OCSP_ResponderID (pctxt, this);
   }
}

int ASN1C_OCSP_ResponderID::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_OCSP_ResponderID (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_OCSP_ResponderID::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_OCSP_ResponderID;
   msgData.setContext (msgBuf.getContext());
   return asn1D_OCSP_ResponderID (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_OCSP_ResponderID (ASN1T_OCSP_ResponderID* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_OCSP_ResponderID;
}

void asn1Free_OCSP_ResponderID (OSCTXT *pctxt, ASN1T_OCSP_ResponderID* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.byName) {
            asn1Free_EXP_Name (pctxt, pvalue->u.byName);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.byName);
         }
         break;

      case 2:
         if (0 != pvalue->u.byKey) {
            asn1Free_OCSP_KeyHash (pctxt, pvalue->u.byKey);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.byKey);
         }
         break;

   }
}

void ASN1C_OCSP_ResponderID::MemFree ()
{
   asn1Free_OCSP_ResponderID (getCtxtPtr(), &msgData);
}

ASN1T_OCSP_RevokedInfo* new_ASN1T_OCSP_RevokedInfo (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_OCSP_RevokedInfo));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_OCSP_RevokedInfo;
}

ASN1C_OCSP_RevokedInfo::ASN1C_OCSP_RevokedInfo (ASN1T_OCSP_RevokedInfo& data)
    : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_OCSP_RevokedInfo::ASN1C_OCSP_RevokedInfo (OSRTMessageBufferIF& msgBuf
   , ASN1T_OCSP_RevokedInfo& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_OCSP_RevokedInfo::ASN1C_OCSP_RevokedInfo (OSRTContext &context
   , ASN1T_OCSP_RevokedInfo& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_OCSP_RevokedInfo::ASN1T_OCSP_RevokedInfo ()
{
   revocationTime = 0;
   m.revocationReasonPresent = 0;
}

ASN1T_OCSP_RevokedInfo::~ASN1T_OCSP_RevokedInfo ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_OCSP_RevokedInfo (pctxt, this);
   }
}

int ASN1C_OCSP_RevokedInfo::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_OCSP_RevokedInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_OCSP_RevokedInfo::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_OCSP_RevokedInfo;
   msgData.setContext (msgBuf.getContext());
   return asn1D_OCSP_RevokedInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_OCSP_RevokedInfo (ASN1T_OCSP_RevokedInfo* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_OCSP_RevokedInfo;
}

void asn1Free_OCSP_RevokedInfo (OSCTXT *pctxt, ASN1T_OCSP_RevokedInfo* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreePtr (pctxt, (void*)pvalue->revocationTime);
}

void ASN1C_OCSP_RevokedInfo::MemFree ()
{
   asn1Free_OCSP_RevokedInfo (getCtxtPtr(), &msgData);
}

ASN1T_OCSP_CertStatus* new_ASN1T_OCSP_CertStatus (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_OCSP_CertStatus));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_OCSP_CertStatus;
}

ASN1C_OCSP_CertStatus::ASN1C_OCSP_CertStatus (ASN1T_OCSP_CertStatus& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_OCSP_CertStatus::ASN1C_OCSP_CertStatus (OSRTMessageBufferIF& msgBuf
   , ASN1T_OCSP_CertStatus& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_OCSP_CertStatus::ASN1C_OCSP_CertStatus (OSRTContext &context
   , ASN1T_OCSP_CertStatus& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_OCSP_CertStatus::~ASN1T_OCSP_CertStatus ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_OCSP_CertStatus (pctxt, this);
   }
}

int ASN1C_OCSP_CertStatus::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_OCSP_CertStatus (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_OCSP_CertStatus::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_OCSP_CertStatus;
   msgData.setContext (msgBuf.getContext());
   return asn1D_OCSP_CertStatus (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_OCSP_CertStatus (ASN1T_OCSP_CertStatus* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_OCSP_CertStatus;
}

void asn1Free_OCSP_CertStatus (OSCTXT *pctxt, ASN1T_OCSP_CertStatus* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         break;

      case 2:
         if (0 != pvalue->u.revoked) {
            asn1Free_OCSP_RevokedInfo (pctxt, pvalue->u.revoked);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.revoked);
         }
         break;

      case 3:
         break;

   }
}

void ASN1C_OCSP_CertStatus::MemFree ()
{
   asn1Free_OCSP_CertStatus (getCtxtPtr(), &msgData);
}

ASN1T_OCSP_SingleResponse* new_ASN1T_OCSP_SingleResponse (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_OCSP_SingleResponse));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_OCSP_SingleResponse;
}

ASN1C_OCSP_SingleResponse::ASN1C_OCSP_SingleResponse
    (ASN1T_OCSP_SingleResponse& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_OCSP_SingleResponse::ASN1C_OCSP_SingleResponse (
   OSRTMessageBufferIF& msgBuf, ASN1T_OCSP_SingleResponse& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_OCSP_SingleResponse::ASN1C_OCSP_SingleResponse (OSRTContext &context
   , ASN1T_OCSP_SingleResponse& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_OCSP_SingleResponse::ASN1T_OCSP_SingleResponse ()
{
   thisUpdate = 0;
   m.nextUpdatePresent = 0;
   nextUpdate = 0;
   m.singleExtensionsPresent = 0;
}

ASN1T_OCSP_SingleResponse::~ASN1T_OCSP_SingleResponse ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_OCSP_SingleResponse (pctxt, this);
   }
}

int ASN1C_OCSP_SingleResponse::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_OCSP_SingleResponse (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_OCSP_SingleResponse::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_OCSP_SingleResponse;
   msgData.setContext (msgBuf.getContext());
   return asn1D_OCSP_SingleResponse (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_OCSP_SingleResponse (ASN1T_OCSP_SingleResponse* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_OCSP_SingleResponse;
}

void asn1Free_OCSP_SingleResponse (OSCTXT *pctxt, 
   ASN1T_OCSP_SingleResponse* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_OCSP_CertID (pctxt, &pvalue->certID);
   asn1Free_OCSP_CertStatus (pctxt, &pvalue->certStatus);
   rtxMemFreePtr (pctxt, (void*)pvalue->thisUpdate);
   if (pvalue->m.nextUpdatePresent) {
      rtxMemFreePtr (pctxt, (void*)pvalue->nextUpdate);
   }
   if (pvalue->m.singleExtensionsPresent) {
      asn1Free_EXP_Extensions (pctxt, &pvalue->singleExtensions);
   }
}

void ASN1C_OCSP_SingleResponse::MemFree ()
{
   asn1Free_OCSP_SingleResponse (getCtxtPtr(), &msgData);
}

ASN1C_OCSP__SeqOfOCSP_SingleResponse::ASN1C_OCSP__SeqOfOCSP_SingleResponse
    (ASN1T_OCSP__SeqOfOCSP_SingleResponse& data) : ASN1CSeqOfList(data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_OCSP__SeqOfOCSP_SingleResponse::ASN1C_OCSP__SeqOfOCSP_SingleResponse (
   OSRTMessageBufferIF& msgBuf, ASN1T_OCSP__SeqOfOCSP_SingleResponse& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_OCSP__SeqOfOCSP_SingleResponse::ASN1C_OCSP__SeqOfOCSP_SingleResponse (
   OSRTContext &context, ASN1T_OCSP__SeqOfOCSP_SingleResponse& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_OCSP__SeqOfOCSP_SingleResponse::
   ASN1C_OCSP__SeqOfOCSP_SingleResponse (ASN1CType& ccobj
   , ASN1T_OCSP__SeqOfOCSP_SingleResponse& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_OCSP__SeqOfOCSP_SingleResponse::Append (ASN1T_OCSP_SingleResponse* elem)
{
   append ((void*)elem);
}

ASN1T_OCSP_SingleResponse* ASN1C_OCSP__SeqOfOCSP_SingleResponse::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_OCSP_SingleResponse));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_OCSP_SingleResponse;
}

ASN1T_OCSP_SingleResponse* ASN1C_OCSP__SeqOfOCSP_SingleResponse::AppendNewElement ()
{
   ASN1T_OCSP_SingleResponse* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_OCSP__SeqOfOCSP_SingleResponse::~ASN1T_OCSP__SeqOfOCSP_SingleResponse ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_OCSP__SeqOfOCSP_SingleResponse (pctxt, this);
   }
}

int ASN1C_OCSP__SeqOfOCSP_SingleResponse::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_OCSP__SeqOfOCSP_SingleResponse (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_OCSP__SeqOfOCSP_SingleResponse::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_OCSP__SeqOfOCSP_SingleResponse;
   msgData.setContext (msgBuf.getContext());
   return asn1D_OCSP__SeqOfOCSP_SingleResponse (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_OCSP__SeqOfOCSP_SingleResponse (
   ASN1T_OCSP__SeqOfOCSP_SingleResponse* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_OCSP__SeqOfOCSP_SingleResponse;
   rtxDListFastInit (pvalue);
}

void asn1Free_OCSP__SeqOfOCSP_SingleResponse (OSCTXT *pctxt, 
   ASN1T_OCSP__SeqOfOCSP_SingleResponse* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_OCSP_SingleResponse* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_OCSP_SingleResponse*)pnode->data;
      asn1Free_OCSP_SingleResponse (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_OCSP__SeqOfOCSP_SingleResponse::MemFree ()
{
   asn1Free_OCSP__SeqOfOCSP_SingleResponse (getCtxtPtr(), &msgData);
}

ASN1T_OCSP_ResponseData* new_ASN1T_OCSP_ResponseData (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_OCSP_ResponseData));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_OCSP_ResponseData;
}

ASN1C_OCSP_ResponseData::ASN1C_OCSP_ResponseData
    (ASN1T_OCSP_ResponseData& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_OCSP_ResponseData::ASN1C_OCSP_ResponseData (OSRTMessageBufferIF& msgBuf
   , ASN1T_OCSP_ResponseData& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_OCSP_ResponseData::ASN1C_OCSP_ResponseData (OSRTContext &context
   , ASN1T_OCSP_ResponseData& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_OCSP_ResponseData::ASN1T_OCSP_ResponseData ()
{
   version = OCSP_Version::v1;
   producedAt = 0;
   m.responseExtensionsPresent = 0;
}

ASN1T_OCSP_ResponseData::~ASN1T_OCSP_ResponseData ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_OCSP_ResponseData (pctxt, this);
   }
}

int ASN1C_OCSP_ResponseData::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_OCSP_ResponseData (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_OCSP_ResponseData::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_OCSP_ResponseData;
   msgData.setContext (msgBuf.getContext());
   return asn1D_OCSP_ResponseData (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_OCSP_ResponseData (ASN1T_OCSP_ResponseData* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_OCSP_ResponseData;
}

void asn1Free_OCSP_ResponseData (OSCTXT *pctxt, 
   ASN1T_OCSP_ResponseData* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_OCSP_ResponderID (pctxt, &pvalue->responderID);
   rtxMemFreePtr (pctxt, (void*)pvalue->producedAt);
   asn1Free_OCSP__SeqOfOCSP_SingleResponse (pctxt, &pvalue->responses);
   if (pvalue->m.responseExtensionsPresent) {
      asn1Free_EXP_Extensions (pctxt, &pvalue->responseExtensions);
   }
}

void ASN1C_OCSP_ResponseData::MemFree ()
{
   asn1Free_OCSP_ResponseData (getCtxtPtr(), &msgData);
}

ASN1T_OCSP_BasicOCSPResponse* 
   new_ASN1T_OCSP_BasicOCSPResponse (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_OCSP_BasicOCSPResponse));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_OCSP_BasicOCSPResponse;
}

ASN1C_OCSP_BasicOCSPResponse::ASN1C_OCSP_BasicOCSPResponse
    (ASN1T_OCSP_BasicOCSPResponse& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_OCSP_BasicOCSPResponse::ASN1C_OCSP_BasicOCSPResponse (
   OSRTMessageBufferIF& msgBuf, ASN1T_OCSP_BasicOCSPResponse& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_OCSP_BasicOCSPResponse::ASN1C_OCSP_BasicOCSPResponse (
   OSRTContext &context, ASN1T_OCSP_BasicOCSPResponse& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_OCSP_BasicOCSPResponse::ASN1T_OCSP_BasicOCSPResponse ()
{
   m.certsPresent = 0;
}

ASN1T_OCSP_BasicOCSPResponse::~ASN1T_OCSP_BasicOCSPResponse ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_OCSP_BasicOCSPResponse (pctxt, this);
   }
}

int ASN1C_OCSP_BasicOCSPResponse::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_OCSP_BasicOCSPResponse (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_OCSP_BasicOCSPResponse::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_OCSP_BasicOCSPResponse;
   msgData.setContext (msgBuf.getContext());
   return asn1D_OCSP_BasicOCSPResponse (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_OCSP_BasicOCSPResponse (ASN1T_OCSP_BasicOCSPResponse* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_OCSP_BasicOCSPResponse;
}

void asn1Free_OCSP_BasicOCSPResponse (OSCTXT *pctxt, 
   ASN1T_OCSP_BasicOCSPResponse* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_OCSP_ResponseData (pctxt, &pvalue->tbsResponseData);
   asn1Free_EXP_AlgorithmIdentifier (pctxt, &pvalue->signatureAlgorithm);
   if (pvalue->signature_.numbits > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->signature_.data);
      pvalue->signature_.numbits = 0;
      pvalue->signature_.data = 0;
   }
   if (pvalue->m.certsPresent) {
      asn1Free_OCSP__SeqOfOCSP_Certificate (pctxt, &pvalue->certs);
   }
}

void ASN1C_OCSP_BasicOCSPResponse::MemFree ()
{
   asn1Free_OCSP_BasicOCSPResponse (getCtxtPtr(), &msgData);
}

