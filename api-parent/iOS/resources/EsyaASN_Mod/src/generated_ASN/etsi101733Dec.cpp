/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.6, Date: 28-Feb-2014.
 */
#include "etsi101733.h"
#include "rtxsrc/rtxCommon.h"

EXTERN int asn1D_ETSI101733_OtherHashValue (OSCTXT* pctxt, 
   ASN1T_ETSI101733_OtherHashValue* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "OtherHashValue");

   stat = xd_octstr (pctxt, &pvalue->data, &pvalue->numocts, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_SignaturePolicyImplied_ (OSCTXT* pctxt, 
   void* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   OS_UNUSED_ARG(pvalue) ;
   OS_UNUSED_ARG(length) ;

   RTXCTXTPUSHTYPENAME (pctxt, "SignaturePolicyImplied");

   stat = xd_null (pctxt, tagging);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_SigPolicyId (OSCTXT* pctxt, 
   ASN1T_ETSI101733_SigPolicyId* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SigPolicyId");

   stat = xd_objid (pctxt, (ASN1OBJID*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_OtherHashAlgAndValue (OSCTXT* pctxt, 
   ASN1T_ETSI101733_OtherHashAlgAndValue* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "OtherHashAlgAndValue");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode hashAlgorithm */
         RTXCTXTPUSHELEMNAME (pctxt, "hashAlgorithm");

         stat = asn1D_EXP_AlgorithmIdentifier (pctxt, &pvalue->hashAlgorithm, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode hashValue */
         RTXCTXTPUSHELEMNAME (pctxt, "hashValue");

         stat = asn1D_ETSI101733_OtherHashValue (pctxt, &pvalue->hashValue, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_CONS|16):
         case (TM_UNIV|TM_PRIM|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_SigPolicyHash (OSCTXT* pctxt, 
   ASN1T_ETSI101733_SigPolicyHash* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SigPolicyHash");

   stat = asn1D_ETSI101733_OtherHashAlgAndValue (pctxt, pvalue, 
      tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_SPuri (OSCTXT* pctxt, 
   ASN1T_ETSI101733_SPuri* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SPuri");

   stat = xd_charstr (pctxt, pvalue, tagging, (TM_UNIV|TM_PRIM|22), length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_ContentTimestamp (OSCTXT* pctxt, 
   ASN1T_ETSI101733_ContentTimestamp* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ContentTimestamp");

   stat = asn1D_TSP_TimeStampToken (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_SignatureTimeStampToken (OSCTXT* pctxt, 
   ASN1T_ETSI101733_SignatureTimeStampToken* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SignatureTimeStampToken");

   stat = asn1D_TSP_TimeStampToken (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_ESCTimeStampToken (OSCTXT* pctxt, 
   ASN1T_ETSI101733_ESCTimeStampToken* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ESCTimeStampToken");

   stat = asn1D_TSP_TimeStampToken (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_TimestampedCertsCRLs (OSCTXT* pctxt, 
   ASN1T_ETSI101733_TimestampedCertsCRLs* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TimestampedCertsCRLs");

   stat = asn1D_TSP_TimeStampToken (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_ArchiveTimeStampToken (OSCTXT* pctxt, 
   ASN1T_ETSI101733_ArchiveTimeStampToken* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ArchiveTimeStampToken");

   stat = asn1D_TSP_TimeStampToken (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_ContentIdentifier (OSCTXT* pctxt, 
   ASN1T_ETSI101733_ContentIdentifier* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ContentIdentifier");

   stat = xd_octstr (pctxt, &pvalue->data, &pvalue->numocts, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_CommitmentTypeIdentifier (OSCTXT* pctxt, 
   ASN1T_ETSI101733_CommitmentTypeIdentifier* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CommitmentTypeIdentifier");

   stat = xd_objid (pctxt, (ASN1OBJID*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_CertifiedAttributes (OSCTXT* pctxt, 
   ASN1T_ETSI101733_CertifiedAttributes* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CertifiedAttributes");

   stat = asn1D_ATTRCERT_AttributeCertificate (pctxt, pvalue, 
      tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_OtherHash (OSCTXT* pctxt, 
   ASN1T_ETSI101733_OtherHash* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "OtherHash");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_UNIV|TM_PRIM|4):
         RTXCTXTPUSHELEMNAME (pctxt, "sha1Hash");

         pvalue->u.sha1Hash = rtxMemAllocType (pctxt, 
            ASN1T_ETSI101733_OtherHashValue);

         if (pvalue->u.sha1Hash == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ETSI101733_OtherHashValue (pvalue->u.sha1Hash);
         stat = asn1D_ETSI101733_OtherHashValue (pctxt, pvalue->u.sha1Hash, 
            ASN1IMPL, length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_CONS|16):
         RTXCTXTPUSHELEMNAME (pctxt, "otherHash");

         pvalue->u.otherHash = rtxMemAllocType (pctxt, 
            ASN1T_ETSI101733_OtherHashAlgAndValue);

         if (pvalue->u.otherHash == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ETSI101733_OtherHashAlgAndValue (pvalue->u.otherHash);
         stat = asn1D_ETSI101733_OtherHashAlgAndValue (pctxt, pvalue->
            u.otherHash, ASN1IMPL, length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_OtherCertID (OSCTXT* pctxt, 
   ASN1T_ETSI101733_OtherCertID* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "OtherCertID");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode otherCertHash */
         RTXCTXTPUSHELEMNAME (pctxt, "otherCertHash");

         stat = asn1D_ETSI101733_OtherHash (pctxt, &pvalue->otherCertHash, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode issuerSerial */
         if (XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "issuerSerial");

            stat = asn1D_ATTRCERT_IssuerSerial (pctxt, &pvalue->issuerSerial, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.issuerSerialPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|4):
         case (TM_UNIV|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733__SeqOfETSI101733_OtherCertID (OSCTXT* pctxt, 
   ASN1T_ETSI101733__SeqOfETSI101733_OtherCertID* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1T_ETSI101733_OtherCertID* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "OtherCertID", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_ETSI101733_OtherCertID, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ETSI101733_OtherCertID (pdata1);

      stat = asn1D_ETSI101733_OtherCertID (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1D_ETSI101733__SeqOfETSI101733_PolicyInformation (OSCTXT* pctxt, 
   ASN1T_ETSI101733__SeqOfETSI101733_PolicyInformation* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_IMP_PolicyInformation* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PolicyInformation", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_IMP_PolicyInformation, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_IMP_PolicyInformation (pdata1);

      stat = asn1D_IMP_PolicyInformation (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1D_ETSI101733_OtherSigningCertificate (OSCTXT* pctxt, 
   ASN1T_ETSI101733_OtherSigningCertificate* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "OtherSigningCertificate");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode certs */
         RTXCTXTPUSHELEMNAME (pctxt, "certs");

         stat = asn1D_ETSI101733__SeqOfETSI101733_OtherCertID (pctxt, &pvalue->
            certs, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode policies */
         if (XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "policies");

            stat = asn1D_ETSI101733__SeqOfETSI101733_PolicyInformation (pctxt, 
               &pvalue->policies, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.policiesPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_SigPolicyQualifierInfo (OSCTXT* pctxt, 
   ASN1T_ETSI101733_SigPolicyQualifierInfo* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "SigPolicyQualifierInfo");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode sigPolicyQualifierId */
         RTXCTXTPUSHELEMNAME (pctxt, "sigPolicyQualifierId");

         stat = xd_objid (pctxt, (ASN1OBJID*)&pvalue->sigPolicyQualifierId, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode qualifier */
         RTXCTXTPUSHELEMNAME (pctxt, "qualifier");

         stat = xd_OpenType (pctxt, &pvalue->qualifier.data, &pvalue->qualifier.numocts);
         if (stat == 0) {
            pvalue->m.qualifierPresent = TRUE;
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_SignaturePolicyId_sigPolicyQualifiers (
   OSCTXT* pctxt, 
   ASN1T_ETSI101733_SignaturePolicyId_sigPolicyQualifiers* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_ETSI101733_SigPolicyQualifierInfo* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SigPolicyQualifierInfo", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_ETSI101733_SigPolicyQualifierInfo, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ETSI101733_SigPolicyQualifierInfo (pdata1);

      stat = asn1D_ETSI101733_SigPolicyQualifierInfo (pctxt, pdata1, 
         ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

EXTERN int asn1D_ETSI101733_SignaturePolicyId (OSCTXT* pctxt, 
   ASN1T_ETSI101733_SignaturePolicyId* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "SignaturePolicyId");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode sigPolicyId */
         RTXCTXTPUSHELEMNAME (pctxt, "sigPolicyId");

         stat = asn1D_ETSI101733_SigPolicyId (pctxt, &pvalue->sigPolicyId, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode sigPolicyHash */
         RTXCTXTPUSHELEMNAME (pctxt, "sigPolicyHash");

         stat = asn1D_ETSI101733_SigPolicyHash (pctxt, &pvalue->sigPolicyHash, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode sigPolicyQualifiers */
         if (XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "sigPolicyQualifiers");

            stat = asn1D_ETSI101733_SignaturePolicyId_sigPolicyQualifiers (pctxt, 
               &pvalue->sigPolicyQualifiers, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.sigPolicyQualifiersPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|6):
         case (TM_UNIV|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_SignaturePolicy (OSCTXT* pctxt, 
   ASN1T_ETSI101733_SignaturePolicy* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "SignaturePolicy");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_UNIV|TM_PRIM|5):
         RTXCTXTPUSHELEMNAME (pctxt, "signaturePolicyImplied");

         stat = asn1D_ETSI101733_SignaturePolicyImplied (pctxt, 
            ASN1IMPL, length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_CONS|16):
         RTXCTXTPUSHELEMNAME (pctxt, "signaturePolicyId");

         pvalue->u.signaturePolicyId = rtxMemAllocType (pctxt, 
            ASN1T_ETSI101733_SignaturePolicyId);

         if (pvalue->u.signaturePolicyId == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ETSI101733_SignaturePolicyId (pvalue->u.signaturePolicyId);
         stat = asn1D_ETSI101733_SignaturePolicyId (pctxt, pvalue->
            u.signaturePolicyId, ASN1IMPL, length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_DisplayText (OSCTXT* pctxt, 
   ASN1T_ETSI101733_DisplayText* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "DisplayText");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_UNIV|TM_PRIM|12):
         RTXCTXTPUSHELEMNAME (pctxt, "utf8String");

         stat = xd_utf8str (pctxt, &pvalue->u.utf8String, ASN1IMPL, length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { int nchars = rtxUTF8Len (pvalue->u.utf8String);
         if (!((nchars >= 1 && nchars <= 200))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|26):
         RTXCTXTPUSHELEMNAME (pctxt, "visibleString");

         stat = xd_charstr (pctxt, &pvalue->u.visibleString, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|26), length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.visibleString);
         if (!((nchars >= 1 && nchars <= 200))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|30):
         RTXCTXTPUSHELEMNAME (pctxt, "bmpString");

         pvalue->u.bmpString = rtxMemAllocType (pctxt, ASN1TBMPString);

         if (pvalue->u.bmpString == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.bmpString->nchars = 0;
         stat = xd_16BitCharStr (pctxt,
            pvalue->u.bmpString,
            ASN1IMPL, (TM_UNIV|TM_PRIM|30), length);
         pvalue->t = 3;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         if (!((pvalue->u.bmpString->nchars >= 1 && pvalue->u.bmpString->nchars <= 200
            ))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)pvalue->u.bmpString->nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_NoticeReference_noticeNumbers (OSCTXT* pctxt, 
   ASN1T_ETSI101733_NoticeReference_noticeNumbers* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   OSINT32* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "INTEGER", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, OSINT32, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_integer (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1D_ETSI101733_NoticeReference (OSCTXT* pctxt, 
   ASN1T_ETSI101733_NoticeReference* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "NoticeReference");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode organization */
         RTXCTXTPUSHELEMNAME (pctxt, "organization");

         stat = asn1D_ETSI101733_DisplayText (pctxt, &pvalue->organization, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode noticeNumbers */
         RTXCTXTPUSHELEMNAME (pctxt, "noticeNumbers");

         stat = asn1D_ETSI101733_NoticeReference_noticeNumbers (pctxt, &pvalue
            ->noticeNumbers, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|12):
         case (TM_UNIV|TM_PRIM|26):
         case (TM_UNIV|TM_PRIM|30):
         case (TM_UNIV|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_SPUserNotice (OSCTXT* pctxt, 
   ASN1T_ETSI101733_SPUserNotice* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "SPUserNotice");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode noticeRef */
         if (XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "noticeRef");

            stat = asn1D_ETSI101733_NoticeReference (pctxt, &pvalue->noticeRef
               , ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.noticeRefPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 1:
         /* decode explicitText */
         if (XD_PEEKTAG (pctxt, 0xc)
         || XD_PEEKTAG (pctxt, 0x1a)
         || XD_PEEKTAG (pctxt, 0x1e)) {
            RTXCTXTPUSHELEMNAME (pctxt, "explicitText");

            stat = asn1D_ETSI101733_DisplayText (pctxt, &pvalue->explicitText, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.explicitTextPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_CONS|16):
         case (TM_UNIV|TM_PRIM|12):
         case (TM_UNIV|TM_PRIM|26):
         case (TM_UNIV|TM_PRIM|30):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_CompleteCertificateRefs (OSCTXT* pctxt, 
   ASN1T_ETSI101733_CompleteCertificateRefs* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1T_ETSI101733_OtherCertID* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "CompleteCertificateRefs");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "OtherCertID", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_ETSI101733_OtherCertID, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ETSI101733_OtherCertID (pdata1);

      stat = asn1D_ETSI101733_OtherCertID (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_CrlIdentifier (OSCTXT* pctxt, 
   ASN1T_ETSI101733_CrlIdentifier* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "CrlIdentifier");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode crlissuer */
         RTXCTXTPUSHELEMNAME (pctxt, "crlissuer");

         stat = asn1D_EXP_Name (pctxt, &pvalue->crlissuer, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode crlIssuedTime */
         RTXCTXTPUSHELEMNAME (pctxt, "crlIssuedTime");

         stat = xd_charstr (pctxt, &pvalue->crlIssuedTime, ASN1EXPL, 
            (TM_UNIV|TM_PRIM|23), length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode crlNumber */
         if (XD_PEEKTAG (pctxt, 0x2)) {
            RTXCTXTPUSHELEMNAME (pctxt, "crlNumber");

            stat = asn1D_IMP_CRLNumber (pctxt, &pvalue->crlNumber, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.crlNumberPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_CONS|16):
         case (TM_UNIV|TM_PRIM|23):
         case (TM_UNIV|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_CrlValidatedID (OSCTXT* pctxt, 
   ASN1T_ETSI101733_CrlValidatedID* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "CrlValidatedID");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode crlHash */
         RTXCTXTPUSHELEMNAME (pctxt, "crlHash");

         stat = asn1D_ETSI101733_OtherHash (pctxt, &pvalue->crlHash, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode crlIdentifier */
         if (XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "crlIdentifier");

            stat = asn1D_ETSI101733_CrlIdentifier (pctxt, &pvalue->
               crlIdentifier, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.crlIdentifierPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|4):
         case (TM_UNIV|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733__SeqOfETSI101733_CrlValidatedID (OSCTXT* pctxt, 
   ASN1T_ETSI101733__SeqOfETSI101733_CrlValidatedID* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_ETSI101733_CrlValidatedID* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CrlValidatedID", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_ETSI101733_CrlValidatedID, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ETSI101733_CrlValidatedID (pdata1);

      stat = asn1D_ETSI101733_CrlValidatedID (pctxt, pdata1, 
         ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1D_ETSI101733_CRLListID (OSCTXT* pctxt, 
   ASN1T_ETSI101733_CRLListID* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "CRLListID");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode crls */
         RTXCTXTPUSHELEMNAME (pctxt, "crls");

         stat = asn1D_ETSI101733__SeqOfETSI101733_CrlValidatedID (pctxt, &
            pvalue->crls, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_OcspIdentifier (OSCTXT* pctxt, 
   ASN1T_ETSI101733_OcspIdentifier* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "OcspIdentifier");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode ocspResponderID */
         RTXCTXTPUSHELEMNAME (pctxt, "ocspResponderID");

         stat = asn1D_OCSP_ResponderID (pctxt, &pvalue->ocspResponderID, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode producedAt */
         RTXCTXTPUSHELEMNAME (pctxt, "producedAt");

         stat = xd_charstr (pctxt, &pvalue->producedAt, ASN1EXPL, 
            (TM_UNIV|TM_PRIM|24), length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_UNIV|TM_PRIM|24):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_OcspResponsesID (OSCTXT* pctxt, 
   ASN1T_ETSI101733_OcspResponsesID* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "OcspResponsesID");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode ocspIdentifier */
         RTXCTXTPUSHELEMNAME (pctxt, "ocspIdentifier");

         stat = asn1D_ETSI101733_OcspIdentifier (pctxt, &pvalue->ocspIdentifier
            , ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode ocspRepHash */
         if (XD_PEEKTAG (pctxt, 0x4)
         || XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "ocspRepHash");

            stat = asn1D_ETSI101733_OtherHash (pctxt, &pvalue->ocspRepHash, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.ocspRepHashPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_CONS|16):
         case (TM_UNIV|TM_PRIM|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733__SeqOfETSI101733_OcspResponsesID (OSCTXT* pctxt, 
   ASN1T_ETSI101733__SeqOfETSI101733_OcspResponsesID* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_ETSI101733_OcspResponsesID* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "OcspResponsesID", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_ETSI101733_OcspResponsesID, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ETSI101733_OcspResponsesID (pdata1);

      stat = asn1D_ETSI101733_OcspResponsesID (pctxt, pdata1, 
         ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1D_ETSI101733_OcspListID (OSCTXT* pctxt, 
   ASN1T_ETSI101733_OcspListID* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "OcspListID");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode ocspResponses */
         RTXCTXTPUSHELEMNAME (pctxt, "ocspResponses");

         stat = asn1D_ETSI101733__SeqOfETSI101733_OcspResponsesID (pctxt, &
            pvalue->ocspResponses, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_OtherRevRefs_otherRevRefs (OSCTXT* pctxt, 
   ASN1T_ETSI101733_OtherRevRefs_otherRevRefs* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TOpenType* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "OPEN_TYPE", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1TOpenType, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pdata1->numocts = 0;
      pdata1->data = 0;

      stat = xd_OpenType (pctxt, &pdata1->data, &pdata1->numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1D_ETSI101733_OtherRevRefs (OSCTXT* pctxt, 
   ASN1T_ETSI101733_OtherRevRefs* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "OtherRevRefs");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode otherRevRefType */
         RTXCTXTPUSHELEMNAME (pctxt, "otherRevRefType");

         stat = xd_objid (pctxt, (ASN1OBJID*)&pvalue->otherRevRefType, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode otherRevRefs */
         RTXCTXTPUSHELEMNAME (pctxt, "otherRevRefs");

         stat = asn1D_ETSI101733_OtherRevRefs_otherRevRefs (pctxt, &pvalue->
            otherRevRefs, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|6):
         case (TM_UNIV|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_CrlOcspRef (OSCTXT* pctxt, 
   ASN1T_ETSI101733_CrlOcspRef* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "CrlOcspRef");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode crlids */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "crlids");

            stat = asn1D_ETSI101733_CRLListID (pctxt, &pvalue->crlids, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.crlidsPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 1:
         /* decode ocspids */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "ocspids");

            stat = asn1D_ETSI101733_OcspListID (pctxt, &pvalue->ocspids, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.ocspidsPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 2:
         /* decode otherRev */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "otherRev");

            stat = asn1D_ETSI101733_OtherRevRefs (pctxt, &pvalue->otherRev, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.otherRevPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_CompleteRevocationRefs (OSCTXT* pctxt, 
   ASN1T_ETSI101733_CompleteRevocationRefs* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1T_ETSI101733_CrlOcspRef* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "CompleteRevocationRefs");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CrlOcspRef", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_ETSI101733_CrlOcspRef, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ETSI101733_CrlOcspRef (pdata1);

      stat = asn1D_ETSI101733_CrlOcspRef (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_CertificateValues (OSCTXT* pctxt, 
   ASN1T_ETSI101733_CertificateValues* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_EXP_Certificate* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "CertificateValues");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "Certificate", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_EXP_Certificate, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EXP_Certificate (pdata1);

      stat = asn1D_EXP_Certificate (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733__SeqOfETSI101733_CertificateList (OSCTXT* pctxt, 
   ASN1T_ETSI101733__SeqOfETSI101733_CertificateList* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_EXP_CertificateList* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CertificateList", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_EXP_CertificateList, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EXP_CertificateList (pdata1);

      stat = asn1D_EXP_CertificateList (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1D_ETSI101733__SeqOfETSI101733_BasicOCSPResponse (OSCTXT* pctxt, 
   ASN1T_ETSI101733__SeqOfETSI101733_BasicOCSPResponse* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_OCSP_BasicOCSPResponse* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "BasicOCSPResponse", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_OCSP_BasicOCSPResponse, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_OCSP_BasicOCSPResponse (pdata1);

      stat = asn1D_OCSP_BasicOCSPResponse (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1D_ETSI101733_OtherRevVals_otherRevVals (OSCTXT* pctxt, 
   ASN1T_ETSI101733_OtherRevVals_otherRevVals* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TOpenType* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "OPEN_TYPE", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1TOpenType, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pdata1->numocts = 0;
      pdata1->data = 0;

      stat = xd_OpenType (pctxt, &pdata1->data, &pdata1->numocts);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1D_ETSI101733_OtherRevVals (OSCTXT* pctxt, 
   ASN1T_ETSI101733_OtherRevVals* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "OtherRevVals");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode otherRevValType */
         RTXCTXTPUSHELEMNAME (pctxt, "otherRevValType");

         stat = xd_objid (pctxt, (ASN1OBJID*)&pvalue->otherRevValType, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode otherRevVals */
         RTXCTXTPUSHELEMNAME (pctxt, "otherRevVals");

         stat = asn1D_ETSI101733_OtherRevVals_otherRevVals (pctxt, &pvalue->
            otherRevVals, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|6):
         case (TM_UNIV|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_RevocationValues (OSCTXT* pctxt, 
   ASN1T_ETSI101733_RevocationValues* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "RevocationValues");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode crlVals */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "crlVals");

            stat = asn1D_ETSI101733__SeqOfETSI101733_CertificateList (pctxt, &
               pvalue->crlVals, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.crlValsPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 1:
         /* decode ocspVals */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "ocspVals");

            stat = asn1D_ETSI101733__SeqOfETSI101733_BasicOCSPResponse (pctxt, 
               &pvalue->ocspVals, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.ocspValsPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 2:
         /* decode otherRevVals */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "otherRevVals");

            stat = asn1D_ETSI101733_OtherRevVals (pctxt, &pvalue->otherRevVals
               , ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.otherRevValsPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_AttributeCertificateRefs (OSCTXT* pctxt, 
   ASN1T_ETSI101733_AttributeCertificateRefs* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1T_ETSI101733_OtherCertID* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "AttributeCertificateRefs");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "OtherCertID", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_ETSI101733_OtherCertID, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ETSI101733_OtherCertID (pdata1);

      stat = asn1D_ETSI101733_OtherCertID (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_AttributeRevocationRefs (OSCTXT* pctxt, 
   ASN1T_ETSI101733_AttributeRevocationRefs* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1T_ETSI101733_CrlOcspRef* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "AttributeRevocationRefs");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CrlOcspRef", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_ETSI101733_CrlOcspRef, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ETSI101733_CrlOcspRef (pdata1);

      stat = asn1D_ETSI101733_CrlOcspRef (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_ContentReference (OSCTXT* pctxt, 
   ASN1T_ETSI101733_ContentReference* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "ContentReference");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode contentType */
         RTXCTXTPUSHELEMNAME (pctxt, "contentType");

         stat = asn1D_CMS_ContentType (pctxt, &pvalue->contentType, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode signedContentIdentifier */
         RTXCTXTPUSHELEMNAME (pctxt, "signedContentIdentifier");

         stat = asn1D_ETSI101733_ContentIdentifier (pctxt, &pvalue->
            signedContentIdentifier, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode originatorSignatureValue */
         RTXCTXTPUSHELEMNAME (pctxt, "originatorSignatureValue");

         stat = xd_octstr (pctxt, &pvalue->originatorSignatureValue.data, &pvalue->originatorSignatureValue.numocts, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|6):
         case (TM_UNIV|TM_PRIM|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_ContentHints (OSCTXT* pctxt, 
   ASN1T_ETSI101733_ContentHints* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "ContentHints");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode contentDescription */
         if (XD_PEEKTAG (pctxt, 0xc)) {
            RTXCTXTPUSHELEMNAME (pctxt, "contentDescription");

            stat = xd_utf8str (pctxt, &pvalue->contentDescription, ASN1EXPL, length);
            if (stat == 0) {
               { int nchars = rtxUTF8Len (pvalue->contentDescription);
               if (!(nchars >= 1)) {
                  rtxErrAddElemNameParm (pctxt);
                  rtxErrAddIntParm (pctxt, (int)nchars);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

               }
               pvalue->m.contentDescriptionPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 1:
         /* decode contentType */
         RTXCTXTPUSHELEMNAME (pctxt, "contentType");

         stat = asn1D_CMS_ContentType (pctxt, &pvalue->contentType, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|12):
         case (TM_UNIV|TM_PRIM|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_CommitmentTypeQualifier (OSCTXT* pctxt, 
   ASN1T_ETSI101733_CommitmentTypeQualifier* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "CommitmentTypeQualifier");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode commitmentTypeIdentifier */
         RTXCTXTPUSHELEMNAME (pctxt, "commitmentTypeIdentifier");

         stat = asn1D_ETSI101733_CommitmentTypeIdentifier (pctxt, &pvalue->
            commitmentTypeIdentifier, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode qualifier */
         RTXCTXTPUSHELEMNAME (pctxt, "qualifier");

         stat = xd_OpenType (pctxt, &pvalue->qualifier.data, &pvalue->qualifier.numocts);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_CommitmentTypeIndication_commitmentTypeQualifier (
   OSCTXT* pctxt, 
   ASN1T_ETSI101733_CommitmentTypeIndication_commitmentTypeQualifier* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_ETSI101733_CommitmentTypeQualifier* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CommitmentTypeQualifier", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_ETSI101733_CommitmentTypeQualifier, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ETSI101733_CommitmentTypeQualifier (pdata1);

      stat = asn1D_ETSI101733_CommitmentTypeQualifier (pctxt, pdata1, 
         ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

EXTERN int asn1D_ETSI101733_CommitmentTypeIndication (OSCTXT* pctxt, 
   ASN1T_ETSI101733_CommitmentTypeIndication* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "CommitmentTypeIndication");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode commitmentTypeId */
         RTXCTXTPUSHELEMNAME (pctxt, "commitmentTypeId");

         stat = asn1D_ETSI101733_CommitmentTypeIdentifier (pctxt, &pvalue->
            commitmentTypeId, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode commitmentTypeQualifier */
         if (XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "commitmentTypeQualifier");

            stat = asn1D_ETSI101733_CommitmentTypeIndication_commitmentTypeQualifier (pctxt, 
               &pvalue->commitmentTypeQualifier, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.commitmentTypeQualifierPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|6):
         case (TM_UNIV|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_PostalAddress (OSCTXT* pctxt, 
   ASN1T_ETSI101733_PostalAddress* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_EXP_DirectoryString* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "PostalAddress");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      if (pvalue->count >= 6) return LOG_RTERR (pctxt, RTERR_SEQOVFLW);

      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DirectoryString", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_EXP_DirectoryString, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EXP_DirectoryString (pdata1);

      stat = asn1D_EXP_DirectoryString (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!((pvalue->count >= OSUINTCONST(1) && pvalue->count <= OSUINTCONST(6)))) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_SignerLocation (OSCTXT* pctxt, 
   ASN1T_ETSI101733_SignerLocation* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "SignerLocation");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode countryName */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "countryName");

            stat = asn1D_EXP_DirectoryString (pctxt, &pvalue->countryName, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.countryNamePresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 1:
         /* decode localityName */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "localityName");

            stat = asn1D_EXP_DirectoryString (pctxt, &pvalue->localityName, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.localityNamePresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 2:
         /* decode postalAdddress */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "postalAdddress");

            stat = asn1D_ETSI101733_PostalAddress (pctxt, &pvalue->
               postalAdddress, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.postalAdddressPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_ClaimedAttributes (OSCTXT* pctxt, 
   ASN1T_ETSI101733_ClaimedAttributes* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_EXP_Attribute* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "ClaimedAttributes");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "Attribute", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_EXP_Attribute, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EXP_Attribute (pdata1);

      stat = asn1D_EXP_Attribute (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ETSI101733_SignerAttribute_element (OSCTXT* pctxt, 
   ASN1T_ETSI101733_SignerAttribute_element* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         RTXCTXTPUSHELEMNAME (pctxt, "claimedAttributes");

         pvalue->u.claimedAttributes = rtxMemAllocType (pctxt, 
            ASN1T_ETSI101733_ClaimedAttributes);

         if (pvalue->u.claimedAttributes == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ETSI101733_ClaimedAttributes (pvalue->u.claimedAttributes);
         stat = asn1D_ETSI101733_ClaimedAttributes (pctxt, pvalue->
            u.claimedAttributes, ASN1EXPL, length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|1):
         RTXCTXTPUSHELEMNAME (pctxt, "certifiedAttributes");

         pvalue->u.certifiedAttributes = rtxMemAllocType (pctxt, 
            ASN1T_ETSI101733_CertifiedAttributes);

         if (pvalue->u.certifiedAttributes == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ETSI101733_CertifiedAttributes (pvalue->u.certifiedAttributes);
         stat = asn1D_ETSI101733_CertifiedAttributes (pctxt, pvalue->
            u.certifiedAttributes, ASN1EXPL, length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1D_ETSI101733_SignerAttribute (OSCTXT* pctxt, 
   ASN1T_ETSI101733_SignerAttribute* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_ETSI101733_SignerAttribute_element* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "SignerAttribute");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CHOICE", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_ETSI101733_SignerAttribute_element, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ETSI101733_SignerAttribute_element (pdata1);

      stat = asn1D_ETSI101733_SignerAttribute_element (pctxt, pdata1, 
         ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

