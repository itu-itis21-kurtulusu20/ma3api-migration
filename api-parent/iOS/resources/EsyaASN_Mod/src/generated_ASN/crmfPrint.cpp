/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.6, Date: 28-Feb-2014.
 */
#include "crmf.h"
#include "rtsrc/rtPrint.h"
#include "rtxsrc/rtxCommon.h"

void asn1Print_CRMF_SubsequentMessage 
   (const char* name, const ASN1T_CRMF_SubsequentMessage* pvalue)
{
   rtxPrintIndent ();
   switch (*pvalue) {
      case 0: printf ("%s = encrCert\n", name); break;
      case 1: printf ("%s = challengeResp\n", name); break;
      default: rtxPrintInteger (name, *pvalue);
   }
}

void ASN1C_CRMF_SubsequentMessage::Print (const char* name)
{
   asn1Print_CRMF_SubsequentMessage (name, &msgData);
}

void asn1Print_CRMF_PKIPublicationInfo_action 
   (const char* name, const ASN1T_CRMF_PKIPublicationInfo_action* pvalue)
{
   rtxPrintIndent ();
   switch (*pvalue) {
      case 0: printf ("%s = dontPublish\n", name); break;
      case 1: printf ("%s = pleasePublish\n", name); break;
      default: rtxPrintInteger (name, *pvalue);
   }
}

void ASN1C_CRMF_PKIPublicationInfo_action::Print (const char* name)
{
   asn1Print_CRMF_PKIPublicationInfo_action (name, &msgData);
}

void asn1Print_CRMF_SinglePubInfo_pubMethod 
   (const char* name, const ASN1T_CRMF_SinglePubInfo_pubMethod* pvalue)
{
   rtxPrintIndent ();
   switch (*pvalue) {
      case 0: printf ("%s = dontCare\n", name); break;
      case 1: printf ("%s = x500\n", name); break;
      case 2: printf ("%s = web\n", name); break;
      case 3: printf ("%s = ldap\n", name); break;
      default: rtxPrintInteger (name, *pvalue);
   }
}

void ASN1C_CRMF_SinglePubInfo_pubMethod::Print (const char* name)
{
   asn1Print_CRMF_SinglePubInfo_pubMethod (name, &msgData);
}

void asn1Print_CRMF_OptionalValidity 
   (const char* name, const ASN1T_CRMF_OptionalValidity* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.notBeforePresent) {
      asn1Print_EXP_Time ("notBefore", &pvalue->notBefore);
   }

   if (pvalue->m.notAfterPresent) {
      asn1Print_EXP_Time ("notAfter", &pvalue->notAfter);
   }

   rtxPrintCloseBrace ();
}

void ASN1C_CRMF_OptionalValidity::Print (const char* name)
{
   asn1Print_CRMF_OptionalValidity (name, &msgData);
}

void asn1Print_CRMF_CertTemplate 
   (const char* name, const ASN1T_CRMF_CertTemplate* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.versionPresent) {
      asn1Print_EXP_Version ("version", &pvalue->version);
   }

   if (pvalue->m.serialNumberPresent) {
      asn1Print_EXP_CertificateSerialNumber ("serialNumber", &pvalue->
         serialNumber);
   }

   if (pvalue->m.signingAlgPresent) {
      asn1Print_EXP_AlgorithmIdentifier ("signingAlg", &pvalue->signingAlg);
   }

   if (pvalue->m.issuerPresent) {
      asn1Print_EXP_Name ("issuer", &pvalue->issuer);
   }

   if (pvalue->m.validityPresent) {
      asn1Print_CRMF_OptionalValidity ("validity", &pvalue->validity);
   }

   if (pvalue->m.subjectPresent) {
      asn1Print_EXP_Name ("subject", &pvalue->subject);
   }

   if (pvalue->m.publicKeyPresent) {
      asn1Print_EXP_SubjectPublicKeyInfo ("publicKey", &pvalue->publicKey);
   }

   if (pvalue->m.issuerUIDPresent) {
      asn1Print_EXP_UniqueIdentifier ("issuerUID", &pvalue->issuerUID);
   }

   if (pvalue->m.subjectUIDPresent) {
      asn1Print_EXP_UniqueIdentifier ("subjectUID", &pvalue->subjectUID);
   }

   if (pvalue->m.extensionsPresent) {
      asn1Print_EXP_Extensions ("extensions", &pvalue->extensions);
   }

   rtxPrintCloseBrace ();
}

void ASN1C_CRMF_CertTemplate::Print (const char* name)
{
   asn1Print_CRMF_CertTemplate (name, &msgData);
}

void asn1Print_CRMF_SinglePubInfo 
   (const char* name, const ASN1T_CRMF_SinglePubInfo* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_CRMF_SinglePubInfo_pubMethod ("pubMethod", &pvalue->pubMethod);

   if (pvalue->m.pubLocationPresent) {
      asn1Print_IMP_GeneralName ("pubLocation", &pvalue->pubLocation);
   }

   rtxPrintCloseBrace ();
}

void ASN1C_CRMF_SinglePubInfo::Print (const char* name)
{
   asn1Print_CRMF_SinglePubInfo (name, &msgData);
}

void asn1Print_CRMF_PKIPublicationInfo_pubInfos 
   (const char* name, const ASN1T_CRMF_PKIPublicationInfo_pubInfos* pvalue)
{
   ASN1T_CRMF_SinglePubInfo* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (ASN1T_CRMF_SinglePubInfo*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_CRMF_SinglePubInfo (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void ASN1C_CRMF_PKIPublicationInfo_pubInfos::Print (const char* name)
{
   asn1Print_CRMF_PKIPublicationInfo_pubInfos (name, &msgData);
}

void asn1Print_CRMF_PKIPublicationInfo 
   (const char* name, const ASN1T_CRMF_PKIPublicationInfo* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_CRMF_PKIPublicationInfo_action ("action", &pvalue->action);

   if (pvalue->m.pubInfosPresent) {
      asn1Print_CRMF_PKIPublicationInfo_pubInfos ("pubInfos", &pvalue->pubInfos
         );
   }

   rtxPrintCloseBrace ();
}

void ASN1C_CRMF_PKIPublicationInfo::Print (const char* name)
{
   asn1Print_CRMF_PKIPublicationInfo (name, &msgData);
}

void asn1Print_CRMF_EncryptedValue 
   (const char* name, const ASN1T_CRMF_EncryptedValue* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.intendedAlgPresent) {
      asn1Print_EXP_AlgorithmIdentifier ("intendedAlg", &pvalue->intendedAlg);
   }

   if (pvalue->m.symmAlgPresent) {
      asn1Print_EXP_AlgorithmIdentifier ("symmAlg", &pvalue->symmAlg);
   }

   if (pvalue->m.encSymmKeyPresent) {
      rtxPrintIndent ();
      rtPrintBitStrBraceText ("encSymmKey", pvalue->encSymmKey.numbits, pvalue->encSymmKey.data);
   }

   if (pvalue->m.keyAlgPresent) {
      asn1Print_EXP_AlgorithmIdentifier ("keyAlg", &pvalue->keyAlg);
   }

   if (pvalue->m.valueHintPresent) {
      rtxPrintIndent ();
      rtxPrintHexStr ("valueHint", pvalue->valueHint.numocts, pvalue->valueHint.data);
   }

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("encValue", pvalue->encValue.numbits, pvalue->encValue.data);

   rtxPrintCloseBrace ();
}

void ASN1C_CRMF_EncryptedValue::Print (const char* name)
{
   asn1Print_CRMF_EncryptedValue (name, &msgData);
}

void asn1Print_CRMF_CertId (const char* name, const ASN1T_CRMF_CertId* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_IMP_GeneralName ("issuer", &pvalue->issuer);

   asn1Print_EXP_CertificateSerialNumber ("serialNumber", &pvalue->serialNumber
      );

   rtxPrintCloseBrace ();
}

void ASN1C_CRMF_CertId::Print (const char* name)
{
   asn1Print_CRMF_CertId (name, &msgData);
}

void asn1Print_CRMF_Controls 
   (const char* name, const ASN1T_CRMF_Controls* pvalue)
{
   ASN1T_EXP_AttributeTypeAndValue* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (ASN1T_EXP_AttributeTypeAndValue*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_EXP_AttributeTypeAndValue (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void ASN1C_CRMF_Controls::Print (const char* name)
{
   asn1Print_CRMF_Controls (name, &msgData);
}

void asn1Print_CRMF_CertRequest 
   (const char* name, const ASN1T_CRMF_CertRequest* pvalue)
{
   rtxPrintOpenBrace (name);

   rtxPrintIndent ();
   rtxPrintInteger ("certReqId", pvalue->certReqId);

   asn1Print_CRMF_CertTemplate ("certTemplate", &pvalue->certTemplate);

   if (pvalue->m.controlsPresent) {
      asn1Print_CRMF_Controls ("controls", &pvalue->controls);
   }

   rtxPrintCloseBrace ();
}

void ASN1C_CRMF_CertRequest::Print (const char* name)
{
   asn1Print_CRMF_CertRequest (name, &msgData);
}

void asn1Print_CRMF_PKMACValue 
   (const char* name, const ASN1T_CRMF_PKMACValue* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_EXP_AlgorithmIdentifier ("algId", &pvalue->algId);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("value", pvalue->value.numbits, pvalue->value.data);

   rtxPrintCloseBrace ();
}

void ASN1C_CRMF_PKMACValue::Print (const char* name)
{
   asn1Print_CRMF_PKMACValue (name, &msgData);
}

void asn1Print_CRMF_POPOSigningKeyInput_authInfo 
   (const char* name, const ASN1T_CRMF_POPOSigningKeyInput_authInfo* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* publicKeyMAC */
      case 1:
      {
         asn1Print_CRMF_PKMACValue ("publicKeyMAC", pvalue->u.publicKeyMAC);
         break;
      }
      /* sender */
      case 2:
      {
         asn1Print_IMP_GeneralName ("sender", pvalue->u.sender);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void ASN1C_CRMF_POPOSigningKeyInput_authInfo::Print (const char* name)
{
   asn1Print_CRMF_POPOSigningKeyInput_authInfo (name, &msgData);
}

void asn1Print_CRMF_POPOSigningKeyInput 
   (const char* name, const ASN1T_CRMF_POPOSigningKeyInput* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_CRMF_POPOSigningKeyInput_authInfo ("authInfo", &pvalue->authInfo
      );

   asn1Print_EXP_SubjectPublicKeyInfo ("publicKey", &pvalue->publicKey);

   rtxPrintCloseBrace ();
}

void ASN1C_CRMF_POPOSigningKeyInput::Print (const char* name)
{
   asn1Print_CRMF_POPOSigningKeyInput (name, &msgData);
}

void asn1Print_CRMF_POPOSigningKey 
   (const char* name, const ASN1T_CRMF_POPOSigningKey* pvalue)
{
   rtxPrintOpenBrace (name);

   if (pvalue->m.poposkInputPresent) {
      asn1Print_CRMF_POPOSigningKeyInput ("poposkInput", &pvalue->poposkInput
         );
   }

   asn1Print_EXP_AlgorithmIdentifier ("algorithmIdentifier", &pvalue->
      algorithmIdentifier);

   rtxPrintIndent ();
   rtPrintBitStrBraceText ("signature_", pvalue->signature_.numbits, pvalue->signature_.data);

   rtxPrintCloseBrace ();
}

void ASN1C_CRMF_POPOSigningKey::Print (const char* name)
{
   asn1Print_CRMF_POPOSigningKey (name, &msgData);
}

void asn1Print_CRMF_POPOPrivKey 
   (const char* name, const ASN1T_CRMF_POPOPrivKey* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* thisMessage */
      case 1:
      {
         rtxPrintIndent ();
         rtPrintBitStrBraceText ("thisMessage", pvalue->u.thisMessage->numbits, pvalue->u.thisMessage->data);
         break;
      }
      /* subsequentMessage */
      case 2:
      {
         asn1Print_CRMF_SubsequentMessage ("subsequentMessage", &pvalue->
            u.subsequentMessage);
         break;
      }
      /* dhMAC */
      case 3:
      {
         rtxPrintIndent ();
         rtPrintBitStrBraceText ("dhMAC", pvalue->u.dhMAC->numbits, pvalue->u.dhMAC->data);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void ASN1C_CRMF_POPOPrivKey::Print (const char* name)
{
   asn1Print_CRMF_POPOPrivKey (name, &msgData);
}

void asn1Print_CRMF_ProofOfPossession 
   (const char* name, const ASN1T_CRMF_ProofOfPossession* pvalue)
{
   rtxPrintOpenBrace (name);

   switch (pvalue->t)
   {
      /* raVerified */
      case 1:
      {
         rtxPrintIndent();
         rtxPrintNull ("raVerified");
         break;
      }
      /* signature */
      case 2:
      {
         asn1Print_CRMF_POPOSigningKey ("signature", pvalue->u.signature_);
         break;
      }
      /* keyEncipherment */
      case 3:
      {
         asn1Print_CRMF_POPOPrivKey ("keyEncipherment", pvalue->
            u.keyEncipherment);
         break;
      }
      /* keyAgreement */
      case 4:
      {
         asn1Print_CRMF_POPOPrivKey ("keyAgreement", pvalue->u.keyAgreement);
         break;
      }
      default:;
   }

   rtxPrintCloseBrace ();
}

void ASN1C_CRMF_ProofOfPossession::Print (const char* name)
{
   asn1Print_CRMF_ProofOfPossession (name, &msgData);
}

void asn1Print_CRMF_CertReqMsg_regInfo 
   (const char* name, const ASN1T_CRMF_CertReqMsg_regInfo* pvalue)
{
   ASN1T_EXP_AttributeTypeAndValue* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (ASN1T_EXP_AttributeTypeAndValue*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_EXP_AttributeTypeAndValue (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void ASN1C_CRMF_CertReqMsg_regInfo::Print (const char* name)
{
   asn1Print_CRMF_CertReqMsg_regInfo (name, &msgData);
}

void asn1Print_CRMF_CertReqMsg 
   (const char* name, const ASN1T_CRMF_CertReqMsg* pvalue)
{
   rtxPrintOpenBrace (name);

   asn1Print_CRMF_CertRequest ("certReq", &pvalue->certReq);

   if (pvalue->m.popPresent) {
      asn1Print_CRMF_ProofOfPossession ("pop", &pvalue->pop);
   }

   if (pvalue->m.regInfoPresent) {
      asn1Print_CRMF_CertReqMsg_regInfo ("regInfo", &pvalue->regInfo);
   }

   rtxPrintCloseBrace ();
}

void ASN1C_CRMF_CertReqMsg::Print (const char* name)
{
   asn1Print_CRMF_CertReqMsg (name, &msgData);
}

void asn1Print_CRMF_CertReqMessages 
   (const char* name, const ASN1T_CRMF_CertReqMessages* pvalue)
{
   ASN1T_CRMF_CertReqMsg* pdata0;
   OSRTDListNode* pnode;
   char namebuf[512];
   OSUINT32 xx1;

   pnode = pvalue->head;
   for (xx1 = 0; xx1 < pvalue->count; xx1++) {
      char numbuf[32];
      pdata0 = (ASN1T_CRMF_CertReqMsg*) pnode->data;
      rtxUIntToCharStr (xx1, numbuf, sizeof(numbuf), 0);
      rtxStrJoin (namebuf, sizeof(namebuf), name, "[", numbuf, "]", 0);
      asn1Print_CRMF_CertReqMsg (namebuf, pdata0);
      pnode = pnode->next;
   }
}

void ASN1C_CRMF_CertReqMessages::Print (const char* name)
{
   asn1Print_CRMF_CertReqMessages (name, &msgData);
}

