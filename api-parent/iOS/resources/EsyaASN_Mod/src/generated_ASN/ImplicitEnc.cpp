/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.6, Date: 28-Feb-2014.
 */
#include "Implicit.h"
#include "UsefulDefinitions.h"
#include "rtxsrc/rtxCommon.h"

EXTERN int asn1E_IMP_AnotherName (OSCTXT* pctxt,
   ASN1T_IMP_AnotherName *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AnotherName");

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
      xe_OpenType (pctxt, pvalue->value.data, pvalue->value.numocts));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode type_id */

   RTXCTXTPUSHELEMNAME (pctxt, "type-id");

   ll = xe_objid (pctxt, (ASN1OBJID*)&pvalue->type_id, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_EDIPartyName (OSCTXT* pctxt,
   ASN1T_IMP_EDIPartyName *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EDIPartyName");

   /* encode partyName */

   RTXCTXTPUSHELEMNAME (pctxt, "partyName");

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_EXP_DirectoryString (pctxt, &pvalue->partyName, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode nameAssigner */

   if (pvalue->m.nameAssignerPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "nameAssigner");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_EXP_DirectoryString (pctxt, &pvalue->nameAssigner, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_GeneralName (OSCTXT* pctxt,
   ASN1T_IMP_GeneralName *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "GeneralName");

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "otherName");

         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_IMP_AnotherName (pctxt, pvalue->u.otherName, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "rfc822Name");

         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
            xe_charstr (pctxt, pvalue->u.rfc822Name, ASN1IMPL, TM_UNIV|TM_PRIM|22));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "dNSName");

         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
            xe_charstr (pctxt, pvalue->u.dNSName, ASN1IMPL, TM_UNIV|TM_PRIM|22));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "x400Address");

         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|3,
            asn1E_EXP_ORAddress (pctxt, pvalue->u.x400Address, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case 5:
         RTXCTXTPUSHELEMNAME (pctxt, "directoryName");

         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|4,
            asn1E_EXP_Name (pctxt, pvalue->u.directoryName, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case 6:
         RTXCTXTPUSHELEMNAME (pctxt, "ediPartyName");

         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|5,
            asn1E_IMP_EDIPartyName (pctxt, pvalue->u.ediPartyName, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case 7:
         RTXCTXTPUSHELEMNAME (pctxt, "uniformResourceIdentifier");

         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|6,
            xe_charstr (pctxt, pvalue->u.uniformResourceIdentifier, ASN1IMPL, TM_UNIV|TM_PRIM|22));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case 8:
         RTXCTXTPUSHELEMNAME (pctxt, "iPAddress");

         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|7,
            xe_octstr (pctxt, pvalue->u.iPAddress->data, pvalue->u.iPAddress->numocts, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case 9:
         RTXCTXTPUSHELEMNAME (pctxt, "registeredID");

         ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|8,
            xe_objid (pctxt, (ASN1OBJID*)pvalue->u.registeredID, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         rtxErrAddIntParm (pctxt, pvalue->t);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_GeneralNames (OSCTXT* pctxt,
   ASN1T_IMP_GeneralNames *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode;
   int xx1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "GeneralNames");

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   xx1 = (int)pvalue->count;
   pnode = pvalue->tail;
   while (0 != pnode) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "GeneralName", xx1);

      ll = asn1E_IMP_GeneralName (pctxt, ((ASN1T_IMP_GeneralName*)pnode->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      xx1--;

      pnode = pnode->prev;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_SubjectAltName (OSCTXT* pctxt,
   ASN1T_IMP_SubjectAltName *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SubjectAltName");

   ll = asn1E_IMP_GeneralNames (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_KeyIdentifier (OSCTXT* pctxt,
   ASN1T_IMP_KeyIdentifier *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "KeyIdentifier");

   ll = xe_octstr (pctxt, pvalue->data, pvalue->numocts, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_SubjectKeyIdentifier (OSCTXT* pctxt,
   ASN1T_IMP_SubjectKeyIdentifier *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SubjectKeyIdentifier");

   ll = xe_octstr (pctxt, pvalue->data, pvalue->numocts, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_KeyUsage (OSCTXT* pctxt,
   ASN1T_IMP_KeyUsage *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "KeyUsage");

   ll = derEncBitString (pctxt, pvalue->data, pvalue->numbits, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_CertPolicyId (OSCTXT* pctxt,
   ASN1T_IMP_CertPolicyId *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CertPolicyId");

   ll = xe_objid (pctxt, (ASN1OBJID*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_PolicyQualifierId (OSCTXT* pctxt,
   ASN1T_IMP_PolicyQualifierId *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PolicyQualifierId");

   ll = xe_objid (pctxt, (ASN1OBJID*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_CPSuri (OSCTXT* pctxt,
   ASN1T_IMP_CPSuri pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CPSuri");

   ll = xe_charstr (pctxt, pvalue, tagging, TM_UNIV|TM_PRIM|22);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_KeyPurposeId (OSCTXT* pctxt,
   ASN1T_IMP_KeyPurposeId *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "KeyPurposeId");

   ll = xe_objid (pctxt, (ASN1OBJID*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_ReasonFlags (OSCTXT* pctxt,
   ASN1T_IMP_ReasonFlags *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReasonFlags");

   ll = derEncBitString (pctxt, pvalue->data, pvalue->numbits, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_CRLNumber (OSCTXT* pctxt,
   ASN1T_IMP_CRLNumber *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CRLNumber");

   ll = xe_bigint (pctxt, *pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_CRLReason (OSCTXT* pctxt,
   ASN1T_IMP_CRLReason *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CRLReason");

   if(*pvalue > 10)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enumUnsigned (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_BaseDistance (OSCTXT* pctxt,
   ASN1T_IMP_BaseDistance *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BaseDistance");

   if (!(*pvalue >= 0)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, *pvalue);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   ll = xe_unsigned (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_SkipCerts (OSCTXT* pctxt,
   ASN1T_IMP_SkipCerts *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SkipCerts");

   if (!(*pvalue >= 0)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, *pvalue);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   ll = xe_unsigned (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_InhibitAnyPolicy (OSCTXT* pctxt,
   ASN1T_IMP_InhibitAnyPolicy *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "InhibitAnyPolicy");

   ll = asn1E_IMP_SkipCerts (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_DistributionPointName (OSCTXT* pctxt,
   ASN1T_IMP_DistributionPointName *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DistributionPointName");

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "fullName");

         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_IMP_GeneralNames (pctxt, pvalue->u.fullName, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "nameRelativeToCRLIssuer");

         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_EXP_RelativeDistinguishedName (pctxt, pvalue->u.nameRelativeToCRLIssuer, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         rtxErrAddIntParm (pctxt, pvalue->t);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_DistributionPoint (OSCTXT* pctxt,
   ASN1T_IMP_DistributionPoint *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DistributionPoint");

   /* encode cRLIssuer */

   if (pvalue->m.cRLIssuerPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "cRLIssuer");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_IMP_GeneralNames (pctxt, &pvalue->cRLIssuer, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode reasons */

   if (pvalue->m.reasonsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "reasons");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         asn1E_IMP_ReasonFlags (pctxt, &pvalue->reasons, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode distributionPoint */

   if (pvalue->m.distributionPointPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "distributionPoint");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_IMP_DistributionPointName (pctxt, &pvalue->distributionPoint, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_CRLDistributionPoints (OSCTXT* pctxt,
   ASN1T_IMP_CRLDistributionPoints *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode;
   int xx1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CRLDistributionPoints");

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   xx1 = (int)pvalue->count;
   pnode = pvalue->tail;
   while (0 != pnode) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DistributionPoint", xx1);

      ll = asn1E_IMP_DistributionPoint (pctxt, ((ASN1T_IMP_DistributionPoint*)pnode->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      xx1--;

      pnode = pnode->prev;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_FreshestCRL (OSCTXT* pctxt,
   ASN1T_IMP_FreshestCRL *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "FreshestCRL");

   ll = asn1E_IMP_CRLDistributionPoints (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_BaseCRLNumber (OSCTXT* pctxt,
   ASN1T_IMP_BaseCRLNumber *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BaseCRLNumber");

   ll = asn1E_IMP_CRLNumber (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_IssuerAltName (OSCTXT* pctxt,
   ASN1T_IMP_IssuerAltName *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IssuerAltName");

   ll = asn1E_IMP_GeneralNames (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_HoldInstructionCode (OSCTXT* pctxt,
   ASN1T_IMP_HoldInstructionCode *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HoldInstructionCode");

   ll = xe_objid (pctxt, (ASN1OBJID*)pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_InvalidityDate (OSCTXT* pctxt,
   ASN1T_IMP_InvalidityDate pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "InvalidityDate");

   ll = xe_charstr (pctxt, pvalue, tagging, TM_UNIV|TM_PRIM|24);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_CertificateIssuer (OSCTXT* pctxt,
   ASN1T_IMP_CertificateIssuer *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CertificateIssuer");

   ll = asn1E_IMP_GeneralNames (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_AuthorityKeyIdentifier (OSCTXT* pctxt,
   ASN1T_IMP_AuthorityKeyIdentifier *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AuthorityKeyIdentifier");

   /* encode authorityCertSerialNumber */

   if (pvalue->m.authorityCertSerialNumberPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "authorityCertSerialNumber");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         asn1E_EXP_CertificateSerialNumber (pctxt, &pvalue->authorityCertSerialNumber, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode authorityCertIssuer */

   if (pvalue->m.authorityCertIssuerPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "authorityCertIssuer");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_IMP_GeneralNames (pctxt, &pvalue->authorityCertIssuer, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode keyIdentifier */

   if (pvalue->m.keyIdentifierPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "keyIdentifier");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         asn1E_IMP_KeyIdentifier (pctxt, &pvalue->keyIdentifier, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_PolicyQualifierInfo (OSCTXT* pctxt,
   ASN1T_IMP_PolicyQualifierInfo *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PolicyQualifierInfo");

   /* encode qualifier */

   RTXCTXTPUSHELEMNAME (pctxt, "qualifier");

   ll = xe_OpenType (pctxt, pvalue->qualifier.data, pvalue->qualifier.numocts);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode policyQualifierId */

   RTXCTXTPUSHELEMNAME (pctxt, "policyQualifierId");

   ll = asn1E_IMP_PolicyQualifierId (pctxt, &pvalue->policyQualifierId, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_PolicyInformation_policyQualifiers (OSCTXT* pctxt,
   ASN1T_IMP_PolicyInformation_policyQualifiers *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode;
   int xx1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   xx1 = (int)pvalue->count;
   pnode = pvalue->tail;
   while (0 != pnode) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PolicyQualifierInfo", xx1);

      ll = asn1E_IMP_PolicyQualifierInfo (pctxt, ((ASN1T_IMP_PolicyQualifierInfo*)pnode->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      xx1--;

      pnode = pnode->prev;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

EXTERN int asn1E_IMP_PolicyInformation (OSCTXT* pctxt,
   ASN1T_IMP_PolicyInformation *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PolicyInformation");

   /* encode policyQualifiers */

   if (pvalue->m.policyQualifiersPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "policyQualifiers");

      ll = asn1E_IMP_PolicyInformation_policyQualifiers (pctxt, &pvalue->policyQualifiers, ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode policyIdentifier */

   RTXCTXTPUSHELEMNAME (pctxt, "policyIdentifier");

   ll = asn1E_IMP_CertPolicyId (pctxt, &pvalue->policyIdentifier, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_CertificatePolicies (OSCTXT* pctxt,
   ASN1T_IMP_CertificatePolicies *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode;
   int xx1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CertificatePolicies");

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   xx1 = (int)pvalue->count;
   pnode = pvalue->tail;
   while (0 != pnode) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PolicyInformation", xx1);

      ll = asn1E_IMP_PolicyInformation (pctxt, ((ASN1T_IMP_PolicyInformation*)pnode->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      xx1--;

      pnode = pnode->prev;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_DisplayText (OSCTXT* pctxt,
   ASN1T_IMP_DisplayText *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DisplayText");

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "utf8String");

         { int nchars = rtxUTF8Len (pvalue->u.utf8String);
         if (!((nchars >= 1 && nchars <= 200))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }
         ll = xe_utf8str (pctxt, pvalue->u.utf8String, ASN1EXPL);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "ia5String");

         { OSSIZE nchars = OSCRTLSTRLEN (pvalue->u.ia5String);
         if (!((nchars >= 1 && nchars <= 200))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         ll = xe_charstr (pctxt, pvalue->u.ia5String, ASN1EXPL, TM_UNIV|TM_PRIM|22);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "visibleString");

         { OSSIZE nchars = OSCRTLSTRLEN (pvalue->u.visibleString);
         if (!((nchars >= 1 && nchars <= 200))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         ll = xe_charstr (pctxt, pvalue->u.visibleString, ASN1EXPL, TM_UNIV|TM_PRIM|26);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case 4:
         RTXCTXTPUSHELEMNAME (pctxt, "bmpString");

         if (!((pvalue->u.bmpString->nchars >= 1 && pvalue->u.bmpString->nchars <= 200
            ))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)pvalue->u.bmpString->nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         ll = xe_16BitCharStr (pctxt, pvalue->u.bmpString, ASN1EXPL, TM_UNIV|TM_PRIM|30);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         rtxErrAddIntParm (pctxt, pvalue->t);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_NoticeReference_noticeNumbers (OSCTXT* pctxt,
   ASN1T_IMP_NoticeReference_noticeNumbers *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode;
   int xx1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   xx1 = (int)pvalue->count;
   pnode = pvalue->tail;
   while (0 != pnode) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "INTEGER", xx1);

      ll = xe_integer (pctxt, ((OSINT32*)pnode->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      xx1--;

      pnode = pnode->prev;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

EXTERN int asn1E_IMP_NoticeReference (OSCTXT* pctxt,
   ASN1T_IMP_NoticeReference *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NoticeReference");

   /* encode noticeNumbers */

   RTXCTXTPUSHELEMNAME (pctxt, "noticeNumbers");

   ll = asn1E_IMP_NoticeReference_noticeNumbers (pctxt, &pvalue->noticeNumbers, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode organization */

   RTXCTXTPUSHELEMNAME (pctxt, "organization");

   ll = asn1E_IMP_DisplayText (pctxt, &pvalue->organization, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_UserNotice (OSCTXT* pctxt,
   ASN1T_IMP_UserNotice *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UserNotice");

   /* encode explicitText */

   if (pvalue->m.explicitTextPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "explicitText");

      ll = asn1E_IMP_DisplayText (pctxt, &pvalue->explicitText, ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode noticeRef */

   if (pvalue->m.noticeRefPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "noticeRef");

      ll = asn1E_IMP_NoticeReference (pctxt, &pvalue->noticeRef, ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_Qualifier (OSCTXT* pctxt,
   ASN1T_IMP_Qualifier *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Qualifier");

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "userNotice");

         ll = asn1E_IMP_UserNotice (pctxt, pvalue->u.userNotice, ASN1EXPL);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "cPSuri");

         ll = asn1E_IMP_CPSuri (pctxt, pvalue->u.cPSuri, ASN1EXPL);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         rtxErrAddIntParm (pctxt, pvalue->t);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_PolicyMappings_element (OSCTXT* pctxt,
   ASN1T_IMP_PolicyMappings_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   /* encode subjectDomainPolicy */

   RTXCTXTPUSHELEMNAME (pctxt, "subjectDomainPolicy");

   ll = asn1E_IMP_CertPolicyId (pctxt, &pvalue->subjectDomainPolicy, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode issuerDomainPolicy */

   RTXCTXTPUSHELEMNAME (pctxt, "issuerDomainPolicy");

   ll = asn1E_IMP_CertPolicyId (pctxt, &pvalue->issuerDomainPolicy, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

EXTERN int asn1E_IMP_PolicyMappings (OSCTXT* pctxt,
   ASN1T_IMP_PolicyMappings *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode;
   int xx1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PolicyMappings");

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   xx1 = (int)pvalue->count;
   pnode = pvalue->tail;
   while (0 != pnode) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", xx1);

      ll = asn1E_IMP_PolicyMappings_element (pctxt, ((ASN1T_IMP_PolicyMappings_element*)pnode->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      xx1--;

      pnode = pnode->prev;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_BasicConstraints (OSCTXT* pctxt,
   ASN1T_IMP_BasicConstraints *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BasicConstraints");

   /* encode pathLenConstraint */

   if (pvalue->m.pathLenConstraintPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "pathLenConstraint");

      if (!(pvalue->pathLenConstraint >= 0)) {
         rtxErrAddElemNameParm (pctxt);
         rtxErrAddUIntParm (pctxt, pvalue->pathLenConstraint);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      ll = xe_unsigned (pctxt, &pvalue->pathLenConstraint, ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode cA */

   if (pvalue->cA != FALSE) {
      RTXCTXTPUSHELEMNAME (pctxt, "cA");

      ll = xe_boolean (pctxt, &pvalue->cA, ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_ExtKeyUsageSyntax (OSCTXT* pctxt,
   ASN1T_IMP_ExtKeyUsageSyntax *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode;
   int xx1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ExtKeyUsageSyntax");

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   xx1 = (int)pvalue->count;
   pnode = pvalue->tail;
   while (0 != pnode) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "KeyPurposeId", xx1);

      ll = asn1E_IMP_KeyPurposeId (pctxt, ((ASN1T_IMP_KeyPurposeId*)pnode->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      xx1--;

      pnode = pnode->prev;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_AccessDescription (OSCTXT* pctxt,
   ASN1T_IMP_AccessDescription *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AccessDescription");

   /* encode accessLocation */

   RTXCTXTPUSHELEMNAME (pctxt, "accessLocation");

   ll = asn1E_IMP_GeneralName (pctxt, &pvalue->accessLocation, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode accessMethod */

   RTXCTXTPUSHELEMNAME (pctxt, "accessMethod");

   ll = xe_objid (pctxt, (ASN1OBJID*)&pvalue->accessMethod, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_AuthorityInfoAccessSyntax (OSCTXT* pctxt,
   ASN1T_IMP_AuthorityInfoAccessSyntax *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode;
   int xx1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AuthorityInfoAccessSyntax");

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   xx1 = (int)pvalue->count;
   pnode = pvalue->tail;
   while (0 != pnode) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "AccessDescription", xx1);

      ll = asn1E_IMP_AccessDescription (pctxt, ((ASN1T_IMP_AccessDescription*)pnode->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      xx1--;

      pnode = pnode->prev;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_SubjectInfoAccessSyntax (OSCTXT* pctxt,
   ASN1T_IMP_SubjectInfoAccessSyntax *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode;
   int xx1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SubjectInfoAccessSyntax");

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   xx1 = (int)pvalue->count;
   pnode = pvalue->tail;
   while (0 != pnode) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "AccessDescription", xx1);

      ll = asn1E_IMP_AccessDescription (pctxt, ((ASN1T_IMP_AccessDescription*)pnode->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      xx1--;

      pnode = pnode->prev;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_SubjectDirectoryAttributes (OSCTXT* pctxt,
   ASN1T_IMP_SubjectDirectoryAttributes *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode;
   int xx1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SubjectDirectoryAttributes");

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   xx1 = (int)pvalue->count;
   pnode = pvalue->tail;
   while (0 != pnode) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "Attribute", xx1);

      ll = asn1E_EXP_Attribute (pctxt, ((ASN1T_EXP_Attribute*)pnode->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      xx1--;

      pnode = pnode->prev;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_RoleSyntax (OSCTXT* pctxt,
   ASN1T_IMP_RoleSyntax *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RoleSyntax");

   /* encode roleName */

   RTXCTXTPUSHELEMNAME (pctxt, "roleName");

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_IMP_GeneralName (pctxt, &pvalue->roleName, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode roleAuthority */

   if (pvalue->m.roleAuthorityPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "roleAuthority");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_IMP_GeneralNames (pctxt, &pvalue->roleAuthority, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_GeneralSubtree (OSCTXT* pctxt,
   ASN1T_IMP_GeneralSubtree *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "GeneralSubtree");

   /* encode maximum */

   if (pvalue->m.maximumPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "maximum");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         asn1E_IMP_BaseDistance (pctxt, &pvalue->maximum, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode minimum */

   if (pvalue->minimum != 0) {
      RTXCTXTPUSHELEMNAME (pctxt, "minimum");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         asn1E_IMP_BaseDistance (pctxt, &pvalue->minimum, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode base */

   RTXCTXTPUSHELEMNAME (pctxt, "base");

   ll = asn1E_IMP_GeneralName (pctxt, &pvalue->base, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_GeneralSubtrees (OSCTXT* pctxt,
   ASN1T_IMP_GeneralSubtrees *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode;
   int xx1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "GeneralSubtrees");

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   xx1 = (int)pvalue->count;
   pnode = pvalue->tail;
   while (0 != pnode) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "GeneralSubtree", xx1);

      ll = asn1E_IMP_GeneralSubtree (pctxt, ((ASN1T_IMP_GeneralSubtree*)pnode->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      xx1--;

      pnode = pnode->prev;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_NameConstraints (OSCTXT* pctxt,
   ASN1T_IMP_NameConstraints *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NameConstraints");

   /* encode excludedSubtrees */

   if (pvalue->m.excludedSubtreesPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "excludedSubtrees");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_IMP_GeneralSubtrees (pctxt, &pvalue->excludedSubtrees, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode permittedSubtrees */

   if (pvalue->m.permittedSubtreesPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "permittedSubtrees");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_IMP_GeneralSubtrees (pctxt, &pvalue->permittedSubtrees, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_PolicyConstraints (OSCTXT* pctxt,
   ASN1T_IMP_PolicyConstraints *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PolicyConstraints");

   /* encode inhibitPolicyMapping */

   if (pvalue->m.inhibitPolicyMappingPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "inhibitPolicyMapping");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         asn1E_IMP_SkipCerts (pctxt, &pvalue->inhibitPolicyMapping, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode requireExplicitPolicy */

   if (pvalue->m.requireExplicitPolicyPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "requireExplicitPolicy");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
         asn1E_IMP_SkipCerts (pctxt, &pvalue->requireExplicitPolicy, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_IMP_IssuingDistributionPoint (OSCTXT* pctxt,
   ASN1T_IMP_IssuingDistributionPoint *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IssuingDistributionPoint");

   /* encode onlyContainsAttributeCerts */

   if (pvalue->onlyContainsAttributeCerts != FALSE) {
      RTXCTXTPUSHELEMNAME (pctxt, "onlyContainsAttributeCerts");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|5,
         xe_boolean (pctxt, &pvalue->onlyContainsAttributeCerts, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode indirectCRL */

   if (pvalue->indirectCRL != FALSE) {
      RTXCTXTPUSHELEMNAME (pctxt, "indirectCRL");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|4,
         xe_boolean (pctxt, &pvalue->indirectCRL, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode onlySomeReasons */

   if (pvalue->m.onlySomeReasonsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "onlySomeReasons");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|3,
         asn1E_IMP_ReasonFlags (pctxt, &pvalue->onlySomeReasons, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode onlyContainsCACerts */

   if (pvalue->onlyContainsCACerts != FALSE) {
      RTXCTXTPUSHELEMNAME (pctxt, "onlyContainsCACerts");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|2,
         xe_boolean (pctxt, &pvalue->onlyContainsCACerts, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode onlyContainsUserCerts */

   if (pvalue->onlyContainsUserCerts != FALSE) {
      RTXCTXTPUSHELEMNAME (pctxt, "onlyContainsUserCerts");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         xe_boolean (pctxt, &pvalue->onlyContainsUserCerts, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode distributionPoint */

   if (pvalue->m.distributionPointPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "distributionPoint");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_IMP_DistributionPointName (pctxt, &pvalue->distributionPoint, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

