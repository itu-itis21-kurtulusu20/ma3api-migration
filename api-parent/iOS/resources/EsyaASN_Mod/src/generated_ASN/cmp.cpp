/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.6, Date: 28-Feb-2014.
 */
#include <new>
#include "cmp.h"
#include "rtxsrc/rtxCommon.h"

ASN1OBJID CMP_id_PasswordBasedMac = {
   7,
   { 1, 2, 840, 113533, 7, 66, 13 }
} ;
ASN1OBJID CMP_id_HMAC_SHA1 = {
   9,
   { 1, 3, 6, 1, 5, 5, 8, 1, 2 }
} ;
ASN1OBJID CMP_id_DHBasedMac = {
   7,
   { 1, 2, 840, 113533, 7, 66, 30 }
} ;

ASN1T_CMP_PKIProtection* new_ASN1T_CMP_PKIProtection (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_PKIProtection));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_PKIProtection;
}

ASN1C_CMP_PKIProtection::ASN1C_CMP_PKIProtection
    (ASN1T_CMP_PKIProtection& data) : ASN1CBitStr (data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_PKIProtection::ASN1C_CMP_PKIProtection (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_PKIProtection& data) : ASN1CBitStr (msgBuf, data), msgData(data)
   
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_PKIProtection::ASN1C_CMP_PKIProtection (OSRTContext &context
   , ASN1T_CMP_PKIProtection& data) : ASN1CBitStr (context, data
   ), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_CMP_PKIProtection::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_PKIProtection (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_PKIProtection::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_CMP_PKIProtection (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_PKIProtection (ASN1T_CMP_PKIProtection* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_PKIProtection;
}

void asn1Free_CMP_PKIProtection (OSCTXT *pctxt, 
   ASN1T_CMP_PKIProtection* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numbits > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numbits = 0;
      pvalue->data = 0;
   }
}

void ASN1C_CMP_PKIProtection::MemFree ()
{
   asn1Free_CMP_PKIProtection (getCtxtPtr(), &msgData);
}

ASN1T_CMP_PKIHeader_pvno* new_ASN1T_CMP_PKIHeader_pvno (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_PKIHeader_pvno));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_PKIHeader_pvno;
}

ASN1C_CMP_PKIHeader_pvno::ASN1C_CMP_PKIHeader_pvno
    (ASN1T_CMP_PKIHeader_pvno& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_PKIHeader_pvno::ASN1C_CMP_PKIHeader_pvno (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_PKIHeader_pvno& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_PKIHeader_pvno::ASN1C_CMP_PKIHeader_pvno (OSRTContext &context
   , ASN1T_CMP_PKIHeader_pvno& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_CMP_PKIHeader_pvno::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_PKIHeader_pvno (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_PKIHeader_pvno::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_CMP_PKIHeader_pvno (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

ASN1C_CMP_PKIFreeText::ASN1C_CMP_PKIFreeText (ASN1T_CMP_PKIFreeText& data) : 
   ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_PKIFreeText::ASN1C_CMP_PKIFreeText (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_PKIFreeText& data) : ASN1CSeqOfList(msgBuf, data), msgData(data)
   
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_PKIFreeText::ASN1C_CMP_PKIFreeText (OSRTContext &context
   , ASN1T_CMP_PKIFreeText& data) : ASN1CSeqOfList(context, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CMP_PKIFreeText::ASN1C_CMP_PKIFreeText (ASN1CType& ccobj
   , ASN1T_CMP_PKIFreeText& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CMP_PKIFreeText::Append (const OSUTF8CHAR* elem)
{
   append ((void*)elem);
}

ASN1T_CMP_PKIFreeText::~ASN1T_CMP_PKIFreeText ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_PKIFreeText (pctxt, this);
   }
}

int ASN1C_CMP_PKIFreeText::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_PKIFreeText (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_PKIFreeText::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_PKIFreeText;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_PKIFreeText (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_PKIFreeText (ASN1T_CMP_PKIFreeText* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_PKIFreeText;
   rtxDListFastInit (pvalue);
}

void asn1Free_CMP_PKIFreeText (OSCTXT *pctxt, ASN1T_CMP_PKIFreeText* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void ASN1C_CMP_PKIFreeText::MemFree ()
{
   asn1Free_CMP_PKIFreeText (getCtxtPtr(), &msgData);
}

ASN1T_CMP_InfoTypeAndValue* new_ASN1T_CMP_InfoTypeAndValue (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_InfoTypeAndValue));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_InfoTypeAndValue;
}

ASN1C_CMP_InfoTypeAndValue::ASN1C_CMP_InfoTypeAndValue
    (ASN1T_CMP_InfoTypeAndValue& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_InfoTypeAndValue::ASN1C_CMP_InfoTypeAndValue (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMP_InfoTypeAndValue& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_InfoTypeAndValue::ASN1C_CMP_InfoTypeAndValue (OSRTContext &context
   , ASN1T_CMP_InfoTypeAndValue& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMP_InfoTypeAndValue::ASN1T_CMP_InfoTypeAndValue ()
{
   m.infoValuePresent = 0;
}

ASN1T_CMP_InfoTypeAndValue::~ASN1T_CMP_InfoTypeAndValue ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_InfoTypeAndValue (pctxt, this);
   }
}

int ASN1C_CMP_InfoTypeAndValue::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_InfoTypeAndValue (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_InfoTypeAndValue::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_InfoTypeAndValue;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_InfoTypeAndValue (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_InfoTypeAndValue (ASN1T_CMP_InfoTypeAndValue* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_InfoTypeAndValue;
}

void asn1Free_CMP_InfoTypeAndValue (OSCTXT *pctxt, 
   ASN1T_CMP_InfoTypeAndValue* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.infoValuePresent) {
      rtxMemFreePtr (pctxt, (void*)pvalue->infoValue.data);
   }
}

void ASN1C_CMP_InfoTypeAndValue::MemFree ()
{
   asn1Free_CMP_InfoTypeAndValue (getCtxtPtr(), &msgData);
}

ASN1C_CMP_PKIHeader_generalInfo::ASN1C_CMP_PKIHeader_generalInfo
    (ASN1T_CMP_PKIHeader_generalInfo& data) : ASN1CSeqOfList(data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_PKIHeader_generalInfo::ASN1C_CMP_PKIHeader_generalInfo (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMP_PKIHeader_generalInfo& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_PKIHeader_generalInfo::ASN1C_CMP_PKIHeader_generalInfo (
   OSRTContext &context, ASN1T_CMP_PKIHeader_generalInfo& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CMP_PKIHeader_generalInfo::
   ASN1C_CMP_PKIHeader_generalInfo (ASN1CType& ccobj
   , ASN1T_CMP_PKIHeader_generalInfo& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CMP_PKIHeader_generalInfo::Append (ASN1T_CMP_InfoTypeAndValue* elem)
{
   append ((void*)elem);
}

ASN1T_CMP_InfoTypeAndValue* ASN1C_CMP_PKIHeader_generalInfo::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_CMP_InfoTypeAndValue));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_InfoTypeAndValue;
}

ASN1T_CMP_InfoTypeAndValue* ASN1C_CMP_PKIHeader_generalInfo::AppendNewElement ()
{
   ASN1T_CMP_InfoTypeAndValue* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CMP_PKIHeader_generalInfo::~ASN1T_CMP_PKIHeader_generalInfo ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_PKIHeader_generalInfo (pctxt, this);
   }
}

int ASN1C_CMP_PKIHeader_generalInfo::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_PKIHeader_generalInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_PKIHeader_generalInfo::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_PKIHeader_generalInfo;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_PKIHeader_generalInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_PKIHeader_generalInfo (
   ASN1T_CMP_PKIHeader_generalInfo* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_PKIHeader_generalInfo;
   rtxDListFastInit (pvalue);
}

void asn1Free_CMP_PKIHeader_generalInfo (OSCTXT *pctxt, 
   ASN1T_CMP_PKIHeader_generalInfo* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_CMP_InfoTypeAndValue* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_CMP_InfoTypeAndValue*)pnode->data;
      asn1Free_CMP_InfoTypeAndValue (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CMP_PKIHeader_generalInfo::MemFree ()
{
   asn1Free_CMP_PKIHeader_generalInfo (getCtxtPtr(), &msgData);
}

ASN1T_CMP_PKIHeader* new_ASN1T_CMP_PKIHeader (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_PKIHeader));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_PKIHeader;
}

ASN1C_CMP_PKIHeader::ASN1C_CMP_PKIHeader (ASN1T_CMP_PKIHeader& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_PKIHeader::ASN1C_CMP_PKIHeader (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_PKIHeader& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_PKIHeader::ASN1C_CMP_PKIHeader (OSRTContext &context
   , ASN1T_CMP_PKIHeader& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMP_PKIHeader::ASN1T_CMP_PKIHeader ()
{
   m.messageTimePresent = 0;
   messageTime = 0;
   m.protectionAlgPresent = 0;
   m.senderKIDPresent = 0;
   m.recipKIDPresent = 0;
   m.transactionIDPresent = 0;
   m.senderNoncePresent = 0;
   m.recipNoncePresent = 0;
   m.freeTextPresent = 0;
   m.generalInfoPresent = 0;
}

ASN1T_CMP_PKIHeader::~ASN1T_CMP_PKIHeader ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_PKIHeader (pctxt, this);
   }
}

int ASN1C_CMP_PKIHeader::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_PKIHeader (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_PKIHeader::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_PKIHeader;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_PKIHeader (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_PKIHeader (ASN1T_CMP_PKIHeader* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_PKIHeader;
}

void asn1Free_CMP_PKIHeader (OSCTXT *pctxt, ASN1T_CMP_PKIHeader* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_IMP_GeneralName (pctxt, &pvalue->sender);
   asn1Free_IMP_GeneralName (pctxt, &pvalue->recipient);
   if (pvalue->m.messageTimePresent) {
      rtxMemFreePtr (pctxt, (void*)pvalue->messageTime);
   }
   if (pvalue->m.protectionAlgPresent) {
      asn1Free_EXP_AlgorithmIdentifier (pctxt, &pvalue->protectionAlg);
   }
   if (pvalue->m.senderKIDPresent) {
      asn1Free_IMP_KeyIdentifier (pctxt, &pvalue->senderKID);
   }
   if (pvalue->m.recipKIDPresent) {
      asn1Free_IMP_KeyIdentifier (pctxt, &pvalue->recipKID);
   }
   if (pvalue->m.transactionIDPresent) {
      if (pvalue->transactionID.numocts > 0) {
         rtxMemFreePtr (pctxt, (void*)pvalue->transactionID.data);
         pvalue->transactionID.numocts = 0;
         pvalue->transactionID.data = 0;
      }
   }
   if (pvalue->m.senderNoncePresent) {
      if (pvalue->senderNonce.numocts > 0) {
         rtxMemFreePtr (pctxt, (void*)pvalue->senderNonce.data);
         pvalue->senderNonce.numocts = 0;
         pvalue->senderNonce.data = 0;
      }
   }
   if (pvalue->m.recipNoncePresent) {
      if (pvalue->recipNonce.numocts > 0) {
         rtxMemFreePtr (pctxt, (void*)pvalue->recipNonce.data);
         pvalue->recipNonce.numocts = 0;
         pvalue->recipNonce.data = 0;
      }
   }
   if (pvalue->m.freeTextPresent) {
      asn1Free_CMP_PKIFreeText (pctxt, &pvalue->freeText);
   }
   if (pvalue->m.generalInfoPresent) {
      asn1Free_CMP_PKIHeader_generalInfo (pctxt, &pvalue->generalInfo);
   }
}

void ASN1C_CMP_PKIHeader::MemFree ()
{
   asn1Free_CMP_PKIHeader (getCtxtPtr(), &msgData);
}

ASN1T_CMP_CMPCertificate* new_ASN1T_CMP_CMPCertificate (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_CMPCertificate));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_CMPCertificate;
}

ASN1C_CMP_CMPCertificate::ASN1C_CMP_CMPCertificate
    (ASN1T_CMP_CMPCertificate& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_CMPCertificate::ASN1C_CMP_CMPCertificate (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_CMPCertificate& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_CMPCertificate::ASN1C_CMP_CMPCertificate (OSRTContext &context
   , ASN1T_CMP_CMPCertificate& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMP_CMPCertificate::~ASN1T_CMP_CMPCertificate ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_CMPCertificate (pctxt, this);
   }
}

int ASN1C_CMP_CMPCertificate::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_CMPCertificate (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_CMPCertificate::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_CMPCertificate;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_CMPCertificate (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_CMPCertificate (ASN1T_CMP_CMPCertificate* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_CMPCertificate;
}

void asn1Free_CMP_CMPCertificate (OSCTXT *pctxt, 
   ASN1T_CMP_CMPCertificate* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.x509v3PKCert) {
            asn1Free_EXP_Certificate (pctxt, pvalue->u.x509v3PKCert);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.x509v3PKCert);
         }
         break;

   }
}

void ASN1C_CMP_CMPCertificate::MemFree ()
{
   asn1Free_CMP_CMPCertificate (getCtxtPtr(), &msgData);
}

ASN1C_CMP_CertRepMessage_caPubs::ASN1C_CMP_CertRepMessage_caPubs
    (ASN1T_CMP_CertRepMessage_caPubs& data) : ASN1CSeqOfList(data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_CertRepMessage_caPubs::ASN1C_CMP_CertRepMessage_caPubs (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMP_CertRepMessage_caPubs& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_CertRepMessage_caPubs::ASN1C_CMP_CertRepMessage_caPubs (
   OSRTContext &context, ASN1T_CMP_CertRepMessage_caPubs& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CMP_CertRepMessage_caPubs::
   ASN1C_CMP_CertRepMessage_caPubs (ASN1CType& ccobj
   , ASN1T_CMP_CertRepMessage_caPubs& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CMP_CertRepMessage_caPubs::Append (ASN1T_CMP_CMPCertificate* elem)
{
   append ((void*)elem);
}

ASN1T_CMP_CMPCertificate* ASN1C_CMP_CertRepMessage_caPubs::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_CMP_CMPCertificate));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_CMPCertificate;
}

ASN1T_CMP_CMPCertificate* ASN1C_CMP_CertRepMessage_caPubs::AppendNewElement ()
{
   ASN1T_CMP_CMPCertificate* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CMP_CertRepMessage_caPubs::~ASN1T_CMP_CertRepMessage_caPubs ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_CertRepMessage_caPubs (pctxt, this);
   }
}

int ASN1C_CMP_CertRepMessage_caPubs::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_CertRepMessage_caPubs (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_CertRepMessage_caPubs::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_CertRepMessage_caPubs;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_CertRepMessage_caPubs (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_CertRepMessage_caPubs (
   ASN1T_CMP_CertRepMessage_caPubs* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_CertRepMessage_caPubs;
   rtxDListFastInit (pvalue);
}

void asn1Free_CMP_CertRepMessage_caPubs (OSCTXT *pctxt, 
   ASN1T_CMP_CertRepMessage_caPubs* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_CMP_CMPCertificate* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_CMP_CMPCertificate*)pnode->data;
      asn1Free_CMP_CMPCertificate (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CMP_CertRepMessage_caPubs::MemFree ()
{
   asn1Free_CMP_CertRepMessage_caPubs (getCtxtPtr(), &msgData);
}

ASN1T_CMP_PKIStatus* new_ASN1T_CMP_PKIStatus (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_PKIStatus));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_PKIStatus;
}

ASN1C_CMP_PKIStatus::ASN1C_CMP_PKIStatus (ASN1T_CMP_PKIStatus& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_PKIStatus::ASN1C_CMP_PKIStatus (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_PKIStatus& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_PKIStatus::ASN1C_CMP_PKIStatus (OSRTContext &context
   , ASN1T_CMP_PKIStatus& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_CMP_PKIStatus::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_PKIStatus (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_PKIStatus::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_CMP_PKIStatus (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

ASN1T_CMP_PKIFailureInfo* new_ASN1T_CMP_PKIFailureInfo (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_PKIFailureInfo));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_PKIFailureInfo;
}

ASN1C_CMP_PKIFailureInfo::ASN1C_CMP_PKIFailureInfo
    (ASN1T_CMP_PKIFailureInfo& data) : ASN1CBitStr (data.data, data.numbits, 32
   ), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_PKIFailureInfo::ASN1C_CMP_PKIFailureInfo (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_PKIFailureInfo& data) : ASN1CBitStr (msgBuf, data.data, 
   data.numbits, 32), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_PKIFailureInfo::ASN1C_CMP_PKIFailureInfo (OSRTContext &context
   , ASN1T_CMP_PKIFailureInfo& data) : ASN1CBitStr (context, data.data, 
   data.numbits, 32), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_CMP_PKIFailureInfo::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_PKIFailureInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_PKIFailureInfo::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_CMP_PKIFailureInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_PKIFailureInfo (ASN1T_CMP_PKIFailureInfo* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_PKIFailureInfo;
}

ASN1T_CMP_PKIStatusInfo* new_ASN1T_CMP_PKIStatusInfo (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_PKIStatusInfo));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_PKIStatusInfo;
}

ASN1C_CMP_PKIStatusInfo::ASN1C_CMP_PKIStatusInfo
    (ASN1T_CMP_PKIStatusInfo& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_PKIStatusInfo::ASN1C_CMP_PKIStatusInfo (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_PKIStatusInfo& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_PKIStatusInfo::ASN1C_CMP_PKIStatusInfo (OSRTContext &context
   , ASN1T_CMP_PKIStatusInfo& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMP_PKIStatusInfo::ASN1T_CMP_PKIStatusInfo ()
{
   m.statusStringPresent = 0;
   m.failInfoPresent = 0;
}

ASN1T_CMP_PKIStatusInfo::~ASN1T_CMP_PKIStatusInfo ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_PKIStatusInfo (pctxt, this);
   }
}

int ASN1C_CMP_PKIStatusInfo::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_PKIStatusInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_PKIStatusInfo::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_PKIStatusInfo;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_PKIStatusInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_PKIStatusInfo (ASN1T_CMP_PKIStatusInfo* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_PKIStatusInfo;
}

void asn1Free_CMP_PKIStatusInfo (OSCTXT *pctxt, 
   ASN1T_CMP_PKIStatusInfo* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.statusStringPresent) {
      asn1Free_CMP_PKIFreeText (pctxt, &pvalue->statusString);
   }
}

void ASN1C_CMP_PKIStatusInfo::MemFree ()
{
   asn1Free_CMP_PKIStatusInfo (getCtxtPtr(), &msgData);
}

ASN1T_CMP_CertOrEncCert* new_ASN1T_CMP_CertOrEncCert (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_CertOrEncCert));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_CertOrEncCert;
}

ASN1C_CMP_CertOrEncCert::ASN1C_CMP_CertOrEncCert
    (ASN1T_CMP_CertOrEncCert& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_CertOrEncCert::ASN1C_CMP_CertOrEncCert (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_CertOrEncCert& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_CertOrEncCert::ASN1C_CMP_CertOrEncCert (OSRTContext &context
   , ASN1T_CMP_CertOrEncCert& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMP_CertOrEncCert::~ASN1T_CMP_CertOrEncCert ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_CertOrEncCert (pctxt, this);
   }
}

int ASN1C_CMP_CertOrEncCert::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_CertOrEncCert (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_CertOrEncCert::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_CertOrEncCert;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_CertOrEncCert (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_CertOrEncCert (ASN1T_CMP_CertOrEncCert* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_CertOrEncCert;
}

void asn1Free_CMP_CertOrEncCert (OSCTXT *pctxt, 
   ASN1T_CMP_CertOrEncCert* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.certificate) {
            asn1Free_CMP_CMPCertificate (pctxt, pvalue->u.certificate);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.certificate);
         }
         break;

      case 2:
         if (0 != pvalue->u.encryptedCert) {
            asn1Free_CRMF_EncryptedValue (pctxt, pvalue->u.encryptedCert);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.encryptedCert);
         }
         break;

   }
}

void ASN1C_CMP_CertOrEncCert::MemFree ()
{
   asn1Free_CMP_CertOrEncCert (getCtxtPtr(), &msgData);
}

ASN1T_CMP_CertifiedKeyPair* new_ASN1T_CMP_CertifiedKeyPair (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_CertifiedKeyPair));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_CertifiedKeyPair;
}

ASN1C_CMP_CertifiedKeyPair::ASN1C_CMP_CertifiedKeyPair
    (ASN1T_CMP_CertifiedKeyPair& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_CertifiedKeyPair::ASN1C_CMP_CertifiedKeyPair (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMP_CertifiedKeyPair& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_CertifiedKeyPair::ASN1C_CMP_CertifiedKeyPair (OSRTContext &context
   , ASN1T_CMP_CertifiedKeyPair& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMP_CertifiedKeyPair::ASN1T_CMP_CertifiedKeyPair ()
{
   m.privateKeyPresent = 0;
   m.publicationInfoPresent = 0;
}

ASN1T_CMP_CertifiedKeyPair::~ASN1T_CMP_CertifiedKeyPair ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_CertifiedKeyPair (pctxt, this);
   }
}

int ASN1C_CMP_CertifiedKeyPair::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_CertifiedKeyPair (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_CertifiedKeyPair::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_CertifiedKeyPair;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_CertifiedKeyPair (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_CertifiedKeyPair (ASN1T_CMP_CertifiedKeyPair* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_CertifiedKeyPair;
}

void asn1Free_CMP_CertifiedKeyPair (OSCTXT *pctxt, 
   ASN1T_CMP_CertifiedKeyPair* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_CMP_CertOrEncCert (pctxt, &pvalue->certOrEncCert);
   if (pvalue->m.privateKeyPresent) {
      asn1Free_CRMF_EncryptedValue (pctxt, &pvalue->privateKey);
   }
   if (pvalue->m.publicationInfoPresent) {
      asn1Free_CRMF_PKIPublicationInfo (pctxt, &pvalue->publicationInfo);
   }
}

void ASN1C_CMP_CertifiedKeyPair::MemFree ()
{
   asn1Free_CMP_CertifiedKeyPair (getCtxtPtr(), &msgData);
}

ASN1T_CMP_CertResponse* new_ASN1T_CMP_CertResponse (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_CertResponse));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_CertResponse;
}

ASN1C_CMP_CertResponse::ASN1C_CMP_CertResponse (ASN1T_CMP_CertResponse& data)
    : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_CertResponse::ASN1C_CMP_CertResponse (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_CertResponse& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_CertResponse::ASN1C_CMP_CertResponse (OSRTContext &context
   , ASN1T_CMP_CertResponse& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMP_CertResponse::ASN1T_CMP_CertResponse ()
{
   m.certifiedKeyPairPresent = 0;
   m.rspInfoPresent = 0;
}

ASN1T_CMP_CertResponse::~ASN1T_CMP_CertResponse ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_CertResponse (pctxt, this);
   }
}

int ASN1C_CMP_CertResponse::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_CertResponse (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_CertResponse::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_CertResponse;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_CertResponse (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_CertResponse (ASN1T_CMP_CertResponse* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_CertResponse;
}

void asn1Free_CMP_CertResponse (OSCTXT *pctxt, ASN1T_CMP_CertResponse* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_CMP_PKIStatusInfo (pctxt, &pvalue->status);
   if (pvalue->m.certifiedKeyPairPresent) {
      asn1Free_CMP_CertifiedKeyPair (pctxt, &pvalue->certifiedKeyPair);
   }
   if (pvalue->m.rspInfoPresent) {
      if (pvalue->rspInfo.numocts > 0) {
         rtxMemFreePtr (pctxt, (void*)pvalue->rspInfo.data);
         pvalue->rspInfo.numocts = 0;
         pvalue->rspInfo.data = 0;
      }
   }
}

void ASN1C_CMP_CertResponse::MemFree ()
{
   asn1Free_CMP_CertResponse (getCtxtPtr(), &msgData);
}

ASN1C_CMP__SeqOfCMP_CertResponse::ASN1C_CMP__SeqOfCMP_CertResponse
    (ASN1T_CMP__SeqOfCMP_CertResponse& data) : ASN1CSeqOfList(data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP__SeqOfCMP_CertResponse::ASN1C_CMP__SeqOfCMP_CertResponse (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMP__SeqOfCMP_CertResponse& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP__SeqOfCMP_CertResponse::ASN1C_CMP__SeqOfCMP_CertResponse (
   OSRTContext &context, ASN1T_CMP__SeqOfCMP_CertResponse& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CMP__SeqOfCMP_CertResponse::
   ASN1C_CMP__SeqOfCMP_CertResponse (ASN1CType& ccobj
   , ASN1T_CMP__SeqOfCMP_CertResponse& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CMP__SeqOfCMP_CertResponse::Append (ASN1T_CMP_CertResponse* elem)
{
   append ((void*)elem);
}

ASN1T_CMP_CertResponse* ASN1C_CMP__SeqOfCMP_CertResponse::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_CMP_CertResponse));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_CertResponse;
}

ASN1T_CMP_CertResponse* ASN1C_CMP__SeqOfCMP_CertResponse::AppendNewElement ()
{
   ASN1T_CMP_CertResponse* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CMP__SeqOfCMP_CertResponse::~ASN1T_CMP__SeqOfCMP_CertResponse ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP__SeqOfCMP_CertResponse (pctxt, this);
   }
}

int ASN1C_CMP__SeqOfCMP_CertResponse::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP__SeqOfCMP_CertResponse (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP__SeqOfCMP_CertResponse::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP__SeqOfCMP_CertResponse;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP__SeqOfCMP_CertResponse (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP__SeqOfCMP_CertResponse (
   ASN1T_CMP__SeqOfCMP_CertResponse* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP__SeqOfCMP_CertResponse;
   rtxDListFastInit (pvalue);
}

void asn1Free_CMP__SeqOfCMP_CertResponse (OSCTXT *pctxt, 
   ASN1T_CMP__SeqOfCMP_CertResponse* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_CMP_CertResponse* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_CMP_CertResponse*)pnode->data;
      asn1Free_CMP_CertResponse (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CMP__SeqOfCMP_CertResponse::MemFree ()
{
   asn1Free_CMP__SeqOfCMP_CertResponse (getCtxtPtr(), &msgData);
}

ASN1T_CMP_CertRepMessage* new_ASN1T_CMP_CertRepMessage (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_CertRepMessage));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_CertRepMessage;
}

ASN1C_CMP_CertRepMessage::ASN1C_CMP_CertRepMessage
    (ASN1T_CMP_CertRepMessage& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_CertRepMessage::ASN1C_CMP_CertRepMessage (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_CertRepMessage& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_CertRepMessage::ASN1C_CMP_CertRepMessage (OSRTContext &context
   , ASN1T_CMP_CertRepMessage& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMP_CertRepMessage::ASN1T_CMP_CertRepMessage ()
{
   m.caPubsPresent = 0;
}

ASN1T_CMP_CertRepMessage::~ASN1T_CMP_CertRepMessage ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_CertRepMessage (pctxt, this);
   }
}

int ASN1C_CMP_CertRepMessage::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_CertRepMessage (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_CertRepMessage::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_CertRepMessage;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_CertRepMessage (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_CertRepMessage (ASN1T_CMP_CertRepMessage* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_CertRepMessage;
}

void asn1Free_CMP_CertRepMessage (OSCTXT *pctxt, 
   ASN1T_CMP_CertRepMessage* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.caPubsPresent) {
      asn1Free_CMP_CertRepMessage_caPubs (pctxt, &pvalue->caPubs);
   }
   asn1Free_CMP__SeqOfCMP_CertResponse (pctxt, &pvalue->response);
}

void ASN1C_CMP_CertRepMessage::MemFree ()
{
   asn1Free_CMP_CertRepMessage (getCtxtPtr(), &msgData);
}

ASN1T_CMP_Challenge* new_ASN1T_CMP_Challenge (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_Challenge));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_Challenge;
}

ASN1C_CMP_Challenge::ASN1C_CMP_Challenge (ASN1T_CMP_Challenge& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_Challenge::ASN1C_CMP_Challenge (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_Challenge& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_Challenge::ASN1C_CMP_Challenge (OSRTContext &context
   , ASN1T_CMP_Challenge& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMP_Challenge::ASN1T_CMP_Challenge ()
{
   m.owfPresent = 0;
}

ASN1T_CMP_Challenge::~ASN1T_CMP_Challenge ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_Challenge (pctxt, this);
   }
}

int ASN1C_CMP_Challenge::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_Challenge (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_Challenge::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_Challenge;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_Challenge (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_Challenge (ASN1T_CMP_Challenge* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_Challenge;
}

void asn1Free_CMP_Challenge (OSCTXT *pctxt, ASN1T_CMP_Challenge* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.owfPresent) {
      asn1Free_EXP_AlgorithmIdentifier (pctxt, &pvalue->owf);
   }
   if (pvalue->witness.numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->witness.data);
      pvalue->witness.numocts = 0;
      pvalue->witness.data = 0;
   }
   if (pvalue->challenge.numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->challenge.data);
      pvalue->challenge.numocts = 0;
      pvalue->challenge.data = 0;
   }
}

void ASN1C_CMP_Challenge::MemFree ()
{
   asn1Free_CMP_Challenge (getCtxtPtr(), &msgData);
}

ASN1C_CMP_POPODecKeyChallContent::ASN1C_CMP_POPODecKeyChallContent
    (ASN1T_CMP_POPODecKeyChallContent& data) : ASN1CSeqOfList(data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_POPODecKeyChallContent::ASN1C_CMP_POPODecKeyChallContent (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMP_POPODecKeyChallContent& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_POPODecKeyChallContent::ASN1C_CMP_POPODecKeyChallContent (
   OSRTContext &context, ASN1T_CMP_POPODecKeyChallContent& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CMP_POPODecKeyChallContent::
   ASN1C_CMP_POPODecKeyChallContent (ASN1CType& ccobj
   , ASN1T_CMP_POPODecKeyChallContent& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CMP_POPODecKeyChallContent::Append (ASN1T_CMP_Challenge* elem)
{
   append ((void*)elem);
}

ASN1T_CMP_Challenge* ASN1C_CMP_POPODecKeyChallContent::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_CMP_Challenge));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_Challenge;
}

ASN1T_CMP_Challenge* ASN1C_CMP_POPODecKeyChallContent::AppendNewElement ()
{
   ASN1T_CMP_Challenge* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CMP_POPODecKeyChallContent::~ASN1T_CMP_POPODecKeyChallContent ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_POPODecKeyChallContent (pctxt, this);
   }
}

int ASN1C_CMP_POPODecKeyChallContent::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_POPODecKeyChallContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_POPODecKeyChallContent::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_POPODecKeyChallContent;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_POPODecKeyChallContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_POPODecKeyChallContent (
   ASN1T_CMP_POPODecKeyChallContent* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_POPODecKeyChallContent;
   rtxDListFastInit (pvalue);
}

void asn1Free_CMP_POPODecKeyChallContent (OSCTXT *pctxt, 
   ASN1T_CMP_POPODecKeyChallContent* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_CMP_Challenge* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_CMP_Challenge*)pnode->data;
      asn1Free_CMP_Challenge (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CMP_POPODecKeyChallContent::MemFree ()
{
   asn1Free_CMP_POPODecKeyChallContent (getCtxtPtr(), &msgData);
}

ASN1C_CMP_POPODecKeyRespContent::ASN1C_CMP_POPODecKeyRespContent
    (ASN1T_CMP_POPODecKeyRespContent& data) : ASN1CSeqOfList(data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_POPODecKeyRespContent::ASN1C_CMP_POPODecKeyRespContent (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMP_POPODecKeyRespContent& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_POPODecKeyRespContent::ASN1C_CMP_POPODecKeyRespContent (
   OSRTContext &context, ASN1T_CMP_POPODecKeyRespContent& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CMP_POPODecKeyRespContent::
   ASN1C_CMP_POPODecKeyRespContent (ASN1CType& ccobj
   , ASN1T_CMP_POPODecKeyRespContent& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CMP_POPODecKeyRespContent::Append (OSINT32* elem)
{
   append ((void*)elem);
}

OSINT32* ASN1C_CMP_POPODecKeyRespContent::NewElement ()
{
   void* pdata = memAlloc (sizeof(OSINT32));

   if (0 == pdata) return 0;
   else return new (pdata) OSINT32;
}

OSINT32* ASN1C_CMP_POPODecKeyRespContent::AppendNewElement ()
{
   OSINT32* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CMP_POPODecKeyRespContent::~ASN1T_CMP_POPODecKeyRespContent ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_POPODecKeyRespContent (pctxt, this);
   }
}

int ASN1C_CMP_POPODecKeyRespContent::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_POPODecKeyRespContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_POPODecKeyRespContent::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_POPODecKeyRespContent;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_POPODecKeyRespContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_POPODecKeyRespContent (
   ASN1T_CMP_POPODecKeyRespContent* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_POPODecKeyRespContent;
   rtxDListFastInit (pvalue);
}

void asn1Free_CMP_POPODecKeyRespContent (OSCTXT *pctxt, 
   ASN1T_CMP_POPODecKeyRespContent* pvalue)
{
   if (0 == pvalue) return;
   { OSINT32* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (OSINT32*)pnode->data;
      OS_UNUSED_ARG(pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CMP_POPODecKeyRespContent::MemFree ()
{
   asn1Free_CMP_POPODecKeyRespContent (getCtxtPtr(), &msgData);
}

ASN1C_CMP_KeyRecRepContent_caCerts::ASN1C_CMP_KeyRecRepContent_caCerts
    (ASN1T_CMP_KeyRecRepContent_caCerts& data) : ASN1CSeqOfList(data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_KeyRecRepContent_caCerts::ASN1C_CMP_KeyRecRepContent_caCerts (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMP_KeyRecRepContent_caCerts& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_KeyRecRepContent_caCerts::ASN1C_CMP_KeyRecRepContent_caCerts (
   OSRTContext &context, ASN1T_CMP_KeyRecRepContent_caCerts& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CMP_KeyRecRepContent_caCerts::
   ASN1C_CMP_KeyRecRepContent_caCerts (ASN1CType& ccobj
   , ASN1T_CMP_KeyRecRepContent_caCerts& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CMP_KeyRecRepContent_caCerts::Append (ASN1T_CMP_CMPCertificate* elem)
{
   append ((void*)elem);
}

ASN1T_CMP_CMPCertificate* ASN1C_CMP_KeyRecRepContent_caCerts::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_CMP_CMPCertificate));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_CMPCertificate;
}

ASN1T_CMP_CMPCertificate* ASN1C_CMP_KeyRecRepContent_caCerts::AppendNewElement ()
{
   ASN1T_CMP_CMPCertificate* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CMP_KeyRecRepContent_caCerts::~ASN1T_CMP_KeyRecRepContent_caCerts ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_KeyRecRepContent_caCerts (pctxt, this);
   }
}

int ASN1C_CMP_KeyRecRepContent_caCerts::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_KeyRecRepContent_caCerts (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_KeyRecRepContent_caCerts::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_KeyRecRepContent_caCerts;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_KeyRecRepContent_caCerts (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_KeyRecRepContent_caCerts (
   ASN1T_CMP_KeyRecRepContent_caCerts* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_KeyRecRepContent_caCerts;
   rtxDListFastInit (pvalue);
}

void asn1Free_CMP_KeyRecRepContent_caCerts (OSCTXT *pctxt, 
   ASN1T_CMP_KeyRecRepContent_caCerts* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_CMP_CMPCertificate* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_CMP_CMPCertificate*)pnode->data;
      asn1Free_CMP_CMPCertificate (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CMP_KeyRecRepContent_caCerts::MemFree ()
{
   asn1Free_CMP_KeyRecRepContent_caCerts (getCtxtPtr(), &msgData);
}

ASN1C_CMP_KeyRecRepContent_keyPairHist::ASN1C_CMP_KeyRecRepContent_keyPairHist
    (ASN1T_CMP_KeyRecRepContent_keyPairHist& data) : ASN1CSeqOfList(data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_KeyRecRepContent_keyPairHist::
   ASN1C_CMP_KeyRecRepContent_keyPairHist (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_KeyRecRepContent_keyPairHist& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_KeyRecRepContent_keyPairHist::
   ASN1C_CMP_KeyRecRepContent_keyPairHist (OSRTContext &context
   , ASN1T_CMP_KeyRecRepContent_keyPairHist& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CMP_KeyRecRepContent_keyPairHist::
   ASN1C_CMP_KeyRecRepContent_keyPairHist (ASN1CType& ccobj
   , ASN1T_CMP_KeyRecRepContent_keyPairHist& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CMP_KeyRecRepContent_keyPairHist::Append (ASN1T_CMP_CertifiedKeyPair* elem)
{
   append ((void*)elem);
}

ASN1T_CMP_CertifiedKeyPair* ASN1C_CMP_KeyRecRepContent_keyPairHist::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_CMP_CertifiedKeyPair));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_CertifiedKeyPair;
}

ASN1T_CMP_CertifiedKeyPair* ASN1C_CMP_KeyRecRepContent_keyPairHist::AppendNewElement ()
{
   ASN1T_CMP_CertifiedKeyPair* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CMP_KeyRecRepContent_keyPairHist::~ASN1T_CMP_KeyRecRepContent_keyPairHist ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_KeyRecRepContent_keyPairHist (pctxt, this);
   }
}

int ASN1C_CMP_KeyRecRepContent_keyPairHist::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_KeyRecRepContent_keyPairHist (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_KeyRecRepContent_keyPairHist::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_KeyRecRepContent_keyPairHist;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_KeyRecRepContent_keyPairHist (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_KeyRecRepContent_keyPairHist (
   ASN1T_CMP_KeyRecRepContent_keyPairHist* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_KeyRecRepContent_keyPairHist;
   rtxDListFastInit (pvalue);
}

void asn1Free_CMP_KeyRecRepContent_keyPairHist (OSCTXT *pctxt, 
   ASN1T_CMP_KeyRecRepContent_keyPairHist* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_CMP_CertifiedKeyPair* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_CMP_CertifiedKeyPair*)pnode->data;
      asn1Free_CMP_CertifiedKeyPair (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CMP_KeyRecRepContent_keyPairHist::MemFree ()
{
   asn1Free_CMP_KeyRecRepContent_keyPairHist (getCtxtPtr(), &msgData);
}

ASN1T_CMP_KeyRecRepContent* new_ASN1T_CMP_KeyRecRepContent (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_KeyRecRepContent));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_KeyRecRepContent;
}

ASN1C_CMP_KeyRecRepContent::ASN1C_CMP_KeyRecRepContent
    (ASN1T_CMP_KeyRecRepContent& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_KeyRecRepContent::ASN1C_CMP_KeyRecRepContent (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMP_KeyRecRepContent& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_KeyRecRepContent::ASN1C_CMP_KeyRecRepContent (OSRTContext &context
   , ASN1T_CMP_KeyRecRepContent& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMP_KeyRecRepContent::ASN1T_CMP_KeyRecRepContent ()
{
   m.newSigCertPresent = 0;
   m.caCertsPresent = 0;
   m.keyPairHistPresent = 0;
}

ASN1T_CMP_KeyRecRepContent::~ASN1T_CMP_KeyRecRepContent ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_KeyRecRepContent (pctxt, this);
   }
}

int ASN1C_CMP_KeyRecRepContent::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_KeyRecRepContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_KeyRecRepContent::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_KeyRecRepContent;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_KeyRecRepContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_KeyRecRepContent (ASN1T_CMP_KeyRecRepContent* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_KeyRecRepContent;
}

void asn1Free_CMP_KeyRecRepContent (OSCTXT *pctxt, 
   ASN1T_CMP_KeyRecRepContent* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_CMP_PKIStatusInfo (pctxt, &pvalue->status);
   if (pvalue->m.newSigCertPresent) {
      asn1Free_CMP_CMPCertificate (pctxt, &pvalue->newSigCert);
   }
   if (pvalue->m.caCertsPresent) {
      asn1Free_CMP_KeyRecRepContent_caCerts (pctxt, &pvalue->caCerts);
   }
   if (pvalue->m.keyPairHistPresent) {
      asn1Free_CMP_KeyRecRepContent_keyPairHist (pctxt, &pvalue->keyPairHist);
   }
}

void ASN1C_CMP_KeyRecRepContent::MemFree ()
{
   asn1Free_CMP_KeyRecRepContent (getCtxtPtr(), &msgData);
}

ASN1T_CMP_RevDetails* new_ASN1T_CMP_RevDetails (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_RevDetails));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_RevDetails;
}

ASN1C_CMP_RevDetails::ASN1C_CMP_RevDetails (ASN1T_CMP_RevDetails& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_RevDetails::ASN1C_CMP_RevDetails (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_RevDetails& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_RevDetails::ASN1C_CMP_RevDetails (OSRTContext &context
   , ASN1T_CMP_RevDetails& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMP_RevDetails::ASN1T_CMP_RevDetails ()
{
   m.crlEntryDetailsPresent = 0;
}

ASN1T_CMP_RevDetails::~ASN1T_CMP_RevDetails ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_RevDetails (pctxt, this);
   }
}

int ASN1C_CMP_RevDetails::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_RevDetails (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_RevDetails::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_RevDetails;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_RevDetails (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_RevDetails (ASN1T_CMP_RevDetails* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_RevDetails;
}

void asn1Free_CMP_RevDetails (OSCTXT *pctxt, ASN1T_CMP_RevDetails* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_CRMF_CertTemplate (pctxt, &pvalue->certDetails);
   if (pvalue->m.crlEntryDetailsPresent) {
      asn1Free_EXP_Extensions (pctxt, &pvalue->crlEntryDetails);
   }
}

void ASN1C_CMP_RevDetails::MemFree ()
{
   asn1Free_CMP_RevDetails (getCtxtPtr(), &msgData);
}

ASN1C_CMP_RevReqContent::ASN1C_CMP_RevReqContent
    (ASN1T_CMP_RevReqContent& data) : ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_RevReqContent::ASN1C_CMP_RevReqContent (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_RevReqContent& data) : ASN1CSeqOfList(msgBuf, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_RevReqContent::ASN1C_CMP_RevReqContent (OSRTContext &context
   , ASN1T_CMP_RevReqContent& data) : ASN1CSeqOfList(context, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CMP_RevReqContent::ASN1C_CMP_RevReqContent (ASN1CType& ccobj
   , ASN1T_CMP_RevReqContent& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CMP_RevReqContent::Append (ASN1T_CMP_RevDetails* elem)
{
   append ((void*)elem);
}

ASN1T_CMP_RevDetails* ASN1C_CMP_RevReqContent::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_CMP_RevDetails));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_RevDetails;
}

ASN1T_CMP_RevDetails* ASN1C_CMP_RevReqContent::AppendNewElement ()
{
   ASN1T_CMP_RevDetails* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CMP_RevReqContent::~ASN1T_CMP_RevReqContent ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_RevReqContent (pctxt, this);
   }
}

int ASN1C_CMP_RevReqContent::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_RevReqContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_RevReqContent::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_RevReqContent;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_RevReqContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_RevReqContent (ASN1T_CMP_RevReqContent* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_RevReqContent;
   rtxDListFastInit (pvalue);
}

void asn1Free_CMP_RevReqContent (OSCTXT *pctxt, 
   ASN1T_CMP_RevReqContent* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_CMP_RevDetails* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_CMP_RevDetails*)pnode->data;
      asn1Free_CMP_RevDetails (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CMP_RevReqContent::MemFree ()
{
   asn1Free_CMP_RevReqContent (getCtxtPtr(), &msgData);
}

ASN1C_CMP_RevRepContent_status::ASN1C_CMP_RevRepContent_status
    (ASN1T_CMP_RevRepContent_status& data) : ASN1CSeqOfList(data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_RevRepContent_status::ASN1C_CMP_RevRepContent_status (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMP_RevRepContent_status& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_RevRepContent_status::ASN1C_CMP_RevRepContent_status (
   OSRTContext &context, ASN1T_CMP_RevRepContent_status& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CMP_RevRepContent_status::
   ASN1C_CMP_RevRepContent_status (ASN1CType& ccobj
   , ASN1T_CMP_RevRepContent_status& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CMP_RevRepContent_status::Append (ASN1T_CMP_PKIStatusInfo* elem)
{
   append ((void*)elem);
}

ASN1T_CMP_PKIStatusInfo* ASN1C_CMP_RevRepContent_status::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_CMP_PKIStatusInfo));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_PKIStatusInfo;
}

ASN1T_CMP_PKIStatusInfo* ASN1C_CMP_RevRepContent_status::AppendNewElement ()
{
   ASN1T_CMP_PKIStatusInfo* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CMP_RevRepContent_status::~ASN1T_CMP_RevRepContent_status ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_RevRepContent_status (pctxt, this);
   }
}

int ASN1C_CMP_RevRepContent_status::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_RevRepContent_status (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_RevRepContent_status::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_RevRepContent_status;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_RevRepContent_status (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_RevRepContent_status (ASN1T_CMP_RevRepContent_status* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_RevRepContent_status;
   rtxDListFastInit (pvalue);
}

void asn1Free_CMP_RevRepContent_status (OSCTXT *pctxt, 
   ASN1T_CMP_RevRepContent_status* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_CMP_PKIStatusInfo* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_CMP_PKIStatusInfo*)pnode->data;
      asn1Free_CMP_PKIStatusInfo (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CMP_RevRepContent_status::MemFree ()
{
   asn1Free_CMP_RevRepContent_status (getCtxtPtr(), &msgData);
}

ASN1C_CMP_RevRepContent_revCerts::ASN1C_CMP_RevRepContent_revCerts
    (ASN1T_CMP_RevRepContent_revCerts& data) : ASN1CSeqOfList(data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_RevRepContent_revCerts::ASN1C_CMP_RevRepContent_revCerts (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMP_RevRepContent_revCerts& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_RevRepContent_revCerts::ASN1C_CMP_RevRepContent_revCerts (
   OSRTContext &context, ASN1T_CMP_RevRepContent_revCerts& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CMP_RevRepContent_revCerts::
   ASN1C_CMP_RevRepContent_revCerts (ASN1CType& ccobj
   , ASN1T_CMP_RevRepContent_revCerts& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CMP_RevRepContent_revCerts::Append (ASN1T_CRMF_CertId* elem)
{
   append ((void*)elem);
}

ASN1T_CRMF_CertId* ASN1C_CMP_RevRepContent_revCerts::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_CRMF_CertId));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CRMF_CertId;
}

ASN1T_CRMF_CertId* ASN1C_CMP_RevRepContent_revCerts::AppendNewElement ()
{
   ASN1T_CRMF_CertId* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CMP_RevRepContent_revCerts::~ASN1T_CMP_RevRepContent_revCerts ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_RevRepContent_revCerts (pctxt, this);
   }
}

int ASN1C_CMP_RevRepContent_revCerts::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_RevRepContent_revCerts (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_RevRepContent_revCerts::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_RevRepContent_revCerts;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_RevRepContent_revCerts (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_RevRepContent_revCerts (
   ASN1T_CMP_RevRepContent_revCerts* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_RevRepContent_revCerts;
   rtxDListFastInit (pvalue);
}

void asn1Free_CMP_RevRepContent_revCerts (OSCTXT *pctxt, 
   ASN1T_CMP_RevRepContent_revCerts* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_CRMF_CertId* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_CRMF_CertId*)pnode->data;
      asn1Free_CRMF_CertId (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CMP_RevRepContent_revCerts::MemFree ()
{
   asn1Free_CMP_RevRepContent_revCerts (getCtxtPtr(), &msgData);
}

ASN1C_CMP_RevRepContent_crls::ASN1C_CMP_RevRepContent_crls
    (ASN1T_CMP_RevRepContent_crls& data) : ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_RevRepContent_crls::ASN1C_CMP_RevRepContent_crls (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMP_RevRepContent_crls& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_RevRepContent_crls::ASN1C_CMP_RevRepContent_crls (
   OSRTContext &context, ASN1T_CMP_RevRepContent_crls& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CMP_RevRepContent_crls::ASN1C_CMP_RevRepContent_crls (ASN1CType& ccobj
   , ASN1T_CMP_RevRepContent_crls& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CMP_RevRepContent_crls::Append (ASN1T_EXP_CertificateList* elem)
{
   append ((void*)elem);
}

ASN1T_EXP_CertificateList* ASN1C_CMP_RevRepContent_crls::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_EXP_CertificateList));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_EXP_CertificateList;
}

ASN1T_EXP_CertificateList* ASN1C_CMP_RevRepContent_crls::AppendNewElement ()
{
   ASN1T_EXP_CertificateList* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CMP_RevRepContent_crls::~ASN1T_CMP_RevRepContent_crls ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_RevRepContent_crls (pctxt, this);
   }
}

int ASN1C_CMP_RevRepContent_crls::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_RevRepContent_crls (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_RevRepContent_crls::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_RevRepContent_crls;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_RevRepContent_crls (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_RevRepContent_crls (ASN1T_CMP_RevRepContent_crls* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_RevRepContent_crls;
   rtxDListFastInit (pvalue);
}

void asn1Free_CMP_RevRepContent_crls (OSCTXT *pctxt, 
   ASN1T_CMP_RevRepContent_crls* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_EXP_CertificateList* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_EXP_CertificateList*)pnode->data;
      asn1Free_EXP_CertificateList (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CMP_RevRepContent_crls::MemFree ()
{
   asn1Free_CMP_RevRepContent_crls (getCtxtPtr(), &msgData);
}

ASN1T_CMP_RevRepContent* new_ASN1T_CMP_RevRepContent (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_RevRepContent));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_RevRepContent;
}

ASN1C_CMP_RevRepContent::ASN1C_CMP_RevRepContent
    (ASN1T_CMP_RevRepContent& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_RevRepContent::ASN1C_CMP_RevRepContent (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_RevRepContent& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_RevRepContent::ASN1C_CMP_RevRepContent (OSRTContext &context
   , ASN1T_CMP_RevRepContent& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMP_RevRepContent::ASN1T_CMP_RevRepContent ()
{
   m.revCertsPresent = 0;
   m.crlsPresent = 0;
}

ASN1T_CMP_RevRepContent::~ASN1T_CMP_RevRepContent ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_RevRepContent (pctxt, this);
   }
}

int ASN1C_CMP_RevRepContent::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_RevRepContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_RevRepContent::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_RevRepContent;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_RevRepContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_RevRepContent (ASN1T_CMP_RevRepContent* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_RevRepContent;
}

void asn1Free_CMP_RevRepContent (OSCTXT *pctxt, 
   ASN1T_CMP_RevRepContent* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_CMP_RevRepContent_status (pctxt, &pvalue->status);
   if (pvalue->m.revCertsPresent) {
      asn1Free_CMP_RevRepContent_revCerts (pctxt, &pvalue->revCerts);
   }
   if (pvalue->m.crlsPresent) {
      asn1Free_CMP_RevRepContent_crls (pctxt, &pvalue->crls);
   }
}

void ASN1C_CMP_RevRepContent::MemFree ()
{
   asn1Free_CMP_RevRepContent (getCtxtPtr(), &msgData);
}

ASN1T_CMP_CAKeyUpdAnnContent* 
   new_ASN1T_CMP_CAKeyUpdAnnContent (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_CAKeyUpdAnnContent));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_CAKeyUpdAnnContent;
}

ASN1C_CMP_CAKeyUpdAnnContent::ASN1C_CMP_CAKeyUpdAnnContent
    (ASN1T_CMP_CAKeyUpdAnnContent& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_CAKeyUpdAnnContent::ASN1C_CMP_CAKeyUpdAnnContent (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMP_CAKeyUpdAnnContent& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_CAKeyUpdAnnContent::ASN1C_CMP_CAKeyUpdAnnContent (
   OSRTContext &context, ASN1T_CMP_CAKeyUpdAnnContent& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMP_CAKeyUpdAnnContent::ASN1T_CMP_CAKeyUpdAnnContent ()
{
}

ASN1T_CMP_CAKeyUpdAnnContent::~ASN1T_CMP_CAKeyUpdAnnContent ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_CAKeyUpdAnnContent (pctxt, this);
   }
}

int ASN1C_CMP_CAKeyUpdAnnContent::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_CAKeyUpdAnnContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_CAKeyUpdAnnContent::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_CAKeyUpdAnnContent;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_CAKeyUpdAnnContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_CAKeyUpdAnnContent (ASN1T_CMP_CAKeyUpdAnnContent* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_CAKeyUpdAnnContent;
}

void asn1Free_CMP_CAKeyUpdAnnContent (OSCTXT *pctxt, 
   ASN1T_CMP_CAKeyUpdAnnContent* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_CMP_CMPCertificate (pctxt, &pvalue->oldWithNew);
   asn1Free_CMP_CMPCertificate (pctxt, &pvalue->newWithOld);
   asn1Free_CMP_CMPCertificate (pctxt, &pvalue->newWithNew);
}

void ASN1C_CMP_CAKeyUpdAnnContent::MemFree ()
{
   asn1Free_CMP_CAKeyUpdAnnContent (getCtxtPtr(), &msgData);
}

ASN1T_CMP_CertAnnContent* new_ASN1T_CMP_CertAnnContent (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_CertAnnContent));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_CertAnnContent;
}

ASN1C_CMP_CertAnnContent::ASN1C_CMP_CertAnnContent
    (ASN1T_CMP_CertAnnContent& data) : ASN1C_CMP_CMPCertificate (data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_CertAnnContent::ASN1C_CMP_CertAnnContent (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_CertAnnContent& data) : ASN1C_CMP_CMPCertificate (msgBuf, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_CertAnnContent::ASN1C_CMP_CertAnnContent (OSRTContext &context
   , ASN1T_CMP_CertAnnContent& data) : ASN1C_CMP_CMPCertificate (context, data)
   
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_CMP_CertAnnContent::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_CertAnnContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_CertAnnContent::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_CertAnnContent;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_CertAnnContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_CertAnnContent (ASN1T_CMP_CertAnnContent* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_CertAnnContent;
}

void asn1Free_CMP_CertAnnContent (OSCTXT *pctxt, 
   ASN1T_CMP_CertAnnContent* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_CMP_CMPCertificate (pctxt, pvalue);
}

void ASN1C_CMP_CertAnnContent::MemFree ()
{
   asn1Free_CMP_CertAnnContent (getCtxtPtr(), &msgData);
}

ASN1T_CMP_RevAnnContent* new_ASN1T_CMP_RevAnnContent (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_RevAnnContent));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_RevAnnContent;
}

ASN1C_CMP_RevAnnContent::ASN1C_CMP_RevAnnContent
    (ASN1T_CMP_RevAnnContent& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_RevAnnContent::ASN1C_CMP_RevAnnContent (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_RevAnnContent& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_RevAnnContent::ASN1C_CMP_RevAnnContent (OSRTContext &context
   , ASN1T_CMP_RevAnnContent& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMP_RevAnnContent::ASN1T_CMP_RevAnnContent ()
{
   willBeRevokedAt = 0;
   badSinceDate = 0;
   m.crlDetailsPresent = 0;
}

ASN1T_CMP_RevAnnContent::~ASN1T_CMP_RevAnnContent ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_RevAnnContent (pctxt, this);
   }
}

int ASN1C_CMP_RevAnnContent::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_RevAnnContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_RevAnnContent::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_RevAnnContent;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_RevAnnContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_RevAnnContent (ASN1T_CMP_RevAnnContent* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_RevAnnContent;
}

void asn1Free_CMP_RevAnnContent (OSCTXT *pctxt, 
   ASN1T_CMP_RevAnnContent* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_CRMF_CertId (pctxt, &pvalue->certId);
   rtxMemFreePtr (pctxt, (void*)pvalue->willBeRevokedAt);
   rtxMemFreePtr (pctxt, (void*)pvalue->badSinceDate);
   if (pvalue->m.crlDetailsPresent) {
      asn1Free_EXP_Extensions (pctxt, &pvalue->crlDetails);
   }
}

void ASN1C_CMP_RevAnnContent::MemFree ()
{
   asn1Free_CMP_RevAnnContent (getCtxtPtr(), &msgData);
}

ASN1C_CMP_CRLAnnContent::ASN1C_CMP_CRLAnnContent
    (ASN1T_CMP_CRLAnnContent& data) : ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_CRLAnnContent::ASN1C_CMP_CRLAnnContent (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_CRLAnnContent& data) : ASN1CSeqOfList(msgBuf, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_CRLAnnContent::ASN1C_CMP_CRLAnnContent (OSRTContext &context
   , ASN1T_CMP_CRLAnnContent& data) : ASN1CSeqOfList(context, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CMP_CRLAnnContent::ASN1C_CMP_CRLAnnContent (ASN1CType& ccobj
   , ASN1T_CMP_CRLAnnContent& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CMP_CRLAnnContent::Append (ASN1T_EXP_CertificateList* elem)
{
   append ((void*)elem);
}

ASN1T_EXP_CertificateList* ASN1C_CMP_CRLAnnContent::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_EXP_CertificateList));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_EXP_CertificateList;
}

ASN1T_EXP_CertificateList* ASN1C_CMP_CRLAnnContent::AppendNewElement ()
{
   ASN1T_EXP_CertificateList* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CMP_CRLAnnContent::~ASN1T_CMP_CRLAnnContent ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_CRLAnnContent (pctxt, this);
   }
}

int ASN1C_CMP_CRLAnnContent::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_CRLAnnContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_CRLAnnContent::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_CRLAnnContent;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_CRLAnnContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_CRLAnnContent (ASN1T_CMP_CRLAnnContent* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_CRLAnnContent;
   rtxDListFastInit (pvalue);
}

void asn1Free_CMP_CRLAnnContent (OSCTXT *pctxt, 
   ASN1T_CMP_CRLAnnContent* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_EXP_CertificateList* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_EXP_CertificateList*)pnode->data;
      asn1Free_EXP_CertificateList (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CMP_CRLAnnContent::MemFree ()
{
   asn1Free_CMP_CRLAnnContent (getCtxtPtr(), &msgData);
}

ASN1C_CMP_PKIConfirmContent::ASN1C_CMP_PKIConfirmContent () : ASN1CType()
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_PKIConfirmContent::ASN1C_CMP_PKIConfirmContent (
   OSRTMessageBufferIF& msgBuf) : ASN1CType (msgBuf)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_PKIConfirmContent::ASN1C_CMP_PKIConfirmContent (OSRTContext &context)
    : ASN1CType (context)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_CMP_PKIConfirmContent::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_PKIConfirmContent (msgBuf.getCtxtPtr(), ASN1EXPL);
}

int ASN1C_CMP_PKIConfirmContent::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_CMP_PKIConfirmContent (msgBuf.getCtxtPtr(), ASN1EXPL, 0);
}

ASN1C_CMP_GenMsgContent::ASN1C_CMP_GenMsgContent
    (ASN1T_CMP_GenMsgContent& data) : ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_GenMsgContent::ASN1C_CMP_GenMsgContent (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_GenMsgContent& data) : ASN1CSeqOfList(msgBuf, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_GenMsgContent::ASN1C_CMP_GenMsgContent (OSRTContext &context
   , ASN1T_CMP_GenMsgContent& data) : ASN1CSeqOfList(context, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CMP_GenMsgContent::ASN1C_CMP_GenMsgContent (ASN1CType& ccobj
   , ASN1T_CMP_GenMsgContent& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CMP_GenMsgContent::Append (ASN1T_CMP_InfoTypeAndValue* elem)
{
   append ((void*)elem);
}

ASN1T_CMP_InfoTypeAndValue* ASN1C_CMP_GenMsgContent::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_CMP_InfoTypeAndValue));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_InfoTypeAndValue;
}

ASN1T_CMP_InfoTypeAndValue* ASN1C_CMP_GenMsgContent::AppendNewElement ()
{
   ASN1T_CMP_InfoTypeAndValue* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CMP_GenMsgContent::~ASN1T_CMP_GenMsgContent ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_GenMsgContent (pctxt, this);
   }
}

int ASN1C_CMP_GenMsgContent::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_GenMsgContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_GenMsgContent::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_GenMsgContent;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_GenMsgContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_GenMsgContent (ASN1T_CMP_GenMsgContent* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_GenMsgContent;
   rtxDListFastInit (pvalue);
}

void asn1Free_CMP_GenMsgContent (OSCTXT *pctxt, 
   ASN1T_CMP_GenMsgContent* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_CMP_InfoTypeAndValue* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_CMP_InfoTypeAndValue*)pnode->data;
      asn1Free_CMP_InfoTypeAndValue (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CMP_GenMsgContent::MemFree ()
{
   asn1Free_CMP_GenMsgContent (getCtxtPtr(), &msgData);
}

ASN1C_CMP_GenRepContent::ASN1C_CMP_GenRepContent
    (ASN1T_CMP_GenRepContent& data) : ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_GenRepContent::ASN1C_CMP_GenRepContent (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_GenRepContent& data) : ASN1CSeqOfList(msgBuf, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_GenRepContent::ASN1C_CMP_GenRepContent (OSRTContext &context
   , ASN1T_CMP_GenRepContent& data) : ASN1CSeqOfList(context, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CMP_GenRepContent::ASN1C_CMP_GenRepContent (ASN1CType& ccobj
   , ASN1T_CMP_GenRepContent& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CMP_GenRepContent::Append (ASN1T_CMP_InfoTypeAndValue* elem)
{
   append ((void*)elem);
}

ASN1T_CMP_InfoTypeAndValue* ASN1C_CMP_GenRepContent::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_CMP_InfoTypeAndValue));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_InfoTypeAndValue;
}

ASN1T_CMP_InfoTypeAndValue* ASN1C_CMP_GenRepContent::AppendNewElement ()
{
   ASN1T_CMP_InfoTypeAndValue* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CMP_GenRepContent::~ASN1T_CMP_GenRepContent ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_GenRepContent (pctxt, this);
   }
}

int ASN1C_CMP_GenRepContent::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_GenRepContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_GenRepContent::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_GenRepContent;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_GenRepContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_GenRepContent (ASN1T_CMP_GenRepContent* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_GenRepContent;
   rtxDListFastInit (pvalue);
}

void asn1Free_CMP_GenRepContent (OSCTXT *pctxt, 
   ASN1T_CMP_GenRepContent* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_CMP_InfoTypeAndValue* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_CMP_InfoTypeAndValue*)pnode->data;
      asn1Free_CMP_InfoTypeAndValue (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CMP_GenRepContent::MemFree ()
{
   asn1Free_CMP_GenRepContent (getCtxtPtr(), &msgData);
}

ASN1T_CMP_ErrorMsgContent* new_ASN1T_CMP_ErrorMsgContent (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_ErrorMsgContent));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_ErrorMsgContent;
}

ASN1C_CMP_ErrorMsgContent::ASN1C_CMP_ErrorMsgContent
    (ASN1T_CMP_ErrorMsgContent& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_ErrorMsgContent::ASN1C_CMP_ErrorMsgContent (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMP_ErrorMsgContent& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_ErrorMsgContent::ASN1C_CMP_ErrorMsgContent (OSRTContext &context
   , ASN1T_CMP_ErrorMsgContent& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMP_ErrorMsgContent::ASN1T_CMP_ErrorMsgContent ()
{
   m.errorCodePresent = 0;
   m.errorDetailsPresent = 0;
}

ASN1T_CMP_ErrorMsgContent::~ASN1T_CMP_ErrorMsgContent ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_ErrorMsgContent (pctxt, this);
   }
}

int ASN1C_CMP_ErrorMsgContent::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_ErrorMsgContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_ErrorMsgContent::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_ErrorMsgContent;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_ErrorMsgContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_ErrorMsgContent (ASN1T_CMP_ErrorMsgContent* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_ErrorMsgContent;
}

void asn1Free_CMP_ErrorMsgContent (OSCTXT *pctxt, 
   ASN1T_CMP_ErrorMsgContent* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_CMP_PKIStatusInfo (pctxt, &pvalue->pKIStatusInfo);
   if (pvalue->m.errorDetailsPresent) {
      asn1Free_CMP_PKIFreeText (pctxt, &pvalue->errorDetails);
   }
}

void ASN1C_CMP_ErrorMsgContent::MemFree ()
{
   asn1Free_CMP_ErrorMsgContent (getCtxtPtr(), &msgData);
}

ASN1T_CMP_CertStatus* new_ASN1T_CMP_CertStatus (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_CertStatus));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_CertStatus;
}

ASN1C_CMP_CertStatus::ASN1C_CMP_CertStatus (ASN1T_CMP_CertStatus& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_CertStatus::ASN1C_CMP_CertStatus (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_CertStatus& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_CertStatus::ASN1C_CMP_CertStatus (OSRTContext &context
   , ASN1T_CMP_CertStatus& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMP_CertStatus::ASN1T_CMP_CertStatus ()
{
   m.statusInfoPresent = 0;
}

ASN1T_CMP_CertStatus::~ASN1T_CMP_CertStatus ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_CertStatus (pctxt, this);
   }
}

int ASN1C_CMP_CertStatus::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_CertStatus (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_CertStatus::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_CertStatus;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_CertStatus (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_CertStatus (ASN1T_CMP_CertStatus* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_CertStatus;
}

void asn1Free_CMP_CertStatus (OSCTXT *pctxt, ASN1T_CMP_CertStatus* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->certHash.numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->certHash.data);
      pvalue->certHash.numocts = 0;
      pvalue->certHash.data = 0;
   }
   if (pvalue->m.statusInfoPresent) {
      asn1Free_CMP_PKIStatusInfo (pctxt, &pvalue->statusInfo);
   }
}

void ASN1C_CMP_CertStatus::MemFree ()
{
   asn1Free_CMP_CertStatus (getCtxtPtr(), &msgData);
}

ASN1C_CMP_CertConfirmContent::ASN1C_CMP_CertConfirmContent
    (ASN1T_CMP_CertConfirmContent& data) : ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_CertConfirmContent::ASN1C_CMP_CertConfirmContent (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMP_CertConfirmContent& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_CertConfirmContent::ASN1C_CMP_CertConfirmContent (
   OSRTContext &context, ASN1T_CMP_CertConfirmContent& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CMP_CertConfirmContent::ASN1C_CMP_CertConfirmContent (ASN1CType& ccobj
   , ASN1T_CMP_CertConfirmContent& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CMP_CertConfirmContent::Append (ASN1T_CMP_CertStatus* elem)
{
   append ((void*)elem);
}

ASN1T_CMP_CertStatus* ASN1C_CMP_CertConfirmContent::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_CMP_CertStatus));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_CertStatus;
}

ASN1T_CMP_CertStatus* ASN1C_CMP_CertConfirmContent::AppendNewElement ()
{
   ASN1T_CMP_CertStatus* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CMP_CertConfirmContent::~ASN1T_CMP_CertConfirmContent ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_CertConfirmContent (pctxt, this);
   }
}

int ASN1C_CMP_CertConfirmContent::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_CertConfirmContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_CertConfirmContent::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_CertConfirmContent;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_CertConfirmContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_CertConfirmContent (ASN1T_CMP_CertConfirmContent* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_CertConfirmContent;
   rtxDListFastInit (pvalue);
}

void asn1Free_CMP_CertConfirmContent (OSCTXT *pctxt, 
   ASN1T_CMP_CertConfirmContent* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_CMP_CertStatus* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_CMP_CertStatus*)pnode->data;
      asn1Free_CMP_CertStatus (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CMP_CertConfirmContent::MemFree ()
{
   asn1Free_CMP_CertConfirmContent (getCtxtPtr(), &msgData);
}

ASN1T_CMP_PollReqContent_element* 
   new_ASN1T_CMP_PollReqContent_element (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_PollReqContent_element));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_PollReqContent_element;
}

ASN1C_CMP_PollReqContent_element::ASN1C_CMP_PollReqContent_element
    (ASN1T_CMP_PollReqContent_element& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_PollReqContent_element::ASN1C_CMP_PollReqContent_element (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMP_PollReqContent_element& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_PollReqContent_element::ASN1C_CMP_PollReqContent_element (
   OSRTContext &context, ASN1T_CMP_PollReqContent_element& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMP_PollReqContent_element::ASN1T_CMP_PollReqContent_element ()
{
}

int ASN1C_CMP_PollReqContent_element::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_PollReqContent_element (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_PollReqContent_element::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_PollReqContent_element (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

ASN1C_CMP_PollReqContent::ASN1C_CMP_PollReqContent
    (ASN1T_CMP_PollReqContent& data) : ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_PollReqContent::ASN1C_CMP_PollReqContent (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_PollReqContent& data) : ASN1CSeqOfList(msgBuf, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_PollReqContent::ASN1C_CMP_PollReqContent (OSRTContext &context
   , ASN1T_CMP_PollReqContent& data) : ASN1CSeqOfList(context, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CMP_PollReqContent::ASN1C_CMP_PollReqContent (ASN1CType& ccobj
   , ASN1T_CMP_PollReqContent& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CMP_PollReqContent::Append (ASN1T_CMP_PollReqContent_element* elem)
{
   append ((void*)elem);
}

ASN1T_CMP_PollReqContent_element* ASN1C_CMP_PollReqContent::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_CMP_PollReqContent_element));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_PollReqContent_element;
}

ASN1T_CMP_PollReqContent_element* ASN1C_CMP_PollReqContent::AppendNewElement ()
{
   ASN1T_CMP_PollReqContent_element* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CMP_PollReqContent::~ASN1T_CMP_PollReqContent ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_PollReqContent (pctxt, this);
   }
}

int ASN1C_CMP_PollReqContent::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_PollReqContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_PollReqContent::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_PollReqContent;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_PollReqContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_PollReqContent (ASN1T_CMP_PollReqContent* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_PollReqContent;
   rtxDListFastInit (pvalue);
}

void asn1Free_CMP_PollReqContent (OSCTXT *pctxt, 
   ASN1T_CMP_PollReqContent* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void ASN1C_CMP_PollReqContent::MemFree ()
{
   asn1Free_CMP_PollReqContent (getCtxtPtr(), &msgData);
}

ASN1T_CMP_PollRepContent_element* 
   new_ASN1T_CMP_PollRepContent_element (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_PollRepContent_element));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_PollRepContent_element;
}

ASN1C_CMP_PollRepContent_element::ASN1C_CMP_PollRepContent_element
    (ASN1T_CMP_PollRepContent_element& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_PollRepContent_element::ASN1C_CMP_PollRepContent_element (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMP_PollRepContent_element& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_PollRepContent_element::ASN1C_CMP_PollRepContent_element (
   OSRTContext &context, ASN1T_CMP_PollRepContent_element& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMP_PollRepContent_element::ASN1T_CMP_PollRepContent_element ()
{
   m.reasonPresent = 0;
}

ASN1T_CMP_PollRepContent_element::~ASN1T_CMP_PollRepContent_element ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_PollRepContent_element (pctxt, this);
   }
}

int ASN1C_CMP_PollRepContent_element::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_PollRepContent_element (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_PollRepContent_element::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_PollRepContent_element;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_PollRepContent_element (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_PollRepContent_element (
   ASN1T_CMP_PollRepContent_element* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_PollRepContent_element;
}

void asn1Free_CMP_PollRepContent_element (OSCTXT *pctxt, 
   ASN1T_CMP_PollRepContent_element* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.reasonPresent) {
      asn1Free_CMP_PKIFreeText (pctxt, &pvalue->reason);
   }
}

void ASN1C_CMP_PollRepContent_element::MemFree ()
{
   asn1Free_CMP_PollRepContent_element (getCtxtPtr(), &msgData);
}

ASN1C_CMP_PollRepContent::ASN1C_CMP_PollRepContent
    (ASN1T_CMP_PollRepContent& data) : ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_PollRepContent::ASN1C_CMP_PollRepContent (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_PollRepContent& data) : ASN1CSeqOfList(msgBuf, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_PollRepContent::ASN1C_CMP_PollRepContent (OSRTContext &context
   , ASN1T_CMP_PollRepContent& data) : ASN1CSeqOfList(context, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CMP_PollRepContent::ASN1C_CMP_PollRepContent (ASN1CType& ccobj
   , ASN1T_CMP_PollRepContent& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CMP_PollRepContent::Append (ASN1T_CMP_PollRepContent_element* elem)
{
   append ((void*)elem);
}

ASN1T_CMP_PollRepContent_element* ASN1C_CMP_PollRepContent::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_CMP_PollRepContent_element));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_PollRepContent_element;
}

ASN1T_CMP_PollRepContent_element* ASN1C_CMP_PollRepContent::AppendNewElement ()
{
   ASN1T_CMP_PollRepContent_element* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CMP_PollRepContent::~ASN1T_CMP_PollRepContent ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_PollRepContent (pctxt, this);
   }
}

int ASN1C_CMP_PollRepContent::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_PollRepContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_PollRepContent::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_PollRepContent;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_PollRepContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_PollRepContent (ASN1T_CMP_PollRepContent* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_PollRepContent;
   rtxDListFastInit (pvalue);
}

void asn1Free_CMP_PollRepContent (OSCTXT *pctxt, 
   ASN1T_CMP_PollRepContent* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_CMP_PollRepContent_element* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_CMP_PollRepContent_element*)pnode->data;
      asn1Free_CMP_PollRepContent_element (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CMP_PollRepContent::MemFree ()
{
   asn1Free_CMP_PollRepContent (getCtxtPtr(), &msgData);
}

ASN1T_CMP_PKIBody* new_ASN1T_CMP_PKIBody (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_PKIBody));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_PKIBody;
}

ASN1C_CMP_PKIBody::ASN1C_CMP_PKIBody (ASN1T_CMP_PKIBody& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_PKIBody::ASN1C_CMP_PKIBody (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_PKIBody& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_PKIBody::ASN1C_CMP_PKIBody (OSRTContext &context
   , ASN1T_CMP_PKIBody& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMP_PKIBody::~ASN1T_CMP_PKIBody ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_PKIBody (pctxt, this);
   }
}

int ASN1C_CMP_PKIBody::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_PKIBody (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_PKIBody::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_PKIBody;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_PKIBody (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_PKIBody (ASN1T_CMP_PKIBody* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_PKIBody;
}

void asn1Free_CMP_PKIBody (OSCTXT *pctxt, ASN1T_CMP_PKIBody* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.ir) {
            asn1Free_CRMF_CertReqMessages (pctxt, pvalue->u.ir);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ir);
         }
         break;

      case 2:
         if (0 != pvalue->u.ip) {
            asn1Free_CMP_CertRepMessage (pctxt, pvalue->u.ip);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ip);
         }
         break;

      case 3:
         if (0 != pvalue->u.cr) {
            asn1Free_CRMF_CertReqMessages (pctxt, pvalue->u.cr);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.cr);
         }
         break;

      case 4:
         if (0 != pvalue->u.cp) {
            asn1Free_CMP_CertRepMessage (pctxt, pvalue->u.cp);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.cp);
         }
         break;

      case 5:
         if (0 != pvalue->u.p10cr) {
            asn1Free_PKCS10_CertificationRequest (pctxt, pvalue->u.p10cr);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.p10cr);
         }
         break;

      case 6:
         if (0 != pvalue->u.popdecc) {
            asn1Free_CMP_POPODecKeyChallContent (pctxt, pvalue->u.popdecc);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.popdecc);
         }
         break;

      case 7:
         if (0 != pvalue->u.popdecr) {
            asn1Free_CMP_POPODecKeyRespContent (pctxt, pvalue->u.popdecr);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.popdecr);
         }
         break;

      case 8:
         if (0 != pvalue->u.kur) {
            asn1Free_CRMF_CertReqMessages (pctxt, pvalue->u.kur);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.kur);
         }
         break;

      case 9:
         if (0 != pvalue->u.kup) {
            asn1Free_CMP_CertRepMessage (pctxt, pvalue->u.kup);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.kup);
         }
         break;

      case 10:
         if (0 != pvalue->u.krr) {
            asn1Free_CRMF_CertReqMessages (pctxt, pvalue->u.krr);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.krr);
         }
         break;

      case 11:
         if (0 != pvalue->u.krp) {
            asn1Free_CMP_KeyRecRepContent (pctxt, pvalue->u.krp);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.krp);
         }
         break;

      case 12:
         if (0 != pvalue->u.rr) {
            asn1Free_CMP_RevReqContent (pctxt, pvalue->u.rr);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.rr);
         }
         break;

      case 13:
         if (0 != pvalue->u.rp) {
            asn1Free_CMP_RevRepContent (pctxt, pvalue->u.rp);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.rp);
         }
         break;

      case 14:
         if (0 != pvalue->u.ccr) {
            asn1Free_CRMF_CertReqMessages (pctxt, pvalue->u.ccr);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ccr);
         }
         break;

      case 15:
         if (0 != pvalue->u.ccp) {
            asn1Free_CMP_CertRepMessage (pctxt, pvalue->u.ccp);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ccp);
         }
         break;

      case 16:
         if (0 != pvalue->u.ckuann) {
            asn1Free_CMP_CAKeyUpdAnnContent (pctxt, pvalue->u.ckuann);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ckuann);
         }
         break;

      case 17:
         if (0 != pvalue->u.cann) {
            asn1Free_CMP_CertAnnContent (pctxt, pvalue->u.cann);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.cann);
         }
         break;

      case 18:
         if (0 != pvalue->u.rann) {
            asn1Free_CMP_RevAnnContent (pctxt, pvalue->u.rann);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.rann);
         }
         break;

      case 19:
         if (0 != pvalue->u.crlann) {
            asn1Free_CMP_CRLAnnContent (pctxt, pvalue->u.crlann);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.crlann);
         }
         break;

      case 20:
         break;

      case 21:
         if (0 != pvalue->u.nested) {
            asn1Free_CMP_NestedMessageContent (pctxt, (ASN1T_CMP_NestedMessageContent*)pvalue->u.nested);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.nested);
         }
         break;

      case 22:
         if (0 != pvalue->u.genm) {
            asn1Free_CMP_GenMsgContent (pctxt, pvalue->u.genm);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.genm);
         }
         break;

      case 23:
         if (0 != pvalue->u.genp) {
            asn1Free_CMP_GenRepContent (pctxt, pvalue->u.genp);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.genp);
         }
         break;

      case 24:
         if (0 != pvalue->u.error) {
            asn1Free_CMP_ErrorMsgContent (pctxt, pvalue->u.error);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.error);
         }
         break;

      case 25:
         if (0 != pvalue->u.certConf) {
            asn1Free_CMP_CertConfirmContent (pctxt, pvalue->u.certConf);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.certConf);
         }
         break;

      case 26:
         if (0 != pvalue->u.pollReq) {
            asn1Free_CMP_PollReqContent (pctxt, pvalue->u.pollReq);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.pollReq);
         }
         break;

      case 27:
         if (0 != pvalue->u.pollRep) {
            asn1Free_CMP_PollRepContent (pctxt, pvalue->u.pollRep);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.pollRep);
         }
         break;

      case 28:
         if (0 != pvalue->u.bcr) {
            asn1Free_CRMF_CertReqMessages (pctxt, pvalue->u.bcr);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.bcr);
         }
         break;

   }
}

void ASN1C_CMP_PKIBody::MemFree ()
{
   asn1Free_CMP_PKIBody (getCtxtPtr(), &msgData);
}

ASN1C_CMP_PKIMessage_extraCerts::ASN1C_CMP_PKIMessage_extraCerts
    (ASN1T_CMP_PKIMessage_extraCerts& data) : ASN1CSeqOfList(data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_PKIMessage_extraCerts::ASN1C_CMP_PKIMessage_extraCerts (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMP_PKIMessage_extraCerts& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_PKIMessage_extraCerts::ASN1C_CMP_PKIMessage_extraCerts (
   OSRTContext &context, ASN1T_CMP_PKIMessage_extraCerts& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CMP_PKIMessage_extraCerts::
   ASN1C_CMP_PKIMessage_extraCerts (ASN1CType& ccobj
   , ASN1T_CMP_PKIMessage_extraCerts& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CMP_PKIMessage_extraCerts::Append (ASN1T_CMP_CMPCertificate* elem)
{
   append ((void*)elem);
}

ASN1T_CMP_CMPCertificate* ASN1C_CMP_PKIMessage_extraCerts::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_CMP_CMPCertificate));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_CMPCertificate;
}

ASN1T_CMP_CMPCertificate* ASN1C_CMP_PKIMessage_extraCerts::AppendNewElement ()
{
   ASN1T_CMP_CMPCertificate* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CMP_PKIMessage_extraCerts::~ASN1T_CMP_PKIMessage_extraCerts ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_PKIMessage_extraCerts (pctxt, this);
   }
}

int ASN1C_CMP_PKIMessage_extraCerts::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_PKIMessage_extraCerts (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_PKIMessage_extraCerts::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_PKIMessage_extraCerts;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_PKIMessage_extraCerts (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_PKIMessage_extraCerts (
   ASN1T_CMP_PKIMessage_extraCerts* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_PKIMessage_extraCerts;
   rtxDListFastInit (pvalue);
}

void asn1Free_CMP_PKIMessage_extraCerts (OSCTXT *pctxt, 
   ASN1T_CMP_PKIMessage_extraCerts* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_CMP_CMPCertificate* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_CMP_CMPCertificate*)pnode->data;
      asn1Free_CMP_CMPCertificate (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CMP_PKIMessage_extraCerts::MemFree ()
{
   asn1Free_CMP_PKIMessage_extraCerts (getCtxtPtr(), &msgData);
}

ASN1T_CMP_PKIMessage* new_ASN1T_CMP_PKIMessage (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_PKIMessage));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_PKIMessage;
}

ASN1C_CMP_PKIMessage::ASN1C_CMP_PKIMessage (ASN1T_CMP_PKIMessage& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_PKIMessage::ASN1C_CMP_PKIMessage (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_PKIMessage& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_PKIMessage::ASN1C_CMP_PKIMessage (OSRTContext &context
   , ASN1T_CMP_PKIMessage& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMP_PKIMessage::ASN1T_CMP_PKIMessage ()
{
   m.protectionPresent = 0;
   m.extraCertsPresent = 0;
}

ASN1T_CMP_PKIMessage::~ASN1T_CMP_PKIMessage ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_PKIMessage (pctxt, this);
   }
}

int ASN1C_CMP_PKIMessage::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_PKIMessage (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_PKIMessage::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_PKIMessage;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_PKIMessage (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_PKIMessage (ASN1T_CMP_PKIMessage* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_PKIMessage;
}

void asn1Free_CMP_PKIMessage (OSCTXT *pctxt, ASN1T_CMP_PKIMessage* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_CMP_PKIHeader (pctxt, &pvalue->header);
   asn1Free_CMP_PKIBody (pctxt, &pvalue->body);
   if (pvalue->m.protectionPresent) {
      asn1Free_CMP_PKIProtection (pctxt, &pvalue->protection);
   }
   if (pvalue->m.extraCertsPresent) {
      asn1Free_CMP_PKIMessage_extraCerts (pctxt, &pvalue->extraCerts);
   }
}

void ASN1C_CMP_PKIMessage::MemFree ()
{
   asn1Free_CMP_PKIMessage (getCtxtPtr(), &msgData);
}

ASN1C_CMP_PKIMessages::ASN1C_CMP_PKIMessages (ASN1T_CMP_PKIMessages& data) : 
   ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_PKIMessages::ASN1C_CMP_PKIMessages (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_PKIMessages& data) : ASN1CSeqOfList(msgBuf, data), msgData(data)
   
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_PKIMessages::ASN1C_CMP_PKIMessages (OSRTContext &context
   , ASN1T_CMP_PKIMessages& data) : ASN1CSeqOfList(context, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_CMP_PKIMessages::ASN1C_CMP_PKIMessages (ASN1CType& ccobj
   , ASN1T_CMP_PKIMessages& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_CMP_PKIMessages::Append (ASN1T_CMP_PKIMessage* elem)
{
   append ((void*)elem);
}

ASN1T_CMP_PKIMessage* ASN1C_CMP_PKIMessages::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_CMP_PKIMessage));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_PKIMessage;
}

ASN1T_CMP_PKIMessage* ASN1C_CMP_PKIMessages::AppendNewElement ()
{
   ASN1T_CMP_PKIMessage* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_CMP_PKIMessages::~ASN1T_CMP_PKIMessages ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_PKIMessages (pctxt, this);
   }
}

int ASN1C_CMP_PKIMessages::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_PKIMessages (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_PKIMessages::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_PKIMessages;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_PKIMessages (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_PKIMessages (ASN1T_CMP_PKIMessages* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_PKIMessages;
   rtxDListFastInit (pvalue);
}

void asn1Free_CMP_PKIMessages (OSCTXT *pctxt, ASN1T_CMP_PKIMessages* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_CMP_PKIMessage* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_CMP_PKIMessage*)pnode->data;
      asn1Free_CMP_PKIMessage (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_CMP_PKIMessages::MemFree ()
{
   asn1Free_CMP_PKIMessages (getCtxtPtr(), &msgData);
}

ASN1T_CMP_NestedMessageContent* 
   new_ASN1T_CMP_NestedMessageContent (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_NestedMessageContent));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_NestedMessageContent;
}

ASN1C_CMP_NestedMessageContent::ASN1C_CMP_NestedMessageContent
    (ASN1T_CMP_NestedMessageContent& data) : ASN1C_CMP_PKIMessages (data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_NestedMessageContent::ASN1C_CMP_NestedMessageContent (
   OSRTMessageBufferIF& msgBuf, ASN1T_CMP_NestedMessageContent& data) : 
   ASN1C_CMP_PKIMessages (msgBuf, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_NestedMessageContent::ASN1C_CMP_NestedMessageContent (
   OSRTContext &context, ASN1T_CMP_NestedMessageContent& data) : 
   ASN1C_CMP_PKIMessages (context, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_CMP_NestedMessageContent::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_NestedMessageContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_NestedMessageContent::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_NestedMessageContent;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_NestedMessageContent (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_NestedMessageContent (ASN1T_CMP_NestedMessageContent* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_NestedMessageContent;
}

void asn1Free_CMP_NestedMessageContent (OSCTXT *pctxt, 
   ASN1T_CMP_NestedMessageContent* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_CMP_PKIMessages (pctxt, pvalue);
}

void ASN1C_CMP_NestedMessageContent::MemFree ()
{
   asn1Free_CMP_NestedMessageContent (getCtxtPtr(), &msgData);
}

ASN1T_CMP_OOBCert* new_ASN1T_CMP_OOBCert (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_OOBCert));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_OOBCert;
}

ASN1C_CMP_OOBCert::ASN1C_CMP_OOBCert (ASN1T_CMP_OOBCert& data) : 
   ASN1C_CMP_CMPCertificate (data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_OOBCert::ASN1C_CMP_OOBCert (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_OOBCert& data) : ASN1C_CMP_CMPCertificate (msgBuf, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_OOBCert::ASN1C_CMP_OOBCert (OSRTContext &context
   , ASN1T_CMP_OOBCert& data) : ASN1C_CMP_CMPCertificate (context, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_CMP_OOBCert::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_OOBCert (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_OOBCert::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_OOBCert;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_OOBCert (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_OOBCert (ASN1T_CMP_OOBCert* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_OOBCert;
}

void asn1Free_CMP_OOBCert (OSCTXT *pctxt, ASN1T_CMP_OOBCert* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_CMP_CMPCertificate (pctxt, pvalue);
}

void ASN1C_CMP_OOBCert::MemFree ()
{
   asn1Free_CMP_OOBCert (getCtxtPtr(), &msgData);
}

ASN1T_CMP_ProtectedPart* new_ASN1T_CMP_ProtectedPart (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_ProtectedPart));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_ProtectedPart;
}

ASN1C_CMP_ProtectedPart::ASN1C_CMP_ProtectedPart
    (ASN1T_CMP_ProtectedPart& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_ProtectedPart::ASN1C_CMP_ProtectedPart (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_ProtectedPart& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_ProtectedPart::ASN1C_CMP_ProtectedPart (OSRTContext &context
   , ASN1T_CMP_ProtectedPart& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMP_ProtectedPart::ASN1T_CMP_ProtectedPart ()
{
}

ASN1T_CMP_ProtectedPart::~ASN1T_CMP_ProtectedPart ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_ProtectedPart (pctxt, this);
   }
}

int ASN1C_CMP_ProtectedPart::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_ProtectedPart (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_ProtectedPart::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_ProtectedPart;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_ProtectedPart (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_ProtectedPart (ASN1T_CMP_ProtectedPart* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_ProtectedPart;
}

void asn1Free_CMP_ProtectedPart (OSCTXT *pctxt, 
   ASN1T_CMP_ProtectedPart* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_CMP_PKIHeader (pctxt, &pvalue->header);
   asn1Free_CMP_PKIBody (pctxt, &pvalue->body);
}

void ASN1C_CMP_ProtectedPart::MemFree ()
{
   asn1Free_CMP_ProtectedPart (getCtxtPtr(), &msgData);
}

ASN1T_CMP_PBMParameter* new_ASN1T_CMP_PBMParameter (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_PBMParameter));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_PBMParameter;
}

ASN1C_CMP_PBMParameter::ASN1C_CMP_PBMParameter (ASN1T_CMP_PBMParameter& data)
    : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_PBMParameter::ASN1C_CMP_PBMParameter (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_PBMParameter& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_PBMParameter::ASN1C_CMP_PBMParameter (OSRTContext &context
   , ASN1T_CMP_PBMParameter& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMP_PBMParameter::ASN1T_CMP_PBMParameter ()
{
}

ASN1T_CMP_PBMParameter::~ASN1T_CMP_PBMParameter ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_PBMParameter (pctxt, this);
   }
}

int ASN1C_CMP_PBMParameter::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_PBMParameter (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_PBMParameter::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_PBMParameter;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_PBMParameter (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_PBMParameter (ASN1T_CMP_PBMParameter* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_PBMParameter;
}

void asn1Free_CMP_PBMParameter (OSCTXT *pctxt, ASN1T_CMP_PBMParameter* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->salt.numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->salt.data);
      pvalue->salt.numocts = 0;
      pvalue->salt.data = 0;
   }
   asn1Free_EXP_AlgorithmIdentifier (pctxt, &pvalue->owf);
   asn1Free_EXP_AlgorithmIdentifier (pctxt, &pvalue->mac);
}

void ASN1C_CMP_PBMParameter::MemFree ()
{
   asn1Free_CMP_PBMParameter (getCtxtPtr(), &msgData);
}

ASN1T_CMP_DHBMParameter* new_ASN1T_CMP_DHBMParameter (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_DHBMParameter));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_DHBMParameter;
}

ASN1C_CMP_DHBMParameter::ASN1C_CMP_DHBMParameter
    (ASN1T_CMP_DHBMParameter& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_DHBMParameter::ASN1C_CMP_DHBMParameter (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_DHBMParameter& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_DHBMParameter::ASN1C_CMP_DHBMParameter (OSRTContext &context
   , ASN1T_CMP_DHBMParameter& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMP_DHBMParameter::ASN1T_CMP_DHBMParameter ()
{
}

ASN1T_CMP_DHBMParameter::~ASN1T_CMP_DHBMParameter ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_DHBMParameter (pctxt, this);
   }
}

int ASN1C_CMP_DHBMParameter::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_DHBMParameter (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_DHBMParameter::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_DHBMParameter;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_DHBMParameter (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_DHBMParameter (ASN1T_CMP_DHBMParameter* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_DHBMParameter;
}

void asn1Free_CMP_DHBMParameter (OSCTXT *pctxt, 
   ASN1T_CMP_DHBMParameter* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_EXP_AlgorithmIdentifier (pctxt, &pvalue->owf);
   asn1Free_EXP_AlgorithmIdentifier (pctxt, &pvalue->mac);
}

void ASN1C_CMP_DHBMParameter::MemFree ()
{
   asn1Free_CMP_DHBMParameter (getCtxtPtr(), &msgData);
}

ASN1T_CMP_OOBCertHash* new_ASN1T_CMP_OOBCertHash (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_CMP_OOBCertHash));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_CMP_OOBCertHash;
}

ASN1C_CMP_OOBCertHash::ASN1C_CMP_OOBCertHash (ASN1T_CMP_OOBCertHash& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_CMP_OOBCertHash::ASN1C_CMP_OOBCertHash (OSRTMessageBufferIF& msgBuf
   , ASN1T_CMP_OOBCertHash& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_CMP_OOBCertHash::ASN1C_CMP_OOBCertHash (OSRTContext &context
   , ASN1T_CMP_OOBCertHash& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_CMP_OOBCertHash::ASN1T_CMP_OOBCertHash ()
{
   m.hashAlgPresent = 0;
   m.certIdPresent = 0;
}

ASN1T_CMP_OOBCertHash::~ASN1T_CMP_OOBCertHash ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_CMP_OOBCertHash (pctxt, this);
   }
}

int ASN1C_CMP_OOBCertHash::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_CMP_OOBCertHash (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_CMP_OOBCertHash::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_CMP_OOBCertHash;
   msgData.setContext (msgBuf.getContext());
   return asn1D_CMP_OOBCertHash (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_CMP_OOBCertHash (ASN1T_CMP_OOBCertHash* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_CMP_OOBCertHash;
}

void asn1Free_CMP_OOBCertHash (OSCTXT *pctxt, ASN1T_CMP_OOBCertHash* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.hashAlgPresent) {
      asn1Free_EXP_AlgorithmIdentifier (pctxt, &pvalue->hashAlg);
   }
   if (pvalue->m.certIdPresent) {
      asn1Free_CRMF_CertId (pctxt, &pvalue->certId);
   }
   if (pvalue->hashVal.numbits > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->hashVal.data);
      pvalue->hashVal.numbits = 0;
      pvalue->hashVal.data = 0;
   }
}

void ASN1C_CMP_OOBCertHash::MemFree ()
{
   asn1Free_CMP_OOBCertHash (getCtxtPtr(), &msgData);
}

