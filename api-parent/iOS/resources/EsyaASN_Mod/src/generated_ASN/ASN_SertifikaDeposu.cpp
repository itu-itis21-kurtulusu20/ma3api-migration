/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.6, Date: 28-Feb-2014.
 */
#include <new>
#include "ASN_SertifikaDeposu.h"
#include "rtxsrc/rtxCommon.h"

static const OSEnumItem ASN1T_SD_KokSertifikaTipi_ENUMTAB[] = {
   { OSUTF8("caprazSertifika"), 2, 15, 2 },
   { OSUTF8("hizmetSertifikasi"), 4, 17, 0 },
   { OSUTF8("kokSertifika"), 1, 12, 3 },
   { OSUTF8("smSertifikasi"), 3, 13, 1 }
} ;
#define ASN1T_SD_KokSertifikaTipi_ENUMTABSIZE 4

const OSUTF8CHAR* ASN1T_SD_KokSertifikaTipi_ToString (OSINT32 value)
{
   OSINT32 idx = value - 1;

   if (idx >= 0 && idx < ASN1T_SD_KokSertifikaTipi_ENUMTABSIZE) {
      return ASN1T_SD_KokSertifikaTipi_ENUMTAB
         [ASN1T_SD_KokSertifikaTipi_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ASN1T_SD_KokSertifikaTipi_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ASN1T_SD_KokSertifikaTipi* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ASN1T_SD_KokSertifikaTipi_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ASN1T_SD_KokSertifikaTipi_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ASN1T_SD_KokSertifikaTipi* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ASN1T_SD_KokSertifikaTipi_ENUMTAB, 
      ASN1T_SD_KokSertifikaTipi_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ASN1T_SD_KokSertifikaTipi)
         ASN1T_SD_KokSertifikaTipi_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

ASN1T_SD_KokSertifikaTipi* new_ASN1T_SD_KokSertifikaTipi (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_SD_KokSertifikaTipi));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_SD_KokSertifikaTipi;
}

ASN1C_SD_KokSertifikaTipi::ASN1C_SD_KokSertifikaTipi
    (ASN1T_SD_KokSertifikaTipi& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_SD_KokSertifikaTipi::ASN1C_SD_KokSertifikaTipi (
   OSRTMessageBufferIF& msgBuf, ASN1T_SD_KokSertifikaTipi& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_SD_KokSertifikaTipi::ASN1C_SD_KokSertifikaTipi (OSRTContext &context
   , ASN1T_SD_KokSertifikaTipi& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_SD_KokSertifikaTipi::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_SD_KokSertifikaTipi (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_SD_KokSertifikaTipi::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_SD_KokSertifikaTipi (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

static const OSEnumItem ASN1T_SD_KOKGuvenSeviyesi_ENUMTAB[] = {
   { OSUTF8("kanuni"), 1, 6, 0 },
   { OSUTF8("kisisel"), 3, 7, 2 },
   { OSUTF8("kurumsal"), 2, 8, 1 }
} ;
#define ASN1T_SD_KOKGuvenSeviyesi_ENUMTABSIZE 3

const OSUTF8CHAR* ASN1T_SD_KOKGuvenSeviyesi_ToString (OSINT32 value)
{
   OSINT32 idx = value - 1;

   if (idx >= 0 && idx < ASN1T_SD_KOKGuvenSeviyesi_ENUMTABSIZE) {
      return ASN1T_SD_KOKGuvenSeviyesi_ENUMTAB
         [ASN1T_SD_KOKGuvenSeviyesi_ENUMTAB[idx].transidx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ASN1T_SD_KOKGuvenSeviyesi_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ASN1T_SD_KOKGuvenSeviyesi* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ASN1T_SD_KOKGuvenSeviyesi_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ASN1T_SD_KOKGuvenSeviyesi_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ASN1T_SD_KOKGuvenSeviyesi* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, 
      ASN1T_SD_KOKGuvenSeviyesi_ENUMTAB, 
      ASN1T_SD_KOKGuvenSeviyesi_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ASN1T_SD_KOKGuvenSeviyesi)
         ASN1T_SD_KOKGuvenSeviyesi_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

ASN1T_SD_KOKGuvenSeviyesi* new_ASN1T_SD_KOKGuvenSeviyesi (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_SD_KOKGuvenSeviyesi));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_SD_KOKGuvenSeviyesi;
}

ASN1C_SD_KOKGuvenSeviyesi::ASN1C_SD_KOKGuvenSeviyesi
    (ASN1T_SD_KOKGuvenSeviyesi& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_SD_KOKGuvenSeviyesi::ASN1C_SD_KOKGuvenSeviyesi (
   OSRTMessageBufferIF& msgBuf, ASN1T_SD_KOKGuvenSeviyesi& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_SD_KOKGuvenSeviyesi::ASN1C_SD_KOKGuvenSeviyesi (OSRTContext &context
   , ASN1T_SD_KOKGuvenSeviyesi& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_SD_KOKGuvenSeviyesi::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_SD_KOKGuvenSeviyesi (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_SD_KOKGuvenSeviyesi::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_SD_KOKGuvenSeviyesi (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

ASN1T_SD_DepoASNEklenecekKokSertifika* 
   new_ASN1T_SD_DepoASNEklenecekKokSertifika (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_SD_DepoASNEklenecekKokSertifika));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_SD_DepoASNEklenecekKokSertifika;
}

ASN1C_SD_DepoASNEklenecekKokSertifika::ASN1C_SD_DepoASNEklenecekKokSertifika
    (ASN1T_SD_DepoASNEklenecekKokSertifika& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_SD_DepoASNEklenecekKokSertifika::ASN1C_SD_DepoASNEklenecekKokSertifika (
   OSRTMessageBufferIF& msgBuf, ASN1T_SD_DepoASNEklenecekKokSertifika& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_SD_DepoASNEklenecekKokSertifika::ASN1C_SD_DepoASNEklenecekKokSertifika (
   OSRTContext &context, ASN1T_SD_DepoASNEklenecekKokSertifika& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_SD_DepoASNEklenecekKokSertifika::ASN1T_SD_DepoASNEklenecekKokSertifika ()
{
}

ASN1T_SD_DepoASNEklenecekKokSertifika::~ASN1T_SD_DepoASNEklenecekKokSertifika ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_SD_DepoASNEklenecekKokSertifika (pctxt, this);
   }
}

int ASN1C_SD_DepoASNEklenecekKokSertifika::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_SD_DepoASNEklenecekKokSertifika (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_SD_DepoASNEklenecekKokSertifika::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_SD_DepoASNEklenecekKokSertifika;
   msgData.setContext (msgBuf.getContext());
   return asn1D_SD_DepoASNEklenecekKokSertifika (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_SD_DepoASNEklenecekKokSertifika (
   ASN1T_SD_DepoASNEklenecekKokSertifika* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_SD_DepoASNEklenecekKokSertifika;
}

void asn1Free_SD_DepoASNEklenecekKokSertifika (OSCTXT *pctxt, 
   ASN1T_SD_DepoASNEklenecekKokSertifika* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->kokSertifikaValue.numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->kokSertifikaValue.data);
      pvalue->kokSertifikaValue.numocts = 0;
      pvalue->kokSertifikaValue.data = 0;
   }
   if (pvalue->kokSertifikaHash.numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->kokSertifikaHash.data);
      pvalue->kokSertifikaHash.numocts = 0;
      pvalue->kokSertifikaHash.data = 0;
   }
   asn1Free_EXP_Name (pctxt, &pvalue->kokIssuerName);
   asn1Free_EXP_Name (pctxt, &pvalue->kokSubjectName);
   asn1Free_EXP_Time (pctxt, &pvalue->kokStartDate);
   asn1Free_EXP_Time (pctxt, &pvalue->kokEndDate);
   asn1Free_IMP_SubjectKeyIdentifier (pctxt, &pvalue->kokSubjectKeyIdentifier);
}

void ASN1C_SD_DepoASNEklenecekKokSertifika::MemFree ()
{
   asn1Free_SD_DepoASNEklenecekKokSertifika (getCtxtPtr(), &msgData);
}

ASN1T_SD_DepoASNSilinecekKokSertifika* 
   new_ASN1T_SD_DepoASNSilinecekKokSertifika (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_SD_DepoASNSilinecekKokSertifika));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_SD_DepoASNSilinecekKokSertifika;
}

ASN1C_SD_DepoASNSilinecekKokSertifika::ASN1C_SD_DepoASNSilinecekKokSertifika
    (ASN1T_SD_DepoASNSilinecekKokSertifika& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_SD_DepoASNSilinecekKokSertifika::ASN1C_SD_DepoASNSilinecekKokSertifika (
   OSRTMessageBufferIF& msgBuf, ASN1T_SD_DepoASNSilinecekKokSertifika& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_SD_DepoASNSilinecekKokSertifika::ASN1C_SD_DepoASNSilinecekKokSertifika (
   OSRTContext &context, ASN1T_SD_DepoASNSilinecekKokSertifika& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_SD_DepoASNSilinecekKokSertifika::ASN1T_SD_DepoASNSilinecekKokSertifika ()
{
}

ASN1T_SD_DepoASNSilinecekKokSertifika::~ASN1T_SD_DepoASNSilinecekKokSertifika ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_SD_DepoASNSilinecekKokSertifika (pctxt, this);
   }
}

int ASN1C_SD_DepoASNSilinecekKokSertifika::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_SD_DepoASNSilinecekKokSertifika (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_SD_DepoASNSilinecekKokSertifika::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_SD_DepoASNSilinecekKokSertifika;
   msgData.setContext (msgBuf.getContext());
   return asn1D_SD_DepoASNSilinecekKokSertifika (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_SD_DepoASNSilinecekKokSertifika (
   ASN1T_SD_DepoASNSilinecekKokSertifika* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_SD_DepoASNSilinecekKokSertifika;
}

void asn1Free_SD_DepoASNSilinecekKokSertifika (OSCTXT *pctxt, 
   ASN1T_SD_DepoASNSilinecekKokSertifika* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->kokSertifikaValue.numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->kokSertifikaValue.data);
      pvalue->kokSertifikaValue.numocts = 0;
      pvalue->kokSertifikaValue.data = 0;
   }
   asn1Free_EXP_Name (pctxt, &pvalue->kokIssuerName);
   asn1Free_EXP_Name (pctxt, &pvalue->kokSubjectName);
}

void ASN1C_SD_DepoASNSilinecekKokSertifika::MemFree ()
{
   asn1Free_SD_DepoASNSilinecekKokSertifika (getCtxtPtr(), &msgData);
}

ASN1T_SD_DepoASNKokSertifika* 
   new_ASN1T_SD_DepoASNKokSertifika (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_SD_DepoASNKokSertifika));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_SD_DepoASNKokSertifika;
}

ASN1C_SD_DepoASNKokSertifika::ASN1C_SD_DepoASNKokSertifika
    (ASN1T_SD_DepoASNKokSertifika& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_SD_DepoASNKokSertifika::ASN1C_SD_DepoASNKokSertifika (
   OSRTMessageBufferIF& msgBuf, ASN1T_SD_DepoASNKokSertifika& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_SD_DepoASNKokSertifika::ASN1C_SD_DepoASNKokSertifika (
   OSRTContext &context, ASN1T_SD_DepoASNKokSertifika& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_SD_DepoASNKokSertifika::~ASN1T_SD_DepoASNKokSertifika ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_SD_DepoASNKokSertifika (pctxt, this);
   }
}

int ASN1C_SD_DepoASNKokSertifika::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_SD_DepoASNKokSertifika (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_SD_DepoASNKokSertifika::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_SD_DepoASNKokSertifika;
   msgData.setContext (msgBuf.getContext());
   return asn1D_SD_DepoASNKokSertifika (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_SD_DepoASNKokSertifika (ASN1T_SD_DepoASNKokSertifika* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_SD_DepoASNKokSertifika;
}

void asn1Free_SD_DepoASNKokSertifika (OSCTXT *pctxt, 
   ASN1T_SD_DepoASNKokSertifika* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.eklenecekSertifika) {
            asn1Free_SD_DepoASNEklenecekKokSertifika (pctxt, pvalue->u.eklenecekSertifika);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.eklenecekSertifika);
         }
         break;

      case 2:
         if (0 != pvalue->u.silinecekSertifika) {
            asn1Free_SD_DepoASNSilinecekKokSertifika (pctxt, pvalue->u.silinecekSertifika);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.silinecekSertifika);
         }
         break;

   }
}

void ASN1C_SD_DepoASNKokSertifika::MemFree ()
{
   asn1Free_SD_DepoASNKokSertifika (getCtxtPtr(), &msgData);
}

ASN1C_SD_DepoASNKokSertifikalar::ASN1C_SD_DepoASNKokSertifikalar
    (ASN1T_SD_DepoASNKokSertifikalar& data) : ASN1CSeqOfList(data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_SD_DepoASNKokSertifikalar::ASN1C_SD_DepoASNKokSertifikalar (
   OSRTMessageBufferIF& msgBuf, ASN1T_SD_DepoASNKokSertifikalar& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_SD_DepoASNKokSertifikalar::ASN1C_SD_DepoASNKokSertifikalar (
   OSRTContext &context, ASN1T_SD_DepoASNKokSertifikalar& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_SD_DepoASNKokSertifikalar::
   ASN1C_SD_DepoASNKokSertifikalar (ASN1CType& ccobj
   , ASN1T_SD_DepoASNKokSertifikalar& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_SD_DepoASNKokSertifikalar::Append (ASN1T_SD_DepoASNKokSertifika* elem)
{
   append ((void*)elem);
}

ASN1T_SD_DepoASNKokSertifika* ASN1C_SD_DepoASNKokSertifikalar::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_SD_DepoASNKokSertifika));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_SD_DepoASNKokSertifika;
}

ASN1T_SD_DepoASNKokSertifika* ASN1C_SD_DepoASNKokSertifikalar::AppendNewElement ()
{
   ASN1T_SD_DepoASNKokSertifika* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_SD_DepoASNKokSertifikalar::~ASN1T_SD_DepoASNKokSertifikalar ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_SD_DepoASNKokSertifikalar (pctxt, this);
   }
}

int ASN1C_SD_DepoASNKokSertifikalar::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_SD_DepoASNKokSertifikalar (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_SD_DepoASNKokSertifikalar::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_SD_DepoASNKokSertifikalar;
   msgData.setContext (msgBuf.getContext());
   return asn1D_SD_DepoASNKokSertifikalar (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_SD_DepoASNKokSertifikalar (
   ASN1T_SD_DepoASNKokSertifikalar* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_SD_DepoASNKokSertifikalar;
   rtxDListFastInit (pvalue);
}

void asn1Free_SD_DepoASNKokSertifikalar (OSCTXT *pctxt, 
   ASN1T_SD_DepoASNKokSertifikalar* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_SD_DepoASNKokSertifika* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_SD_DepoASNKokSertifika*)pnode->data;
      asn1Free_SD_DepoASNKokSertifika (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_SD_DepoASNKokSertifikalar::MemFree ()
{
   asn1Free_SD_DepoASNKokSertifikalar (getCtxtPtr(), &msgData);
}

ASN1T_SD_DepoASNRawImza* new_ASN1T_SD_DepoASNRawImza (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_SD_DepoASNRawImza));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_SD_DepoASNRawImza;
}

ASN1C_SD_DepoASNRawImza::ASN1C_SD_DepoASNRawImza
    (ASN1T_SD_DepoASNRawImza& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_SD_DepoASNRawImza::ASN1C_SD_DepoASNRawImza (OSRTMessageBufferIF& msgBuf
   , ASN1T_SD_DepoASNRawImza& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_SD_DepoASNRawImza::ASN1C_SD_DepoASNRawImza (OSRTContext &context
   , ASN1T_SD_DepoASNRawImza& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_SD_DepoASNRawImza::ASN1T_SD_DepoASNRawImza ()
{
}

ASN1T_SD_DepoASNRawImza::~ASN1T_SD_DepoASNRawImza ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_SD_DepoASNRawImza (pctxt, this);
   }
}

int ASN1C_SD_DepoASNRawImza::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_SD_DepoASNRawImza (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_SD_DepoASNRawImza::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_SD_DepoASNRawImza;
   msgData.setContext (msgBuf.getContext());
   return asn1D_SD_DepoASNRawImza (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_SD_DepoASNRawImza (ASN1T_SD_DepoASNRawImza* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_SD_DepoASNRawImza;
}

void asn1Free_SD_DepoASNRawImza (OSCTXT *pctxt, 
   ASN1T_SD_DepoASNRawImza* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->publicKeyHash.numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->publicKeyHash.data);
      pvalue->publicKeyHash.numocts = 0;
      pvalue->publicKeyHash.data = 0;
   }
   if (pvalue->imza.numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->imza.data);
      pvalue->imza.numocts = 0;
      pvalue->imza.data = 0;
   }
}

void ASN1C_SD_DepoASNRawImza::MemFree ()
{
   asn1Free_SD_DepoASNRawImza (getCtxtPtr(), &msgData);
}

ASN1T_SD_DepoASNImza* new_ASN1T_SD_DepoASNImza (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_SD_DepoASNImza));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_SD_DepoASNImza;
}

ASN1C_SD_DepoASNImza::ASN1C_SD_DepoASNImza (ASN1T_SD_DepoASNImza& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_SD_DepoASNImza::ASN1C_SD_DepoASNImza (OSRTMessageBufferIF& msgBuf
   , ASN1T_SD_DepoASNImza& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_SD_DepoASNImza::ASN1C_SD_DepoASNImza (OSRTContext &context
   , ASN1T_SD_DepoASNImza& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_SD_DepoASNImza::ASN1T_SD_DepoASNImza ()
{
}

ASN1T_SD_DepoASNImza::~ASN1T_SD_DepoASNImza ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_SD_DepoASNImza (pctxt, this);
   }
}

int ASN1C_SD_DepoASNImza::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_SD_DepoASNImza (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_SD_DepoASNImza::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_SD_DepoASNImza;
   msgData.setContext (msgBuf.getContext());
   return asn1D_SD_DepoASNImza (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_SD_DepoASNImza (ASN1T_SD_DepoASNImza* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_SD_DepoASNImza;
}

void asn1Free_SD_DepoASNImza (OSCTXT *pctxt, ASN1T_SD_DepoASNImza* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_SD_DepoASNKokSertifika (pctxt, &pvalue->imzalanan);
   asn1Free_SD_DepoASNRawImza (pctxt, &pvalue->imza);
}

void ASN1C_SD_DepoASNImza::MemFree ()
{
   asn1Free_SD_DepoASNImza (getCtxtPtr(), &msgData);
}

ASN1C_SD_DepoASNImzalar::ASN1C_SD_DepoASNImzalar
    (ASN1T_SD_DepoASNImzalar& data) : ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_SD_DepoASNImzalar::ASN1C_SD_DepoASNImzalar (OSRTMessageBufferIF& msgBuf
   , ASN1T_SD_DepoASNImzalar& data) : ASN1CSeqOfList(msgBuf, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_SD_DepoASNImzalar::ASN1C_SD_DepoASNImzalar (OSRTContext &context
   , ASN1T_SD_DepoASNImzalar& data) : ASN1CSeqOfList(context, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_SD_DepoASNImzalar::ASN1C_SD_DepoASNImzalar (ASN1CType& ccobj
   , ASN1T_SD_DepoASNImzalar& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_SD_DepoASNImzalar::Append (ASN1T_SD_DepoASNImza* elem)
{
   append ((void*)elem);
}

ASN1T_SD_DepoASNImza* ASN1C_SD_DepoASNImzalar::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_SD_DepoASNImza));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_SD_DepoASNImza;
}

ASN1T_SD_DepoASNImza* ASN1C_SD_DepoASNImzalar::AppendNewElement ()
{
   ASN1T_SD_DepoASNImza* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_SD_DepoASNImzalar::~ASN1T_SD_DepoASNImzalar ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_SD_DepoASNImzalar (pctxt, this);
   }
}

int ASN1C_SD_DepoASNImzalar::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_SD_DepoASNImzalar (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_SD_DepoASNImzalar::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_SD_DepoASNImzalar;
   msgData.setContext (msgBuf.getContext());
   return asn1D_SD_DepoASNImzalar (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_SD_DepoASNImzalar (ASN1T_SD_DepoASNImzalar* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_SD_DepoASNImzalar;
   rtxDListFastInit (pvalue);
}

void asn1Free_SD_DepoASNImzalar (OSCTXT *pctxt, 
   ASN1T_SD_DepoASNImzalar* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_SD_DepoASNImza* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_SD_DepoASNImza*)pnode->data;
      asn1Free_SD_DepoASNImza (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_SD_DepoASNImzalar::MemFree ()
{
   asn1Free_SD_DepoASNImzalar (getCtxtPtr(), &msgData);
}

