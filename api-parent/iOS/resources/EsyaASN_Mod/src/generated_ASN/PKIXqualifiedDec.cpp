/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.6, Date: 28-Feb-2014.
 */
#include "PKIXqualified.h"
#include "rtxsrc/rtxCommon.h"

EXTERN int asn1D_PKIXQUAL_DateOfBirth (OSCTXT* pctxt, 
   ASN1T_PKIXQUAL_DateOfBirth* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DateOfBirth");

   stat = xd_charstr (pctxt, pvalue, tagging, (TM_UNIV|TM_PRIM|24), length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_PKIXQUAL_PlaceOfBirth (OSCTXT* pctxt, 
   ASN1T_PKIXQUAL_PlaceOfBirth* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PlaceOfBirth");

   stat = asn1D_EXP_DirectoryString (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_PKIXQUAL_Gender (OSCTXT* pctxt, 
   ASN1T_PKIXQUAL_Gender* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Gender");

   stat = xd_charstr (pctxt, pvalue, tagging, (TM_UNIV|TM_PRIM|19), length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   { size_t nchars = OSCRTLSTRLEN (*pvalue);
   if (!(nchars == 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)nchars);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_PKIXQUAL_CountryOfCitizenship (OSCTXT* pctxt, 
   ASN1T_PKIXQUAL_CountryOfCitizenship* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CountryOfCitizenship");

   stat = xd_charstr (pctxt, pvalue, tagging, (TM_UNIV|TM_PRIM|19), length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   { size_t nchars = OSCRTLSTRLEN (*pvalue);
   if (!(nchars == 2)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)nchars);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_PKIXQUAL_CountryOfResidence (OSCTXT* pctxt, 
   ASN1T_PKIXQUAL_CountryOfResidence* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CountryOfResidence");

   stat = xd_charstr (pctxt, pvalue, tagging, (TM_UNIV|TM_PRIM|19), length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   { size_t nchars = OSCRTLSTRLEN (*pvalue);
   if (!(nchars == 2)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)nchars);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_PKIXQUAL_PredefinedBiometricType (OSCTXT* pctxt, 
   ASN1T_PKIXQUAL_PredefinedBiometricType* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PredefinedBiometricType");

   stat = xd_uint8 (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!((*pvalue == 0 || *pvalue == 1))) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)*pvalue);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_PKIXQUAL_TypeOfBiometricData (OSCTXT* pctxt, 
   ASN1T_PKIXQUAL_TypeOfBiometricData* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "TypeOfBiometricData");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_UNIV|TM_PRIM|2):
         RTXCTXTPUSHELEMNAME (pctxt, "predefinedBiometricType");

         stat = asn1D_PKIXQUAL_PredefinedBiometricType (pctxt, &pvalue->
            u.predefinedBiometricType, ASN1IMPL, length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|6):
         RTXCTXTPUSHELEMNAME (pctxt, "biometricDataOid");

         pvalue->u.biometricDataOid = rtxMemAllocType (pctxt, ASN1TObjId);

         if (pvalue->u.biometricDataOid == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.biometricDataOid->numids = 0;
         stat = xd_objid (pctxt, (ASN1OBJID*)pvalue->u.biometricDataOid, ASN1IMPL, length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_PKIXQUAL_BiometricData (OSCTXT* pctxt, 
   ASN1T_PKIXQUAL_BiometricData* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "BiometricData");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode typeOfBiometricData */
         RTXCTXTPUSHELEMNAME (pctxt, "typeOfBiometricData");

         stat = asn1D_PKIXQUAL_TypeOfBiometricData (pctxt, &pvalue->
            typeOfBiometricData, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode hashAlgorithm */
         RTXCTXTPUSHELEMNAME (pctxt, "hashAlgorithm");

         stat = asn1D_EXP_AlgorithmIdentifier (pctxt, &pvalue->hashAlgorithm, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode biometricDataHash */
         RTXCTXTPUSHELEMNAME (pctxt, "biometricDataHash");

         stat = xd_octstr (pctxt, &pvalue->biometricDataHash.data, &pvalue->biometricDataHash.numocts, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 3:
         /* decode sourceDataUri */
         if (XD_PEEKTAG (pctxt, 0x16)) {
            RTXCTXTPUSHELEMNAME (pctxt, "sourceDataUri");

            stat = xd_charstr (pctxt, &pvalue->sourceDataUri, ASN1EXPL, 
               (TM_UNIV|TM_PRIM|22), length);
            if (stat == 0) {
               pvalue->m.sourceDataUriPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|2):
         case (TM_UNIV|TM_PRIM|6):
         case (TM_UNIV|TM_CONS|16):
         case (TM_UNIV|TM_PRIM|4):
         case (TM_UNIV|TM_PRIM|22):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_PKIXQUAL_BiometricSyntax (OSCTXT* pctxt, 
   ASN1T_PKIXQUAL_BiometricSyntax* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_PKIXQUAL_BiometricData* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "BiometricSyntax");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "BiometricData", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_PKIXQUAL_BiometricData, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PKIXQUAL_BiometricData (pdata1);

      stat = asn1D_PKIXQUAL_BiometricData (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_PKIXQUAL_QCStatement (OSCTXT* pctxt, 
   ASN1T_PKIXQUAL_QCStatement* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "QCStatement");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode statementId */
         RTXCTXTPUSHELEMNAME (pctxt, "statementId");

         stat = xd_objid (pctxt, (ASN1OBJID*)&pvalue->statementId, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode statementInfo */
         RTXCTXTPUSHELEMNAME (pctxt, "statementInfo");

         stat = xd_OpenType (pctxt, &pvalue->statementInfo.data, &pvalue->statementInfo.numocts);
         if (stat == 0) {
            pvalue->m.statementInfoPresent = TRUE;
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_PKIXQUAL_QCStatements (OSCTXT* pctxt, 
   ASN1T_PKIXQUAL_QCStatements* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_PKIXQUAL_QCStatement* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "QCStatements");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "QCStatement", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_PKIXQUAL_QCStatement, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_PKIXQUAL_QCStatement (pdata1);

      stat = asn1D_PKIXQUAL_QCStatement (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_PKIXQUAL_NameRegistrationAuthorities (OSCTXT* pctxt, 
   ASN1T_PKIXQUAL_NameRegistrationAuthorities* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1T_IMP_GeneralName* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "NameRegistrationAuthorities");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "GeneralName", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_IMP_GeneralName, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_IMP_GeneralName (pdata1);

      stat = asn1D_IMP_GeneralName (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_PKIXQUAL_SemanticsInformation (OSCTXT* pctxt, 
   ASN1T_PKIXQUAL_SemanticsInformation* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "SemanticsInformation");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode semanticsIndentifier */
         if (XD_PEEKTAG (pctxt, 0x6)) {
            RTXCTXTPUSHELEMNAME (pctxt, "semanticsIndentifier");

            stat = xd_objid (pctxt, (ASN1OBJID*)&pvalue->semanticsIndentifier, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.semanticsIndentifierPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 1:
         /* decode nameRegistrationAuthorities */
         if (XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "nameRegistrationAuthorities");

            stat = asn1D_PKIXQUAL_NameRegistrationAuthorities (pctxt, &pvalue->
               nameRegistrationAuthorities, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.nameRegistrationAuthoritiesPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|6):
         case (TM_UNIV|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

