/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.6, Date: 28-Feb-2014.
 */
#include "attrcert.h"
#include "rtxsrc/rtxCommon.h"

EXTERN int asn1D_ATTRCERT_AttCertVersion (OSCTXT* pctxt, 
   ASN1T_ATTRCERT_AttCertVersion* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AttCertVersion");

   stat = xd_integer (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ATTRCERT_ClassList (OSCTXT* pctxt, 
   ASN1T_ATTRCERT_ClassList* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ClassList");

   pvalue->numbits = 6;
   stat = xd_bitstr_s (pctxt, pvalue->data, &pvalue->numbits, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ATTRCERT_AttCertVersionV1 (OSCTXT* pctxt, 
   ASN1T_ATTRCERT_AttCertVersionV1* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AttCertVersionV1");

   stat = xd_integer (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ATTRCERT_ObjectDigestInfo_digestedObjectType (OSCTXT* pctxt, 
   ASN1T_ATTRCERT_ObjectDigestInfo_digestedObjectType* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   stat = xd_enumUnsigned (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if(*pvalue > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   return (stat);
}

EXTERN int asn1D_ATTRCERT_IssuerSerial (OSCTXT* pctxt, 
   ASN1T_ATTRCERT_IssuerSerial* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "IssuerSerial");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode issuer */
         RTXCTXTPUSHELEMNAME (pctxt, "issuer");

         stat = asn1D_IMP_GeneralNames (pctxt, &pvalue->issuer, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode serial */
         RTXCTXTPUSHELEMNAME (pctxt, "serial");

         stat = asn1D_EXP_CertificateSerialNumber (pctxt, &pvalue->serial, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode issuerUID */
         if (XD_PEEKTAG (pctxt, 0x3)) {
            RTXCTXTPUSHELEMNAME (pctxt, "issuerUID");

            stat = asn1D_EXP_UniqueIdentifier (pctxt, &pvalue->issuerUID, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.issuerUIDPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_CONS|16):
         case (TM_UNIV|TM_PRIM|2):
         case (TM_UNIV|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ATTRCERT_ObjectDigestInfo (OSCTXT* pctxt, 
   ASN1T_ATTRCERT_ObjectDigestInfo* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "ObjectDigestInfo");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode digestedObjectType */
         RTXCTXTPUSHELEMNAME (pctxt, "digestedObjectType");

         stat = asn1D_ATTRCERT_ObjectDigestInfo_digestedObjectType (pctxt, &
            pvalue->digestedObjectType, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode otherObjectTypeID */
         if (XD_PEEKTAG (pctxt, 0x6)) {
            RTXCTXTPUSHELEMNAME (pctxt, "otherObjectTypeID");

            stat = xd_objid (pctxt, (ASN1OBJID*)&pvalue->otherObjectTypeID, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.otherObjectTypeIDPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 2:
         /* decode digestAlgorithm */
         RTXCTXTPUSHELEMNAME (pctxt, "digestAlgorithm");

         stat = asn1D_EXP_AlgorithmIdentifier (pctxt, &pvalue->digestAlgorithm
            , ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 3:
         /* decode objectDigest */
         RTXCTXTPUSHELEMNAME (pctxt, "objectDigest");

         stat = xd_bitstr (pctxt, &pvalue->objectDigest.data, &pvalue->objectDigest.numbits, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|10):
         case (TM_UNIV|TM_PRIM|6):
         case (TM_UNIV|TM_CONS|16):
         case (TM_UNIV|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ATTRCERT_Holder (OSCTXT* pctxt, 
   ASN1T_ATTRCERT_Holder* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "Holder");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode baseCertificateID */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "baseCertificateID");

            stat = asn1D_ATTRCERT_IssuerSerial (pctxt, &pvalue->
               baseCertificateID, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.baseCertificateIDPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 1:
         /* decode entityName */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "entityName");

            stat = asn1D_IMP_GeneralNames (pctxt, &pvalue->entityName, 
               ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.entityNamePresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 2:
         /* decode objectDigestInfo */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "objectDigestInfo");

            stat = asn1D_ATTRCERT_ObjectDigestInfo (pctxt, &pvalue->
               objectDigestInfo, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.objectDigestInfoPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ATTRCERT_V2Form (OSCTXT* pctxt, 
   ASN1T_ATTRCERT_V2Form* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "V2Form");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode issuerName */
         if (XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "issuerName");

            stat = asn1D_IMP_GeneralNames (pctxt, &pvalue->issuerName, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.issuerNamePresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 1:
         /* decode baseCertificateID */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "baseCertificateID");

            stat = asn1D_ATTRCERT_IssuerSerial (pctxt, &pvalue->
               baseCertificateID, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.baseCertificateIDPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 2:
         /* decode objectDigestInfo */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "objectDigestInfo");

            stat = asn1D_ATTRCERT_ObjectDigestInfo (pctxt, &pvalue->
               objectDigestInfo, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.objectDigestInfoPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_CONS|16):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ATTRCERT_AttCertIssuer (OSCTXT* pctxt, 
   ASN1T_ATTRCERT_AttCertIssuer* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "AttCertIssuer");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_UNIV|TM_CONS|16):
         RTXCTXTPUSHELEMNAME (pctxt, "v1Form");

         pvalue->u.v1Form = rtxMemAllocType (pctxt, ASN1T_IMP_GeneralNames);

         if (pvalue->u.v1Form == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_IMP_GeneralNames (pvalue->u.v1Form);
         stat = asn1D_IMP_GeneralNames (pctxt, pvalue->u.v1Form, 
            ASN1IMPL, length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|0):
         RTXCTXTPUSHELEMNAME (pctxt, "v2Form");

         pvalue->u.v2Form = rtxMemAllocType (pctxt, ASN1T_ATTRCERT_V2Form);

         if (pvalue->u.v2Form == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ATTRCERT_V2Form (pvalue->u.v2Form);
         stat = asn1D_ATTRCERT_V2Form (pctxt, pvalue->u.v2Form, 
            ASN1IMPL, length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ATTRCERT_AttCertValidityPeriod (OSCTXT* pctxt, 
   ASN1T_ATTRCERT_AttCertValidityPeriod* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "AttCertValidityPeriod");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode notBeforeTime */
         RTXCTXTPUSHELEMNAME (pctxt, "notBeforeTime");

         stat = xd_charstr (pctxt, &pvalue->notBeforeTime, ASN1EXPL, 
            (TM_UNIV|TM_PRIM|24), length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode notAfterTime */
         RTXCTXTPUSHELEMNAME (pctxt, "notAfterTime");

         stat = xd_charstr (pctxt, &pvalue->notAfterTime, ASN1EXPL, 
            (TM_UNIV|TM_PRIM|24), length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|24):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ATTRCERT__SeqOfATTRCERT_Attribute (OSCTXT* pctxt, 
   ASN1T_ATTRCERT__SeqOfATTRCERT_Attribute* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1T_EXP_Attribute* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "Attribute", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_EXP_Attribute, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EXP_Attribute (pdata1);

      stat = asn1D_EXP_Attribute (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1D_ATTRCERT_AttributeCertificateInfo (OSCTXT* pctxt, 
   ASN1T_ATTRCERT_AttributeCertificateInfo* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "AttributeCertificateInfo");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode version */
         RTXCTXTPUSHELEMNAME (pctxt, "version");

         stat = asn1D_ATTRCERT_AttCertVersion (pctxt, &pvalue->version, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode holder */
         RTXCTXTPUSHELEMNAME (pctxt, "holder");

         stat = asn1D_ATTRCERT_Holder (pctxt, &pvalue->holder, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode issuer */
         RTXCTXTPUSHELEMNAME (pctxt, "issuer");

         stat = asn1D_ATTRCERT_AttCertIssuer (pctxt, &pvalue->issuer, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 3:
         /* decode signature_ */
         RTXCTXTPUSHELEMNAME (pctxt, "signature");

         stat = asn1D_EXP_AlgorithmIdentifier (pctxt, &pvalue->signature_, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 4:
         /* decode serialNumber */
         RTXCTXTPUSHELEMNAME (pctxt, "serialNumber");

         stat = asn1D_EXP_CertificateSerialNumber (pctxt, &pvalue->serialNumber
            , ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 5:
         /* decode attrCertValidityPeriod */
         RTXCTXTPUSHELEMNAME (pctxt, "attrCertValidityPeriod");

         stat = asn1D_ATTRCERT_AttCertValidityPeriod (pctxt, &pvalue->
            attrCertValidityPeriod, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 6:
         /* decode attributes */
         RTXCTXTPUSHELEMNAME (pctxt, "attributes");

         stat = asn1D_ATTRCERT__SeqOfATTRCERT_Attribute (pctxt, &pvalue->
            attributes, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 7:
         /* decode issuerUniqueID */
         if (XD_PEEKTAG (pctxt, 0x3)) {
            RTXCTXTPUSHELEMNAME (pctxt, "issuerUniqueID");

            stat = asn1D_EXP_UniqueIdentifier (pctxt, &pvalue->issuerUniqueID, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.issuerUniqueIDPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 8:
         /* decode extensions */
         if (XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "extensions");

            stat = asn1D_EXP_Extensions (pctxt, &pvalue->extensions, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.extensionsPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|2):
         case (TM_UNIV|TM_CONS|16):
         case (TM_CTXT|TM_CONS|0):
         case (TM_UNIV|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 7) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ATTRCERT_AttributeCertificate (OSCTXT* pctxt, 
   ASN1T_ATTRCERT_AttributeCertificate* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "AttributeCertificate");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode acinfo */
         RTXCTXTPUSHELEMNAME (pctxt, "acinfo");

         stat = asn1D_ATTRCERT_AttributeCertificateInfo (pctxt, &pvalue->acinfo
            , ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode signatureAlgorithm */
         RTXCTXTPUSHELEMNAME (pctxt, "signatureAlgorithm");

         stat = asn1D_EXP_AlgorithmIdentifier (pctxt, &pvalue->
            signatureAlgorithm, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode signatureValue */
         RTXCTXTPUSHELEMNAME (pctxt, "signatureValue");

         stat = xd_bitstr (pctxt, &pvalue->signatureValue.data, &pvalue->signatureValue.numbits, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_CONS|16):
         case (TM_UNIV|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ATTRCERT_TargetCert (OSCTXT* pctxt, 
   ASN1T_ATTRCERT_TargetCert* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "TargetCert");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode targetCertificate */
         RTXCTXTPUSHELEMNAME (pctxt, "targetCertificate");

         stat = asn1D_ATTRCERT_IssuerSerial (pctxt, &pvalue->targetCertificate
            , ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode targetName */
         if (XD_PEEKTAG (pctxt, 0x80)
         || XD_PEEKTAG (pctxt, 0x81)
         || XD_PEEKTAG (pctxt, 0x82)
         || XD_PEEKTAG (pctxt, 0x83)
         || XD_PEEKTAG (pctxt, 0x84)
         || XD_PEEKTAG (pctxt, 0x85)
         || XD_PEEKTAG (pctxt, 0x86)
         || XD_PEEKTAG (pctxt, 0x87)
         || XD_PEEKTAG (pctxt, 0x88)) {
            RTXCTXTPUSHELEMNAME (pctxt, "targetName");

            stat = asn1D_IMP_GeneralName (pctxt, &pvalue->targetName, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.targetNamePresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 2:
         /* decode certDigestInfo */
         if (XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "certDigestInfo");

            stat = asn1D_ATTRCERT_ObjectDigestInfo (pctxt, &pvalue->
               certDigestInfo, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.certDigestInfoPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_CONS|16):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ATTRCERT_Target (OSCTXT* pctxt, 
   ASN1T_ATTRCERT_Target* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "Target");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         RTXCTXTPUSHELEMNAME (pctxt, "targetName");

         pvalue->u.targetName = rtxMemAllocType (pctxt, 
            ASN1T_IMP_GeneralName);

         if (pvalue->u.targetName == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_IMP_GeneralName (pvalue->u.targetName);
         stat = asn1D_IMP_GeneralName (pctxt, pvalue->u.targetName, 
            ASN1IMPL, length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|1):
         RTXCTXTPUSHELEMNAME (pctxt, "targetGroup");

         pvalue->u.targetGroup = rtxMemAllocType (pctxt, 
            ASN1T_IMP_GeneralName);

         if (pvalue->u.targetGroup == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_IMP_GeneralName (pvalue->u.targetGroup);
         stat = asn1D_IMP_GeneralName (pctxt, pvalue->u.targetGroup, 
            ASN1IMPL, length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|2):
         RTXCTXTPUSHELEMNAME (pctxt, "targetCert");

         pvalue->u.targetCert = rtxMemAllocType (pctxt, 
            ASN1T_ATTRCERT_TargetCert);

         if (pvalue->u.targetCert == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ATTRCERT_TargetCert (pvalue->u.targetCert);
         stat = asn1D_ATTRCERT_TargetCert (pctxt, pvalue->u.targetCert, 
            ASN1IMPL, length);
         pvalue->t = 3;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ATTRCERT_Targets (OSCTXT* pctxt, 
   ASN1T_ATTRCERT_Targets* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_ATTRCERT_Target* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "Targets");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "Target", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_ATTRCERT_Target, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ATTRCERT_Target (pdata1);

      stat = asn1D_ATTRCERT_Target (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ATTRCERT_IetfAttrSyntax_values_element (OSCTXT* pctxt, 
   ASN1T_ATTRCERT_IetfAttrSyntax_values_element* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_UNIV|TM_PRIM|4):
         RTXCTXTPUSHELEMNAME (pctxt, "octets");

         pvalue->u.octets = rtxMemAllocType (pctxt, ASN1TDynOctStr);

         if (pvalue->u.octets == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.octets->numocts = 0;
         pvalue->u.octets->data = 0;
         stat = xd_octstr (pctxt, &pvalue->u.octets->data, &pvalue->u.octets->numocts, ASN1IMPL, length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|6):
         RTXCTXTPUSHELEMNAME (pctxt, "oid");

         pvalue->u.oid = rtxMemAllocType (pctxt, ASN1TObjId);

         if (pvalue->u.oid == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.oid->numids = 0;
         stat = xd_objid (pctxt, (ASN1OBJID*)pvalue->u.oid, ASN1IMPL, length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|12):
         RTXCTXTPUSHELEMNAME (pctxt, "string");

         stat = xd_utf8str (pctxt, &pvalue->u.string, ASN1IMPL, length);
         pvalue->t = 3;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1D_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element (
   OSCTXT* pctxt, 
   ASN1T_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_ATTRCERT_IetfAttrSyntax_values_element* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CHOICE", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_ATTRCERT_IetfAttrSyntax_values_element, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ATTRCERT_IetfAttrSyntax_values_element (pdata1);

      stat = asn1D_ATTRCERT_IetfAttrSyntax_values_element (pctxt, pdata1, 
         ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1D_ATTRCERT_IetfAttrSyntax (OSCTXT* pctxt, 
   ASN1T_ATTRCERT_IetfAttrSyntax* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "IetfAttrSyntax");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode policyAuthority */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "policyAuthority");

            stat = asn1D_IMP_GeneralNames (pctxt, &pvalue->policyAuthority, 
               ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.policyAuthorityPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 1:
         /* decode values */
         RTXCTXTPUSHELEMNAME (pctxt, "values");

         stat = asn1D_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element (pctxt, 
            &pvalue->values, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_UNIV|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ATTRCERT_SvceAuthInfo (OSCTXT* pctxt, 
   ASN1T_ATTRCERT_SvceAuthInfo* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "SvceAuthInfo");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode service */
         RTXCTXTPUSHELEMNAME (pctxt, "service");

         stat = asn1D_IMP_GeneralName (pctxt, &pvalue->service, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode ident */
         RTXCTXTPUSHELEMNAME (pctxt, "ident");

         stat = asn1D_IMP_GeneralName (pctxt, &pvalue->ident, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode authInfo */
         if (XD_PEEKTAG (pctxt, 0x4)) {
            RTXCTXTPUSHELEMNAME (pctxt, "authInfo");

            stat = xd_octstr (pctxt, &pvalue->authInfo.data, &pvalue->authInfo.numocts, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.authInfoPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_UNIV|TM_PRIM|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ATTRCERT_RoleSyntax (OSCTXT* pctxt, 
   ASN1T_ATTRCERT_RoleSyntax* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "RoleSyntax");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode roleAuthority */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "roleAuthority");

            stat = asn1D_IMP_GeneralNames (pctxt, &pvalue->roleAuthority, 
               ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.roleAuthorityPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 1:
         /* decode roleName */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "roleName");

            stat = asn1D_IMP_GeneralName (pctxt, &pvalue->roleName, 
               ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            reqcnt++;
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ATTRCERT_SecurityCategory (OSCTXT* pctxt, 
   ASN1T_ATTRCERT_SecurityCategory* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityCategory");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode type */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "type");

            stat = xd_objid (pctxt, (ASN1OBJID*)&pvalue->type, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            reqcnt++;
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 1:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "value");

            stat = xd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            reqcnt++;
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ATTRCERT__SetOfATTRCERT_SecurityCategory (OSCTXT* pctxt, 
   ASN1T_ATTRCERT__SetOfATTRCERT_SecurityCategory* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_ATTRCERT_SecurityCategory* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x11, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SecurityCategory", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_ATTRCERT_SecurityCategory, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ATTRCERT_SecurityCategory (pdata1);

      stat = asn1D_ATTRCERT_SecurityCategory (pctxt, pdata1, 
         ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1D_ATTRCERT_Clearance (OSCTXT* pctxt, 
   ASN1T_ATTRCERT_Clearance* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "Clearance");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
      pvalue->classList.data[0] = 0x40;
      pvalue->classList.numbits = 2;
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode policyId */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "policyId");

            stat = xd_objid (pctxt, (ASN1OBJID*)&pvalue->policyId, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            reqcnt++;
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 1:
         /* decode classList */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "classList");

            stat = asn1D_ATTRCERT_ClassList (pctxt, &pvalue->classList, 
               ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.classListPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 2:
         /* decode securityCategories */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "securityCategories");

            stat = asn1D_ATTRCERT__SetOfATTRCERT_SecurityCategory (pctxt, &
               pvalue->securityCategories, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.securityCategoriesPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ATTRCERT_AttrSpec (OSCTXT* pctxt, 
   ASN1T_ATTRCERT_AttrSpec* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TObjId* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "AttrSpec");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "OBJECT_IDENTIFIER", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1TObjId, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pdata1->numids = 0;

      stat = xd_objid (pctxt, (ASN1OBJID*)pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ATTRCERT_AAControls (OSCTXT* pctxt, 
   ASN1T_ATTRCERT_AAControls* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "AAControls");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
      pvalue->permitUnSpecified = TRUE;
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode pathLenConstraint */
         if (XD_PEEKTAG (pctxt, 0x2)) {
            RTXCTXTPUSHELEMNAME (pctxt, "pathLenConstraint");

            stat = xd_unsigned (pctxt, &pvalue->pathLenConstraint, ASN1EXPL, length);
            if (stat == 0) {
               if (!(pvalue->pathLenConstraint >= 0)) {
                  rtxErrAddElemNameParm (pctxt);
                  rtxErrAddUIntParm (pctxt, pvalue->pathLenConstraint);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

               pvalue->m.pathLenConstraintPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 1:
         /* decode permittedAttrs */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "permittedAttrs");

            stat = asn1D_ATTRCERT_AttrSpec (pctxt, &pvalue->permittedAttrs, 
               ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.permittedAttrsPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 2:
         /* decode excludedAttrs */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "excludedAttrs");

            stat = asn1D_ATTRCERT_AttrSpec (pctxt, &pvalue->excludedAttrs, 
               ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.excludedAttrsPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 3:
         /* decode permitUnSpecified */
         if (XD_PEEKTAG (pctxt, 0x1)) {
            RTXCTXTPUSHELEMNAME (pctxt, "permitUnSpecified");

            stat = xd_boolean (pctxt, &pvalue->permitUnSpecified, ASN1EXPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_UNIV|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ATTRCERT_ACClearAttrs (OSCTXT* pctxt, 
   ASN1T_ATTRCERT_ACClearAttrs* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "ACClearAttrs");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode acIssuer */
         RTXCTXTPUSHELEMNAME (pctxt, "acIssuer");

         stat = asn1D_IMP_GeneralName (pctxt, &pvalue->acIssuer, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode acSerial */
         RTXCTXTPUSHELEMNAME (pctxt, "acSerial");

         stat = xd_integer (pctxt, &pvalue->acSerial, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode attrs */
         RTXCTXTPUSHELEMNAME (pctxt, "attrs");

         stat = asn1D_ATTRCERT__SeqOfATTRCERT_Attribute (pctxt, &pvalue->attrs
            , ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
         case (TM_UNIV|TM_PRIM|2):
         case (TM_UNIV|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ATTRCERT_ProxyInfo (OSCTXT* pctxt, 
   ASN1T_ATTRCERT_ProxyInfo* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_ATTRCERT_Targets* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "ProxyInfo");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "Targets", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_ATTRCERT_Targets, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_ATTRCERT_Targets (pdata1);

      stat = asn1D_ATTRCERT_Targets (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ATTRCERT_AttributeCertificateInfoV1_subject (OSCTXT* pctxt, 
   ASN1T_ATTRCERT_AttributeCertificateInfoV1_subject* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         RTXCTXTPUSHELEMNAME (pctxt, "baseCertificateID");

         pvalue->u.baseCertificateID = rtxMemAllocType (pctxt, 
            ASN1T_ATTRCERT_IssuerSerial);

         if (pvalue->u.baseCertificateID == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_ATTRCERT_IssuerSerial (pvalue->u.baseCertificateID);
         stat = asn1D_ATTRCERT_IssuerSerial (pctxt, pvalue->u.baseCertificateID
            , ASN1IMPL, length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|1):
         RTXCTXTPUSHELEMNAME (pctxt, "subjectName");

         pvalue->u.subjectName = rtxMemAllocType (pctxt, 
            ASN1T_IMP_GeneralNames);

         if (pvalue->u.subjectName == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_IMP_GeneralNames (pvalue->u.subjectName);
         stat = asn1D_IMP_GeneralNames (pctxt, pvalue->u.subjectName, 
            ASN1IMPL, length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   return (stat);
}

EXTERN int asn1D_ATTRCERT_AttributeCertificateInfoV1 (OSCTXT* pctxt, 
   ASN1T_ATTRCERT_AttributeCertificateInfoV1* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "AttributeCertificateInfoV1");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
      pvalue->version = ATTRCERT_AttCertVersionV1::v1;
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode version */
         if (XD_PEEKTAG (pctxt, 0x2)) {
            RTXCTXTPUSHELEMNAME (pctxt, "version");

            stat = asn1D_ATTRCERT_AttCertVersionV1 (pctxt, &pvalue->version, 
               ASN1EXPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 1:
         /* decode subject */
         RTXCTXTPUSHELEMNAME (pctxt, "subject");

         stat = asn1D_ATTRCERT_AttributeCertificateInfoV1_subject (pctxt, &
            pvalue->subject, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode issuer */
         RTXCTXTPUSHELEMNAME (pctxt, "issuer");

         stat = asn1D_IMP_GeneralNames (pctxt, &pvalue->issuer, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 3:
         /* decode signature_ */
         RTXCTXTPUSHELEMNAME (pctxt, "signature");

         stat = asn1D_EXP_AlgorithmIdentifier (pctxt, &pvalue->signature_, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 4:
         /* decode serialNumber */
         RTXCTXTPUSHELEMNAME (pctxt, "serialNumber");

         stat = asn1D_EXP_CertificateSerialNumber (pctxt, &pvalue->serialNumber
            , ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 5:
         /* decode attCertValidityPeriod */
         RTXCTXTPUSHELEMNAME (pctxt, "attCertValidityPeriod");

         stat = asn1D_ATTRCERT_AttCertValidityPeriod (pctxt, &pvalue->
            attCertValidityPeriod, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 6:
         /* decode attributes */
         RTXCTXTPUSHELEMNAME (pctxt, "attributes");

         stat = asn1D_ATTRCERT__SeqOfATTRCERT_Attribute (pctxt, &pvalue->
            attributes, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 7:
         /* decode issuerUniqueID */
         if (XD_PEEKTAG (pctxt, 0x3)) {
            RTXCTXTPUSHELEMNAME (pctxt, "issuerUniqueID");

            stat = asn1D_EXP_UniqueIdentifier (pctxt, &pvalue->issuerUniqueID, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.issuerUniqueIDPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 8:
         /* decode extensions */
         if (XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "extensions");

            stat = asn1D_EXP_Extensions (pctxt, &pvalue->extensions, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.extensionsPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_UNIV|TM_CONS|16):
         case (TM_UNIV|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 6) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_ATTRCERT_AttributeCertificateV1 (OSCTXT* pctxt, 
   ASN1T_ATTRCERT_AttributeCertificateV1* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "AttributeCertificateV1");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode acInfo */
         RTXCTXTPUSHELEMNAME (pctxt, "acInfo");

         stat = asn1D_ATTRCERT_AttributeCertificateInfoV1 (pctxt, &pvalue->
            acInfo, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode signatureAlgorithm */
         RTXCTXTPUSHELEMNAME (pctxt, "signatureAlgorithm");

         stat = asn1D_EXP_AlgorithmIdentifier (pctxt, &pvalue->
            signatureAlgorithm, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode signature_ */
         RTXCTXTPUSHELEMNAME (pctxt, "signature");

         stat = xd_bitstr (pctxt, &pvalue->signature_.data, &pvalue->signature_.numbits, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_CONS|16):
         case (TM_UNIV|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

