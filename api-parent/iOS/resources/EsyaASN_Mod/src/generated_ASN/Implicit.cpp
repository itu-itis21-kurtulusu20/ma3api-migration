/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.6, Date: 28-Feb-2014.
 */
#include <new>
#include "Implicit.h"
#include "UsefulDefinitions.h"
#include "rtxsrc/rtxCommon.h"

ASN1OBJID IMP_id_ce_subjectAltName = {
   4,
   { 2, 5, 29, 17 }
} ;
ASN1OBJID IMP_id_ce = {
   3,
   { 2, 5, 29 }
} ;
ASN1OBJID IMP_id_ce_authorityKeyIdentifier = {
   4,
   { 2, 5, 29, 35 }
} ;
ASN1OBJID IMP_id_ce_subjectKeyIdentifier = {
   4,
   { 2, 5, 29, 14 }
} ;
ASN1OBJID IMP_id_ce_keyUsage = {
   4,
   { 2, 5, 29, 15 }
} ;
ASN1OBJID IMP_id_ce_certificatePolicies = {
   4,
   { 2, 5, 29, 32 }
} ;
ASN1OBJID IMP_anyPolicy = {
   5,
   { 2, 5, 29, 32, 0 }
} ;
ASN1OBJID IMP_id_ce_policyMappings = {
   4,
   { 2, 5, 29, 33 }
} ;
ASN1OBJID IMP_id_ce_basicConstraints = {
   4,
   { 2, 5, 29, 19 }
} ;
ASN1OBJID IMP_id_ce_extKeyUsage = {
   4,
   { 2, 5, 29, 37 }
} ;
ASN1OBJID IMP_anyExtendedKeyUsage = {
   5,
   { 2, 5, 29, 37, 0 }
} ;
ASN1OBJID IMP_id_kp_serverAuth = {
   9,
   { 1, 3, 6, 1, 5, 5, 7, 3, 1 }
} ;
ASN1OBJID IMP_id_kp_clientAuth = {
   9,
   { 1, 3, 6, 1, 5, 5, 7, 3, 2 }
} ;
ASN1OBJID IMP_id_kp_codeSigning = {
   9,
   { 1, 3, 6, 1, 5, 5, 7, 3, 3 }
} ;
ASN1OBJID IMP_id_kp_emailProtection = {
   9,
   { 1, 3, 6, 1, 5, 5, 7, 3, 4 }
} ;
ASN1OBJID IMP_id_kp_ipsecEndSystem = {
   9,
   { 1, 3, 6, 1, 5, 5, 7, 3, 5 }
} ;
ASN1OBJID IMP_id_kp_ipsecTunnel = {
   9,
   { 1, 3, 6, 1, 5, 5, 7, 3, 6 }
} ;
ASN1OBJID IMP_id_kp_ipsecUser = {
   9,
   { 1, 3, 6, 1, 5, 5, 7, 3, 7 }
} ;
ASN1OBJID IMP_id_kp_timeStamping = {
   9,
   { 1, 3, 6, 1, 5, 5, 7, 3, 8 }
} ;
ASN1OBJID IMP_id_kp_OCSPSigning = {
   9,
   { 1, 3, 6, 1, 5, 5, 7, 3, 9 }
} ;
ASN1OBJID IMP_id_kp_dvcs = {
   9,
   { 1, 3, 6, 1, 5, 5, 7, 3, 10 }
} ;
ASN1OBJID IMP_id_ce_cRLDistributionPoints = {
   4,
   { 2, 5, 29, 31 }
} ;
ASN1OBJID IMP_id_pe_authorityInfoAccess = {
   9,
   { 1, 3, 6, 1, 5, 5, 7, 1, 1 }
} ;
ASN1OBJID IMP_id_pe_subjectInfoAccess = {
   9,
   { 1, 3, 6, 1, 5, 5, 7, 1, 11 }
} ;
ASN1OBJID IMP_id_ce_cRLNumber = {
   4,
   { 2, 5, 29, 20 }
} ;
ASN1OBJID IMP_id_ce_cRLReasons = {
   4,
   { 2, 5, 29, 21 }
} ;
ASN1OBJID IMP_id_ce_subjectDirectoryAttributes = {
   4,
   { 2, 5, 29, 9 }
} ;
ASN1OBJID IMP_id_at_role = {
   4,
   { 2, 5, 4, 72 }
} ;
ASN1OBJID IMP_id_win_certTemplate = {
   9,
   { 1, 3, 6, 1, 4, 1, 311, 20, 2 }
} ;
ASN1OBJID IMP_id_ms_smartCardLogon = {
   10,
   { 1, 3, 6, 1, 4, 1, 311, 20, 2, 2 }
} ;
ASN1OBJID IMP_id_win_upn = {
   10,
   { 1, 3, 6, 1, 4, 1, 311, 20, 2, 3 }
} ;
ASN1OBJID IMP_id_win_otherNameforDC = {
   9,
   { 1, 3, 6, 1, 4, 1, 311, 25, 1 }
} ;
ASN1OBJID IMP_id_ce_nameConstraints = {
   4,
   { 2, 5, 29, 30 }
} ;
ASN1OBJID IMP_id_ce_policyConstraints = {
   4,
   { 2, 5, 29, 36 }
} ;
ASN1OBJID IMP_id_ce_inhibitAnyPolicy = {
   4,
   { 2, 5, 29, 54 }
} ;
ASN1OBJID IMP_id_ce_freshestCRL = {
   4,
   { 2, 5, 29, 46 }
} ;
ASN1OBJID IMP_id_ce_deltaCRLIndicator = {
   4,
   { 2, 5, 29, 27 }
} ;
ASN1OBJID IMP_id_ce_issuingDistributionPoint = {
   4,
   { 2, 5, 29, 28 }
} ;
ASN1OBJID IMP_id_ce_issuerAltName = {
   4,
   { 2, 5, 29, 18 }
} ;
ASN1OBJID IMP_id_ce_holdInstructionCode = {
   4,
   { 2, 5, 29, 23 }
} ;
ASN1OBJID IMP_holdInstruction = {
   5,
   { 1, 2, 840, 10040, 2 }
} ;
ASN1OBJID IMP_id_holdinstruction_none = {
   6,
   { 1, 2, 840, 10040, 2, 1 }
} ;
ASN1OBJID IMP_id_holdinstruction_callissuer = {
   6,
   { 1, 2, 840, 10040, 2, 2 }
} ;
ASN1OBJID IMP_id_holdinstruction_reject = {
   6,
   { 1, 2, 840, 10040, 2, 3 }
} ;
ASN1OBJID IMP_id_ce_invalidityDate = {
   4,
   { 2, 5, 29, 24 }
} ;
ASN1OBJID IMP_id_ce_certificateIssuer = {
   4,
   { 2, 5, 29, 29 }
} ;

ASN1T_IMP_AnotherName* new_ASN1T_IMP_AnotherName (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_AnotherName));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_AnotherName;
}

ASN1C_IMP_AnotherName::ASN1C_IMP_AnotherName (ASN1T_IMP_AnotherName& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_AnotherName::ASN1C_IMP_AnotherName (OSRTMessageBufferIF& msgBuf
   , ASN1T_IMP_AnotherName& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_AnotherName::ASN1C_IMP_AnotherName (OSRTContext &context
   , ASN1T_IMP_AnotherName& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_IMP_AnotherName::ASN1T_IMP_AnotherName ()
{
}

ASN1T_IMP_AnotherName::~ASN1T_IMP_AnotherName ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_IMP_AnotherName (pctxt, this);
   }
}

int ASN1C_IMP_AnotherName::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_AnotherName (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_AnotherName::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_AnotherName;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_AnotherName (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_AnotherName (ASN1T_IMP_AnotherName* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_AnotherName;
}

void asn1Free_IMP_AnotherName (OSCTXT *pctxt, ASN1T_IMP_AnotherName* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreePtr (pctxt, (void*)pvalue->value.data);
}

void ASN1C_IMP_AnotherName::MemFree ()
{
   asn1Free_IMP_AnotherName (getCtxtPtr(), &msgData);
}

ASN1T_IMP_EDIPartyName* new_ASN1T_IMP_EDIPartyName (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_EDIPartyName));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_EDIPartyName;
}

ASN1C_IMP_EDIPartyName::ASN1C_IMP_EDIPartyName (ASN1T_IMP_EDIPartyName& data)
    : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_EDIPartyName::ASN1C_IMP_EDIPartyName (OSRTMessageBufferIF& msgBuf
   , ASN1T_IMP_EDIPartyName& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_EDIPartyName::ASN1C_IMP_EDIPartyName (OSRTContext &context
   , ASN1T_IMP_EDIPartyName& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_IMP_EDIPartyName::ASN1T_IMP_EDIPartyName ()
{
   m.nameAssignerPresent = 0;
}

ASN1T_IMP_EDIPartyName::~ASN1T_IMP_EDIPartyName ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_IMP_EDIPartyName (pctxt, this);
   }
}

int ASN1C_IMP_EDIPartyName::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_EDIPartyName (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_EDIPartyName::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_EDIPartyName;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_EDIPartyName (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_EDIPartyName (ASN1T_IMP_EDIPartyName* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_EDIPartyName;
}

void asn1Free_IMP_EDIPartyName (OSCTXT *pctxt, ASN1T_IMP_EDIPartyName* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.nameAssignerPresent) {
      asn1Free_EXP_DirectoryString (pctxt, &pvalue->nameAssigner);
   }
   asn1Free_EXP_DirectoryString (pctxt, &pvalue->partyName);
}

void ASN1C_IMP_EDIPartyName::MemFree ()
{
   asn1Free_IMP_EDIPartyName (getCtxtPtr(), &msgData);
}

ASN1T_IMP_GeneralName* new_ASN1T_IMP_GeneralName (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_GeneralName));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_GeneralName;
}

ASN1C_IMP_GeneralName::ASN1C_IMP_GeneralName (ASN1T_IMP_GeneralName& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_GeneralName::ASN1C_IMP_GeneralName (OSRTMessageBufferIF& msgBuf
   , ASN1T_IMP_GeneralName& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_GeneralName::ASN1C_IMP_GeneralName (OSRTContext &context
   , ASN1T_IMP_GeneralName& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_IMP_GeneralName::~ASN1T_IMP_GeneralName ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_IMP_GeneralName (pctxt, this);
   }
}

int ASN1C_IMP_GeneralName::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_GeneralName (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_GeneralName::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_GeneralName;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_GeneralName (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_GeneralName (ASN1T_IMP_GeneralName* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_GeneralName;
}

void asn1Free_IMP_GeneralName (OSCTXT *pctxt, ASN1T_IMP_GeneralName* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.otherName) {
            asn1Free_IMP_AnotherName (pctxt, pvalue->u.otherName);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.otherName);
         }
         break;

      case 2:
         if (0 != &pvalue->u.rfc822Name) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.rfc822Name);
         }
         break;

      case 3:
         if (0 != &pvalue->u.dNSName) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.dNSName);
         }
         break;

      case 4:
         if (0 != pvalue->u.x400Address) {
            asn1Free_EXP_ORAddress (pctxt, pvalue->u.x400Address);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.x400Address);
         }
         break;

      case 5:
         if (0 != pvalue->u.directoryName) {
            asn1Free_EXP_Name (pctxt, pvalue->u.directoryName);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.directoryName);
         }
         break;

      case 6:
         if (0 != pvalue->u.ediPartyName) {
            asn1Free_IMP_EDIPartyName (pctxt, pvalue->u.ediPartyName);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ediPartyName);
         }
         break;

      case 7:
         if (0 != &pvalue->u.uniformResourceIdentifier) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.uniformResourceIdentifier);
         }
         break;

      case 8:
         if (0 != pvalue->u.iPAddress) {
            if (pvalue->u.iPAddress->numocts > 0) {
               rtxMemFreePtr (pctxt, (void*)pvalue->u.iPAddress->data);
               pvalue->u.iPAddress->numocts = 0;
               pvalue->u.iPAddress->data = 0;
            }
            rtxMemFreePtr (pctxt, (void*)pvalue->u.iPAddress);
         }
         break;

      case 9:
         if (0 != pvalue->u.registeredID) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.registeredID);
         }
         break;

   }
}

void ASN1C_IMP_GeneralName::MemFree ()
{
   asn1Free_IMP_GeneralName (getCtxtPtr(), &msgData);
}

ASN1C_IMP_GeneralNames::ASN1C_IMP_GeneralNames (ASN1T_IMP_GeneralNames& data)
    : ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_GeneralNames::ASN1C_IMP_GeneralNames (OSRTMessageBufferIF& msgBuf
   , ASN1T_IMP_GeneralNames& data) : ASN1CSeqOfList(msgBuf, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_GeneralNames::ASN1C_IMP_GeneralNames (OSRTContext &context
   , ASN1T_IMP_GeneralNames& data) : ASN1CSeqOfList(context, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_IMP_GeneralNames::ASN1C_IMP_GeneralNames (ASN1CType& ccobj
   , ASN1T_IMP_GeneralNames& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_IMP_GeneralNames::Append (ASN1T_IMP_GeneralName* elem)
{
   append ((void*)elem);
}

ASN1T_IMP_GeneralName* ASN1C_IMP_GeneralNames::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_IMP_GeneralName));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_GeneralName;
}

ASN1T_IMP_GeneralName* ASN1C_IMP_GeneralNames::AppendNewElement ()
{
   ASN1T_IMP_GeneralName* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_IMP_GeneralNames::~ASN1T_IMP_GeneralNames ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_IMP_GeneralNames (pctxt, this);
   }
}

int ASN1C_IMP_GeneralNames::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_GeneralNames (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_GeneralNames::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_GeneralNames;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_GeneralNames (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_GeneralNames (ASN1T_IMP_GeneralNames* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_GeneralNames;
   rtxDListFastInit (pvalue);
}

void asn1Free_IMP_GeneralNames (OSCTXT *pctxt, ASN1T_IMP_GeneralNames* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_IMP_GeneralName* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_IMP_GeneralName*)pnode->data;
      asn1Free_IMP_GeneralName (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_IMP_GeneralNames::MemFree ()
{
   asn1Free_IMP_GeneralNames (getCtxtPtr(), &msgData);
}

ASN1T_IMP_SubjectAltName* new_ASN1T_IMP_SubjectAltName (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_SubjectAltName));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_SubjectAltName;
}

ASN1C_IMP_SubjectAltName::ASN1C_IMP_SubjectAltName
    (ASN1T_IMP_SubjectAltName& data) : ASN1C_IMP_GeneralNames (data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_SubjectAltName::ASN1C_IMP_SubjectAltName (OSRTMessageBufferIF& msgBuf
   , ASN1T_IMP_SubjectAltName& data) : ASN1C_IMP_GeneralNames (msgBuf, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_SubjectAltName::ASN1C_IMP_SubjectAltName (OSRTContext &context
   , ASN1T_IMP_SubjectAltName& data) : ASN1C_IMP_GeneralNames (context, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_IMP_SubjectAltName::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_SubjectAltName (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_SubjectAltName::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_SubjectAltName;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_SubjectAltName (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_SubjectAltName (ASN1T_IMP_SubjectAltName* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_SubjectAltName;
}

void asn1Free_IMP_SubjectAltName (OSCTXT *pctxt, 
   ASN1T_IMP_SubjectAltName* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_IMP_GeneralNames (pctxt, pvalue);
}

void ASN1C_IMP_SubjectAltName::MemFree ()
{
   asn1Free_IMP_SubjectAltName (getCtxtPtr(), &msgData);
}

ASN1T_IMP_KeyIdentifier* new_ASN1T_IMP_KeyIdentifier (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_KeyIdentifier));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_KeyIdentifier;
}

ASN1C_IMP_KeyIdentifier::ASN1C_IMP_KeyIdentifier
    (ASN1T_IMP_KeyIdentifier& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_KeyIdentifier::ASN1C_IMP_KeyIdentifier (OSRTMessageBufferIF& msgBuf
   , ASN1T_IMP_KeyIdentifier& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_KeyIdentifier::ASN1C_IMP_KeyIdentifier (OSRTContext &context
   , ASN1T_IMP_KeyIdentifier& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_IMP_KeyIdentifier::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_KeyIdentifier (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_KeyIdentifier::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_IMP_KeyIdentifier (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_KeyIdentifier (ASN1T_IMP_KeyIdentifier* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_KeyIdentifier;
}

void asn1Free_IMP_KeyIdentifier (OSCTXT *pctxt, 
   ASN1T_IMP_KeyIdentifier* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

void ASN1C_IMP_KeyIdentifier::MemFree ()
{
   asn1Free_IMP_KeyIdentifier (getCtxtPtr(), &msgData);
}

ASN1T_IMP_SubjectKeyIdentifier* 
   new_ASN1T_IMP_SubjectKeyIdentifier (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_SubjectKeyIdentifier));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_SubjectKeyIdentifier;
}

ASN1C_IMP_SubjectKeyIdentifier::ASN1C_IMP_SubjectKeyIdentifier
    (ASN1T_IMP_SubjectKeyIdentifier& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_SubjectKeyIdentifier::ASN1C_IMP_SubjectKeyIdentifier (
   OSRTMessageBufferIF& msgBuf, ASN1T_IMP_SubjectKeyIdentifier& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_SubjectKeyIdentifier::ASN1C_IMP_SubjectKeyIdentifier (
   OSRTContext &context, ASN1T_IMP_SubjectKeyIdentifier& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_IMP_SubjectKeyIdentifier::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_SubjectKeyIdentifier (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_SubjectKeyIdentifier::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_IMP_SubjectKeyIdentifier (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_SubjectKeyIdentifier (ASN1T_IMP_SubjectKeyIdentifier* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_SubjectKeyIdentifier;
}

void asn1Free_IMP_SubjectKeyIdentifier (OSCTXT *pctxt, 
   ASN1T_IMP_SubjectKeyIdentifier* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

void ASN1C_IMP_SubjectKeyIdentifier::MemFree ()
{
   asn1Free_IMP_SubjectKeyIdentifier (getCtxtPtr(), &msgData);
}

ASN1T_IMP_KeyUsage* new_ASN1T_IMP_KeyUsage (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_KeyUsage));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_KeyUsage;
}

ASN1C_IMP_KeyUsage::ASN1C_IMP_KeyUsage (ASN1T_IMP_KeyUsage& data) : 
   ASN1CBitStr (data.data, data.numbits, 16), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_KeyUsage::ASN1C_IMP_KeyUsage (OSRTMessageBufferIF& msgBuf
   , ASN1T_IMP_KeyUsage& data) : ASN1CBitStr (msgBuf, data.data, data.numbits, 
   16), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_KeyUsage::ASN1C_IMP_KeyUsage (OSRTContext &context
   , ASN1T_IMP_KeyUsage& data) : ASN1CBitStr (context, data.data, 
   data.numbits, 16), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_IMP_KeyUsage::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_KeyUsage (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_KeyUsage::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_IMP_KeyUsage (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_KeyUsage (ASN1T_IMP_KeyUsage* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_KeyUsage;
}

ASN1T_IMP_CertPolicyId* new_ASN1T_IMP_CertPolicyId (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_CertPolicyId));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_CertPolicyId;
}

ASN1C_IMP_CertPolicyId::ASN1C_IMP_CertPolicyId (ASN1T_IMP_CertPolicyId& data)
    : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_CertPolicyId::ASN1C_IMP_CertPolicyId (OSRTMessageBufferIF& msgBuf
   , ASN1T_IMP_CertPolicyId& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_CertPolicyId::ASN1C_IMP_CertPolicyId (OSRTContext &context
   , ASN1T_IMP_CertPolicyId& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_IMP_CertPolicyId::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_CertPolicyId (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_CertPolicyId::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_IMP_CertPolicyId (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_CertPolicyId (ASN1T_IMP_CertPolicyId* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_CertPolicyId;
}

ASN1T_IMP_PolicyQualifierId* new_ASN1T_IMP_PolicyQualifierId (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_PolicyQualifierId));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_PolicyQualifierId;
}

ASN1C_IMP_PolicyQualifierId::ASN1C_IMP_PolicyQualifierId
    (ASN1T_IMP_PolicyQualifierId& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_PolicyQualifierId::ASN1C_IMP_PolicyQualifierId (
   OSRTMessageBufferIF& msgBuf, ASN1T_IMP_PolicyQualifierId& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_PolicyQualifierId::ASN1C_IMP_PolicyQualifierId (OSRTContext &context
   , ASN1T_IMP_PolicyQualifierId& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_IMP_PolicyQualifierId::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_PolicyQualifierId (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_PolicyQualifierId::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_IMP_PolicyQualifierId (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_PolicyQualifierId (ASN1T_IMP_PolicyQualifierId* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_PolicyQualifierId;
}

ASN1C_IMP_CPSuri::ASN1C_IMP_CPSuri (ASN1T_IMP_CPSuri& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_CPSuri::ASN1C_IMP_CPSuri (OSRTMessageBufferIF& msgBuf
   , ASN1T_IMP_CPSuri& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_CPSuri::ASN1C_IMP_CPSuri (OSRTContext &context
   , ASN1T_IMP_CPSuri& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_IMP_CPSuri::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_CPSuri (msgBuf.getCtxtPtr(), msgData, ASN1EXPL);
}

int ASN1C_IMP_CPSuri::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_IMP_CPSuri (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Free_IMP_CPSuri (OSCTXT *pctxt, ASN1T_IMP_CPSuri pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreePtr (pctxt, (void*)pvalue);
}

void ASN1C_IMP_CPSuri::MemFree ()
{
   asn1Free_IMP_CPSuri (getCtxtPtr(), msgData);
}

ASN1T_IMP_KeyPurposeId* new_ASN1T_IMP_KeyPurposeId (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_KeyPurposeId));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_KeyPurposeId;
}

ASN1C_IMP_KeyPurposeId::ASN1C_IMP_KeyPurposeId (ASN1T_IMP_KeyPurposeId& data)
    : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_KeyPurposeId::ASN1C_IMP_KeyPurposeId (OSRTMessageBufferIF& msgBuf
   , ASN1T_IMP_KeyPurposeId& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_KeyPurposeId::ASN1C_IMP_KeyPurposeId (OSRTContext &context
   , ASN1T_IMP_KeyPurposeId& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_IMP_KeyPurposeId::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_KeyPurposeId (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_KeyPurposeId::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_IMP_KeyPurposeId (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_KeyPurposeId (ASN1T_IMP_KeyPurposeId* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_KeyPurposeId;
}

ASN1T_IMP_ReasonFlags* new_ASN1T_IMP_ReasonFlags (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_ReasonFlags));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_ReasonFlags;
}

ASN1C_IMP_ReasonFlags::ASN1C_IMP_ReasonFlags (ASN1T_IMP_ReasonFlags& data) : 
   ASN1CBitStr (data.data, data.numbits, 16), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_ReasonFlags::ASN1C_IMP_ReasonFlags (OSRTMessageBufferIF& msgBuf
   , ASN1T_IMP_ReasonFlags& data) : ASN1CBitStr (msgBuf, data.data, 
   data.numbits, 16), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_ReasonFlags::ASN1C_IMP_ReasonFlags (OSRTContext &context
   , ASN1T_IMP_ReasonFlags& data) : ASN1CBitStr (context, data.data, 
   data.numbits, 16), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_IMP_ReasonFlags::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_ReasonFlags (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_ReasonFlags::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_IMP_ReasonFlags (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_ReasonFlags (ASN1T_IMP_ReasonFlags* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_ReasonFlags;
}

ASN1T_IMP_CRLNumber* new_ASN1T_IMP_CRLNumber (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_CRLNumber));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_CRLNumber;
}

ASN1C_IMP_CRLNumber::ASN1C_IMP_CRLNumber (ASN1T_IMP_CRLNumber& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_CRLNumber::ASN1C_IMP_CRLNumber (OSRTMessageBufferIF& msgBuf
   , ASN1T_IMP_CRLNumber& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_CRLNumber::ASN1C_IMP_CRLNumber (OSRTContext &context
   , ASN1T_IMP_CRLNumber& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_IMP_CRLNumber::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_CRLNumber (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_CRLNumber::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_IMP_CRLNumber (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

static const OSEnumItem ASN1T_IMP_CRLReason_ENUMTAB[] = {
   { OSUTF8("aACompromise"), 10, 12, 9 },
   { OSUTF8("affiliationChanged"), 3, 18, 5 },
   { OSUTF8("cACompromise"), 2, 12, 2 },
   { OSUTF8("certificateHold"), 6, 15, 1 },
   { OSUTF8("cessationOfOperation"), 5, 20, 8 },
   { OSUTF8("keyCompromise"), 1, 13, 4 },
   { OSUTF8("privilegeWithdrawn"), 9, 18, 3 },
   { OSUTF8("removeFromCRL"), 8, 13, 7 },
   { OSUTF8("superseded"), 4, 10, 6 },
   { OSUTF8("unspecified"), 0, 11, 0 }
} ;
#define ASN1T_IMP_CRLReason_ENUMTABSIZE 10

const OSUTF8CHAR* ASN1T_IMP_CRLReason_ToString (OSINT32 value)
{
   OSINT32 idx = rtxLookupEnumByValue (value, ASN1T_IMP_CRLReason_ENUMTAB, 
      ASN1T_IMP_CRLReason_ENUMTABSIZE);

   if (idx >= 0 && idx < ASN1T_IMP_CRLReason_ENUMTABSIZE) {
      return ASN1T_IMP_CRLReason_ENUMTAB[idx].name;
   }
   else
      return OSUTF8("_UNKNOWN_");
}

int ASN1T_IMP_CRLReason_ToEnum (OSCTXT* pctxt,
   const OSUTF8CHAR* value, ASN1T_IMP_CRLReason* pvalue)
{
   OSSIZE valueLen = rtxUTF8LenBytes (value);
   return ASN1T_IMP_CRLReason_ToEnum2 (pctxt, value, valueLen, pvalue);
}

int ASN1T_IMP_CRLReason_ToEnum2 (OSCTXT* pctxt,
   const OSUTF8CHAR* value, OSSIZE valueLen, ASN1T_IMP_CRLReason* pvalue)
{
   OSINT32 idx = rtxLookupEnum (value, valueLen, ASN1T_IMP_CRLReason_ENUMTAB, 
      ASN1T_IMP_CRLReason_ENUMTABSIZE);

   if (idx >= 0) {
      *pvalue = (ASN1T_IMP_CRLReason)ASN1T_IMP_CRLReason_ENUMTAB[idx].value;
      return 0;
   }
   else {
      rtxErrAddStrParm (pctxt, (const char*)value);
      return LOG_RTERR (pctxt, RTERR_INVENUM);
   }
}

ASN1T_IMP_CRLReason* new_ASN1T_IMP_CRLReason (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_CRLReason));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_CRLReason;
}

ASN1C_IMP_CRLReason::ASN1C_IMP_CRLReason (ASN1T_IMP_CRLReason& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_CRLReason::ASN1C_IMP_CRLReason (OSRTMessageBufferIF& msgBuf
   , ASN1T_IMP_CRLReason& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_CRLReason::ASN1C_IMP_CRLReason (OSRTContext &context
   , ASN1T_IMP_CRLReason& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_IMP_CRLReason::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_CRLReason (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_CRLReason::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_IMP_CRLReason (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

ASN1T_IMP_BaseDistance* new_ASN1T_IMP_BaseDistance (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_BaseDistance));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_BaseDistance;
}

ASN1C_IMP_BaseDistance::ASN1C_IMP_BaseDistance (ASN1T_IMP_BaseDistance& data)
    : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_BaseDistance::ASN1C_IMP_BaseDistance (OSRTMessageBufferIF& msgBuf
   , ASN1T_IMP_BaseDistance& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_BaseDistance::ASN1C_IMP_BaseDistance (OSRTContext &context
   , ASN1T_IMP_BaseDistance& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_IMP_BaseDistance::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_BaseDistance (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_BaseDistance::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_IMP_BaseDistance (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

ASN1T_IMP_SkipCerts* new_ASN1T_IMP_SkipCerts (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_SkipCerts));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_SkipCerts;
}

ASN1C_IMP_SkipCerts::ASN1C_IMP_SkipCerts (ASN1T_IMP_SkipCerts& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_SkipCerts::ASN1C_IMP_SkipCerts (OSRTMessageBufferIF& msgBuf
   , ASN1T_IMP_SkipCerts& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_SkipCerts::ASN1C_IMP_SkipCerts (OSRTContext &context
   , ASN1T_IMP_SkipCerts& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_IMP_SkipCerts::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_SkipCerts (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_SkipCerts::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_IMP_SkipCerts (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

ASN1T_IMP_InhibitAnyPolicy* new_ASN1T_IMP_InhibitAnyPolicy (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_InhibitAnyPolicy));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_InhibitAnyPolicy;
}

ASN1C_IMP_InhibitAnyPolicy::ASN1C_IMP_InhibitAnyPolicy
    (ASN1T_IMP_InhibitAnyPolicy& data) : ASN1C_IMP_SkipCerts (data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_InhibitAnyPolicy::ASN1C_IMP_InhibitAnyPolicy (
   OSRTMessageBufferIF& msgBuf, ASN1T_IMP_InhibitAnyPolicy& data) : 
   ASN1C_IMP_SkipCerts (msgBuf, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_InhibitAnyPolicy::ASN1C_IMP_InhibitAnyPolicy (OSRTContext &context
   , ASN1T_IMP_InhibitAnyPolicy& data) : ASN1C_IMP_SkipCerts (context, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_IMP_InhibitAnyPolicy::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_InhibitAnyPolicy (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_InhibitAnyPolicy::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_IMP_InhibitAnyPolicy (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

ASN1T_IMP_DistributionPointName* 
   new_ASN1T_IMP_DistributionPointName (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_DistributionPointName));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_DistributionPointName;
}

ASN1C_IMP_DistributionPointName::ASN1C_IMP_DistributionPointName
    (ASN1T_IMP_DistributionPointName& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_DistributionPointName::ASN1C_IMP_DistributionPointName (
   OSRTMessageBufferIF& msgBuf, ASN1T_IMP_DistributionPointName& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_DistributionPointName::ASN1C_IMP_DistributionPointName (
   OSRTContext &context, ASN1T_IMP_DistributionPointName& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_IMP_DistributionPointName::~ASN1T_IMP_DistributionPointName ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_IMP_DistributionPointName (pctxt, this);
   }
}

int ASN1C_IMP_DistributionPointName::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_DistributionPointName (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_DistributionPointName::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_DistributionPointName;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_DistributionPointName (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_DistributionPointName (
   ASN1T_IMP_DistributionPointName* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_DistributionPointName;
}

void asn1Free_IMP_DistributionPointName (OSCTXT *pctxt, 
   ASN1T_IMP_DistributionPointName* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.fullName) {
            asn1Free_IMP_GeneralNames (pctxt, pvalue->u.fullName);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.fullName);
         }
         break;

      case 2:
         if (0 != pvalue->u.nameRelativeToCRLIssuer) {
            asn1Free_EXP_RelativeDistinguishedName (pctxt, pvalue->u.nameRelativeToCRLIssuer);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.nameRelativeToCRLIssuer);
         }
         break;

   }
}

void ASN1C_IMP_DistributionPointName::MemFree ()
{
   asn1Free_IMP_DistributionPointName (getCtxtPtr(), &msgData);
}

ASN1T_IMP_DistributionPoint* new_ASN1T_IMP_DistributionPoint (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_DistributionPoint));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_DistributionPoint;
}

ASN1C_IMP_DistributionPoint::ASN1C_IMP_DistributionPoint
    (ASN1T_IMP_DistributionPoint& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_DistributionPoint::ASN1C_IMP_DistributionPoint (
   OSRTMessageBufferIF& msgBuf, ASN1T_IMP_DistributionPoint& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_DistributionPoint::ASN1C_IMP_DistributionPoint (OSRTContext &context
   , ASN1T_IMP_DistributionPoint& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_IMP_DistributionPoint::ASN1T_IMP_DistributionPoint ()
{
   m.distributionPointPresent = 0;
   m.reasonsPresent = 0;
   m.cRLIssuerPresent = 0;
}

ASN1T_IMP_DistributionPoint::~ASN1T_IMP_DistributionPoint ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_IMP_DistributionPoint (pctxt, this);
   }
}

int ASN1C_IMP_DistributionPoint::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_DistributionPoint (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_DistributionPoint::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_DistributionPoint;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_DistributionPoint (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_DistributionPoint (ASN1T_IMP_DistributionPoint* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_DistributionPoint;
}

void asn1Free_IMP_DistributionPoint (OSCTXT *pctxt, 
   ASN1T_IMP_DistributionPoint* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.distributionPointPresent) {
      asn1Free_IMP_DistributionPointName (pctxt, &pvalue->distributionPoint);
   }
   if (pvalue->m.cRLIssuerPresent) {
      asn1Free_IMP_GeneralNames (pctxt, &pvalue->cRLIssuer);
   }
}

void ASN1C_IMP_DistributionPoint::MemFree ()
{
   asn1Free_IMP_DistributionPoint (getCtxtPtr(), &msgData);
}

ASN1C_IMP_CRLDistributionPoints::ASN1C_IMP_CRLDistributionPoints
    (ASN1T_IMP_CRLDistributionPoints& data) : ASN1CSeqOfList(data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_CRLDistributionPoints::ASN1C_IMP_CRLDistributionPoints (
   OSRTMessageBufferIF& msgBuf, ASN1T_IMP_CRLDistributionPoints& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_CRLDistributionPoints::ASN1C_IMP_CRLDistributionPoints (
   OSRTContext &context, ASN1T_IMP_CRLDistributionPoints& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_IMP_CRLDistributionPoints::
   ASN1C_IMP_CRLDistributionPoints (ASN1CType& ccobj
   , ASN1T_IMP_CRLDistributionPoints& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_IMP_CRLDistributionPoints::Append (ASN1T_IMP_DistributionPoint* elem)
{
   append ((void*)elem);
}

ASN1T_IMP_DistributionPoint* ASN1C_IMP_CRLDistributionPoints::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_IMP_DistributionPoint));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_DistributionPoint;
}

ASN1T_IMP_DistributionPoint* ASN1C_IMP_CRLDistributionPoints::AppendNewElement ()
{
   ASN1T_IMP_DistributionPoint* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_IMP_CRLDistributionPoints::~ASN1T_IMP_CRLDistributionPoints ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_IMP_CRLDistributionPoints (pctxt, this);
   }
}

int ASN1C_IMP_CRLDistributionPoints::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_CRLDistributionPoints (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_CRLDistributionPoints::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_CRLDistributionPoints;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_CRLDistributionPoints (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_CRLDistributionPoints (
   ASN1T_IMP_CRLDistributionPoints* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_CRLDistributionPoints;
   rtxDListFastInit (pvalue);
}

void asn1Free_IMP_CRLDistributionPoints (OSCTXT *pctxt, 
   ASN1T_IMP_CRLDistributionPoints* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_IMP_DistributionPoint* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_IMP_DistributionPoint*)pnode->data;
      asn1Free_IMP_DistributionPoint (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_IMP_CRLDistributionPoints::MemFree ()
{
   asn1Free_IMP_CRLDistributionPoints (getCtxtPtr(), &msgData);
}

ASN1T_IMP_FreshestCRL* new_ASN1T_IMP_FreshestCRL (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_FreshestCRL));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_FreshestCRL;
}

ASN1C_IMP_FreshestCRL::ASN1C_IMP_FreshestCRL (ASN1T_IMP_FreshestCRL& data) : 
   ASN1C_IMP_CRLDistributionPoints (data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_FreshestCRL::ASN1C_IMP_FreshestCRL (OSRTMessageBufferIF& msgBuf
   , ASN1T_IMP_FreshestCRL& data) : 
   ASN1C_IMP_CRLDistributionPoints (msgBuf, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_FreshestCRL::ASN1C_IMP_FreshestCRL (OSRTContext &context
   , ASN1T_IMP_FreshestCRL& data) : 
   ASN1C_IMP_CRLDistributionPoints (context, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_IMP_FreshestCRL::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_FreshestCRL (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_FreshestCRL::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_FreshestCRL;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_FreshestCRL (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_FreshestCRL (ASN1T_IMP_FreshestCRL* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_FreshestCRL;
}

void asn1Free_IMP_FreshestCRL (OSCTXT *pctxt, ASN1T_IMP_FreshestCRL* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_IMP_CRLDistributionPoints (pctxt, pvalue);
}

void ASN1C_IMP_FreshestCRL::MemFree ()
{
   asn1Free_IMP_FreshestCRL (getCtxtPtr(), &msgData);
}

ASN1T_IMP_BaseCRLNumber* new_ASN1T_IMP_BaseCRLNumber (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_BaseCRLNumber));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_BaseCRLNumber;
}

ASN1C_IMP_BaseCRLNumber::ASN1C_IMP_BaseCRLNumber
    (ASN1T_IMP_BaseCRLNumber& data) : ASN1C_IMP_CRLNumber (data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_BaseCRLNumber::ASN1C_IMP_BaseCRLNumber (OSRTMessageBufferIF& msgBuf
   , ASN1T_IMP_BaseCRLNumber& data) : ASN1C_IMP_CRLNumber (msgBuf, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_BaseCRLNumber::ASN1C_IMP_BaseCRLNumber (OSRTContext &context
   , ASN1T_IMP_BaseCRLNumber& data) : ASN1C_IMP_CRLNumber (context, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_IMP_BaseCRLNumber::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_BaseCRLNumber (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_BaseCRLNumber::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_IMP_BaseCRLNumber (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

ASN1T_IMP_IssuerAltName* new_ASN1T_IMP_IssuerAltName (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_IssuerAltName));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_IssuerAltName;
}

ASN1C_IMP_IssuerAltName::ASN1C_IMP_IssuerAltName
    (ASN1T_IMP_IssuerAltName& data) : ASN1C_IMP_GeneralNames (data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_IssuerAltName::ASN1C_IMP_IssuerAltName (OSRTMessageBufferIF& msgBuf
   , ASN1T_IMP_IssuerAltName& data) : ASN1C_IMP_GeneralNames (msgBuf, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_IssuerAltName::ASN1C_IMP_IssuerAltName (OSRTContext &context
   , ASN1T_IMP_IssuerAltName& data) : ASN1C_IMP_GeneralNames (context, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_IMP_IssuerAltName::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_IssuerAltName (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_IssuerAltName::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_IssuerAltName;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_IssuerAltName (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_IssuerAltName (ASN1T_IMP_IssuerAltName* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_IssuerAltName;
}

void asn1Free_IMP_IssuerAltName (OSCTXT *pctxt, 
   ASN1T_IMP_IssuerAltName* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_IMP_GeneralNames (pctxt, pvalue);
}

void ASN1C_IMP_IssuerAltName::MemFree ()
{
   asn1Free_IMP_IssuerAltName (getCtxtPtr(), &msgData);
}

ASN1T_IMP_HoldInstructionCode* 
   new_ASN1T_IMP_HoldInstructionCode (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_HoldInstructionCode));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_HoldInstructionCode;
}

ASN1C_IMP_HoldInstructionCode::ASN1C_IMP_HoldInstructionCode
    (ASN1T_IMP_HoldInstructionCode& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_HoldInstructionCode::ASN1C_IMP_HoldInstructionCode (
   OSRTMessageBufferIF& msgBuf, ASN1T_IMP_HoldInstructionCode& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_HoldInstructionCode::ASN1C_IMP_HoldInstructionCode (
   OSRTContext &context, ASN1T_IMP_HoldInstructionCode& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_IMP_HoldInstructionCode::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_HoldInstructionCode (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_HoldInstructionCode::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_IMP_HoldInstructionCode (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_HoldInstructionCode (ASN1T_IMP_HoldInstructionCode* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_HoldInstructionCode;
}

ASN1C_IMP_InvalidityDate::ASN1C_IMP_InvalidityDate
    (ASN1T_IMP_InvalidityDate& data) : 
   ASN1CGeneralizedTime(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_InvalidityDate::ASN1C_IMP_InvalidityDate (OSRTMessageBufferIF& msgBuf
   , ASN1T_IMP_InvalidityDate& data) : 
   ASN1CGeneralizedTime (msgBuf, data), msgData (data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_InvalidityDate::ASN1C_IMP_InvalidityDate (OSRTContext &context
   , ASN1T_IMP_InvalidityDate& data) : 
   ASN1CGeneralizedTime (context, data), msgData (data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_IMP_InvalidityDate::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_InvalidityDate (msgBuf.getCtxtPtr(), msgData, ASN1EXPL);
}

int ASN1C_IMP_InvalidityDate::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_IMP_InvalidityDate (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Free_IMP_InvalidityDate (OSCTXT *pctxt, 
   ASN1T_IMP_InvalidityDate pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreePtr (pctxt, (void*)pvalue);
}

void ASN1C_IMP_InvalidityDate::MemFree ()
{
   asn1Free_IMP_InvalidityDate (getCtxtPtr(), msgData);
}

ASN1T_IMP_CertificateIssuer* new_ASN1T_IMP_CertificateIssuer (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_CertificateIssuer));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_CertificateIssuer;
}

ASN1C_IMP_CertificateIssuer::ASN1C_IMP_CertificateIssuer
    (ASN1T_IMP_CertificateIssuer& data) : ASN1C_IMP_GeneralNames (data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_CertificateIssuer::ASN1C_IMP_CertificateIssuer (
   OSRTMessageBufferIF& msgBuf, ASN1T_IMP_CertificateIssuer& data) : 
   ASN1C_IMP_GeneralNames (msgBuf, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_CertificateIssuer::ASN1C_IMP_CertificateIssuer (OSRTContext &context
   , ASN1T_IMP_CertificateIssuer& data) : 
   ASN1C_IMP_GeneralNames (context, data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_IMP_CertificateIssuer::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_CertificateIssuer (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_CertificateIssuer::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_CertificateIssuer;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_CertificateIssuer (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_CertificateIssuer (ASN1T_IMP_CertificateIssuer* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_CertificateIssuer;
}

void asn1Free_IMP_CertificateIssuer (OSCTXT *pctxt, 
   ASN1T_IMP_CertificateIssuer* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_IMP_GeneralNames (pctxt, pvalue);
}

void ASN1C_IMP_CertificateIssuer::MemFree ()
{
   asn1Free_IMP_CertificateIssuer (getCtxtPtr(), &msgData);
}

ASN1T_IMP_AuthorityKeyIdentifier* 
   new_ASN1T_IMP_AuthorityKeyIdentifier (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_AuthorityKeyIdentifier));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_AuthorityKeyIdentifier;
}

ASN1C_IMP_AuthorityKeyIdentifier::ASN1C_IMP_AuthorityKeyIdentifier
    (ASN1T_IMP_AuthorityKeyIdentifier& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_AuthorityKeyIdentifier::ASN1C_IMP_AuthorityKeyIdentifier (
   OSRTMessageBufferIF& msgBuf, ASN1T_IMP_AuthorityKeyIdentifier& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_AuthorityKeyIdentifier::ASN1C_IMP_AuthorityKeyIdentifier (
   OSRTContext &context, ASN1T_IMP_AuthorityKeyIdentifier& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_IMP_AuthorityKeyIdentifier::ASN1T_IMP_AuthorityKeyIdentifier ()
{
   m.keyIdentifierPresent = 0;
   m.authorityCertIssuerPresent = 0;
   m.authorityCertSerialNumberPresent = 0;
}

ASN1T_IMP_AuthorityKeyIdentifier::~ASN1T_IMP_AuthorityKeyIdentifier ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_IMP_AuthorityKeyIdentifier (pctxt, this);
   }
}

int ASN1C_IMP_AuthorityKeyIdentifier::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_AuthorityKeyIdentifier (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_AuthorityKeyIdentifier::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_AuthorityKeyIdentifier;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_AuthorityKeyIdentifier (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_AuthorityKeyIdentifier (
   ASN1T_IMP_AuthorityKeyIdentifier* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_AuthorityKeyIdentifier;
}

void asn1Free_IMP_AuthorityKeyIdentifier (OSCTXT *pctxt, 
   ASN1T_IMP_AuthorityKeyIdentifier* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.keyIdentifierPresent) {
      asn1Free_IMP_KeyIdentifier (pctxt, &pvalue->keyIdentifier);
   }
   if (pvalue->m.authorityCertIssuerPresent) {
      asn1Free_IMP_GeneralNames (pctxt, &pvalue->authorityCertIssuer);
   }
}

void ASN1C_IMP_AuthorityKeyIdentifier::MemFree ()
{
   asn1Free_IMP_AuthorityKeyIdentifier (getCtxtPtr(), &msgData);
}

ASN1T_IMP_PolicyQualifierInfo* 
   new_ASN1T_IMP_PolicyQualifierInfo (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_PolicyQualifierInfo));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_PolicyQualifierInfo;
}

ASN1C_IMP_PolicyQualifierInfo::ASN1C_IMP_PolicyQualifierInfo
    (ASN1T_IMP_PolicyQualifierInfo& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_PolicyQualifierInfo::ASN1C_IMP_PolicyQualifierInfo (
   OSRTMessageBufferIF& msgBuf, ASN1T_IMP_PolicyQualifierInfo& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_PolicyQualifierInfo::ASN1C_IMP_PolicyQualifierInfo (
   OSRTContext &context, ASN1T_IMP_PolicyQualifierInfo& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_IMP_PolicyQualifierInfo::ASN1T_IMP_PolicyQualifierInfo ()
{
}

ASN1T_IMP_PolicyQualifierInfo::~ASN1T_IMP_PolicyQualifierInfo ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_IMP_PolicyQualifierInfo (pctxt, this);
   }
}

int ASN1C_IMP_PolicyQualifierInfo::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_PolicyQualifierInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_PolicyQualifierInfo::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_PolicyQualifierInfo;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_PolicyQualifierInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_PolicyQualifierInfo (ASN1T_IMP_PolicyQualifierInfo* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_PolicyQualifierInfo;
}

void asn1Free_IMP_PolicyQualifierInfo (OSCTXT *pctxt, 
   ASN1T_IMP_PolicyQualifierInfo* pvalue)
{
   if (0 == pvalue) return;
   rtxMemFreePtr (pctxt, (void*)pvalue->qualifier.data);
}

void ASN1C_IMP_PolicyQualifierInfo::MemFree ()
{
   asn1Free_IMP_PolicyQualifierInfo (getCtxtPtr(), &msgData);
}

ASN1C_IMP_PolicyInformation_policyQualifiers::
   ASN1C_IMP_PolicyInformation_policyQualifiers
    (ASN1T_IMP_PolicyInformation_policyQualifiers& data) : ASN1CSeqOfList(data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_PolicyInformation_policyQualifiers::
   ASN1C_IMP_PolicyInformation_policyQualifiers (OSRTMessageBufferIF& msgBuf
   , ASN1T_IMP_PolicyInformation_policyQualifiers& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_PolicyInformation_policyQualifiers::
   ASN1C_IMP_PolicyInformation_policyQualifiers (OSRTContext &context
   , ASN1T_IMP_PolicyInformation_policyQualifiers& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_IMP_PolicyInformation_policyQualifiers::
   ASN1C_IMP_PolicyInformation_policyQualifiers (ASN1CType& ccobj
   , ASN1T_IMP_PolicyInformation_policyQualifiers& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_IMP_PolicyInformation_policyQualifiers::Append (ASN1T_IMP_PolicyQualifierInfo* elem)
{
   append ((void*)elem);
}

ASN1T_IMP_PolicyQualifierInfo* ASN1C_IMP_PolicyInformation_policyQualifiers::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_IMP_PolicyQualifierInfo));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_PolicyQualifierInfo;
}

ASN1T_IMP_PolicyQualifierInfo* ASN1C_IMP_PolicyInformation_policyQualifiers::AppendNewElement ()
{
   ASN1T_IMP_PolicyQualifierInfo* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_IMP_PolicyInformation_policyQualifiers::~ASN1T_IMP_PolicyInformation_policyQualifiers ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_IMP_PolicyInformation_policyQualifiers (pctxt, this);
   }
}

int ASN1C_IMP_PolicyInformation_policyQualifiers::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_PolicyInformation_policyQualifiers (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_PolicyInformation_policyQualifiers::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_PolicyInformation_policyQualifiers;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_PolicyInformation_policyQualifiers (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_PolicyInformation_policyQualifiers (
   ASN1T_IMP_PolicyInformation_policyQualifiers* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_PolicyInformation_policyQualifiers;
   rtxDListFastInit (pvalue);
}

void asn1Free_IMP_PolicyInformation_policyQualifiers (OSCTXT *pctxt, 
   ASN1T_IMP_PolicyInformation_policyQualifiers* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_IMP_PolicyQualifierInfo* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_IMP_PolicyQualifierInfo*)pnode->data;
      asn1Free_IMP_PolicyQualifierInfo (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_IMP_PolicyInformation_policyQualifiers::MemFree ()
{
   asn1Free_IMP_PolicyInformation_policyQualifiers (getCtxtPtr(), &msgData);
}

ASN1T_IMP_PolicyInformation* new_ASN1T_IMP_PolicyInformation (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_PolicyInformation));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_PolicyInformation;
}

ASN1C_IMP_PolicyInformation::ASN1C_IMP_PolicyInformation
    (ASN1T_IMP_PolicyInformation& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_PolicyInformation::ASN1C_IMP_PolicyInformation (
   OSRTMessageBufferIF& msgBuf, ASN1T_IMP_PolicyInformation& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_PolicyInformation::ASN1C_IMP_PolicyInformation (OSRTContext &context
   , ASN1T_IMP_PolicyInformation& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_IMP_PolicyInformation::ASN1T_IMP_PolicyInformation ()
{
   m.policyQualifiersPresent = 0;
}

ASN1T_IMP_PolicyInformation::~ASN1T_IMP_PolicyInformation ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_IMP_PolicyInformation (pctxt, this);
   }
}

int ASN1C_IMP_PolicyInformation::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_PolicyInformation (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_PolicyInformation::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_PolicyInformation;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_PolicyInformation (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_PolicyInformation (ASN1T_IMP_PolicyInformation* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_PolicyInformation;
}

void asn1Free_IMP_PolicyInformation (OSCTXT *pctxt, 
   ASN1T_IMP_PolicyInformation* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.policyQualifiersPresent) {
      asn1Free_IMP_PolicyInformation_policyQualifiers (pctxt, &pvalue->policyQualifiers);
   }
}

void ASN1C_IMP_PolicyInformation::MemFree ()
{
   asn1Free_IMP_PolicyInformation (getCtxtPtr(), &msgData);
}

ASN1C_IMP_CertificatePolicies::ASN1C_IMP_CertificatePolicies
    (ASN1T_IMP_CertificatePolicies& data) : ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_CertificatePolicies::ASN1C_IMP_CertificatePolicies (
   OSRTMessageBufferIF& msgBuf, ASN1T_IMP_CertificatePolicies& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_CertificatePolicies::ASN1C_IMP_CertificatePolicies (
   OSRTContext &context, ASN1T_IMP_CertificatePolicies& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_IMP_CertificatePolicies::ASN1C_IMP_CertificatePolicies (ASN1CType& ccobj
   , ASN1T_IMP_CertificatePolicies& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_IMP_CertificatePolicies::Append (ASN1T_IMP_PolicyInformation* elem)
{
   append ((void*)elem);
}

ASN1T_IMP_PolicyInformation* ASN1C_IMP_CertificatePolicies::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_IMP_PolicyInformation));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_PolicyInformation;
}

ASN1T_IMP_PolicyInformation* ASN1C_IMP_CertificatePolicies::AppendNewElement ()
{
   ASN1T_IMP_PolicyInformation* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_IMP_CertificatePolicies::~ASN1T_IMP_CertificatePolicies ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_IMP_CertificatePolicies (pctxt, this);
   }
}

int ASN1C_IMP_CertificatePolicies::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_CertificatePolicies (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_CertificatePolicies::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_CertificatePolicies;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_CertificatePolicies (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_CertificatePolicies (ASN1T_IMP_CertificatePolicies* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_CertificatePolicies;
   rtxDListFastInit (pvalue);
}

void asn1Free_IMP_CertificatePolicies (OSCTXT *pctxt, 
   ASN1T_IMP_CertificatePolicies* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_IMP_PolicyInformation* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_IMP_PolicyInformation*)pnode->data;
      asn1Free_IMP_PolicyInformation (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_IMP_CertificatePolicies::MemFree ()
{
   asn1Free_IMP_CertificatePolicies (getCtxtPtr(), &msgData);
}

ASN1T_IMP_DisplayText* new_ASN1T_IMP_DisplayText (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_DisplayText));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_DisplayText;
}

ASN1C_IMP_DisplayText::ASN1C_IMP_DisplayText (ASN1T_IMP_DisplayText& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_DisplayText::ASN1C_IMP_DisplayText (OSRTMessageBufferIF& msgBuf
   , ASN1T_IMP_DisplayText& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_DisplayText::ASN1C_IMP_DisplayText (OSRTContext &context
   , ASN1T_IMP_DisplayText& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_IMP_DisplayText::~ASN1T_IMP_DisplayText ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_IMP_DisplayText (pctxt, this);
   }
}

int ASN1C_IMP_DisplayText::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_DisplayText (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_DisplayText::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_DisplayText;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_DisplayText (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_DisplayText (ASN1T_IMP_DisplayText* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_DisplayText;
}

void asn1Free_IMP_DisplayText (OSCTXT *pctxt, ASN1T_IMP_DisplayText* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != &pvalue->u.utf8String) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.utf8String);
         }
         break;

      case 2:
         if (0 != &pvalue->u.ia5String) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.ia5String);
         }
         break;

      case 3:
         if (0 != &pvalue->u.visibleString) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.visibleString);
         }
         break;

      case 4:
         if (0 != pvalue->u.bmpString) {
            rtxMemFreePtr (pctxt, (void*)pvalue->u.bmpString);
         }
         break;

   }
}

void ASN1C_IMP_DisplayText::MemFree ()
{
   asn1Free_IMP_DisplayText (getCtxtPtr(), &msgData);
}

ASN1C_IMP_NoticeReference_noticeNumbers::
   ASN1C_IMP_NoticeReference_noticeNumbers
    (ASN1T_IMP_NoticeReference_noticeNumbers& data) : ASN1CSeqOfList(data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_NoticeReference_noticeNumbers::
   ASN1C_IMP_NoticeReference_noticeNumbers (OSRTMessageBufferIF& msgBuf
   , ASN1T_IMP_NoticeReference_noticeNumbers& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_NoticeReference_noticeNumbers::
   ASN1C_IMP_NoticeReference_noticeNumbers (OSRTContext &context
   , ASN1T_IMP_NoticeReference_noticeNumbers& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_IMP_NoticeReference_noticeNumbers::
   ASN1C_IMP_NoticeReference_noticeNumbers (ASN1CType& ccobj
   , ASN1T_IMP_NoticeReference_noticeNumbers& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_IMP_NoticeReference_noticeNumbers::Append (OSINT32* elem)
{
   append ((void*)elem);
}

OSINT32* ASN1C_IMP_NoticeReference_noticeNumbers::NewElement ()
{
   void* pdata = memAlloc (sizeof(OSINT32));

   if (0 == pdata) return 0;
   else return new (pdata) OSINT32;
}

OSINT32* ASN1C_IMP_NoticeReference_noticeNumbers::AppendNewElement ()
{
   OSINT32* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_IMP_NoticeReference_noticeNumbers::~ASN1T_IMP_NoticeReference_noticeNumbers ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_IMP_NoticeReference_noticeNumbers (pctxt, this);
   }
}

int ASN1C_IMP_NoticeReference_noticeNumbers::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_NoticeReference_noticeNumbers (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_NoticeReference_noticeNumbers::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_NoticeReference_noticeNumbers;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_NoticeReference_noticeNumbers (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_NoticeReference_noticeNumbers (
   ASN1T_IMP_NoticeReference_noticeNumbers* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_NoticeReference_noticeNumbers;
   rtxDListFastInit (pvalue);
}

void asn1Free_IMP_NoticeReference_noticeNumbers (OSCTXT *pctxt, 
   ASN1T_IMP_NoticeReference_noticeNumbers* pvalue)
{
   if (0 == pvalue) return;
   { OSINT32* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (OSINT32*)pnode->data;
      OS_UNUSED_ARG(pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_IMP_NoticeReference_noticeNumbers::MemFree ()
{
   asn1Free_IMP_NoticeReference_noticeNumbers (getCtxtPtr(), &msgData);
}

ASN1T_IMP_NoticeReference* new_ASN1T_IMP_NoticeReference (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_NoticeReference));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_NoticeReference;
}

ASN1C_IMP_NoticeReference::ASN1C_IMP_NoticeReference
    (ASN1T_IMP_NoticeReference& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_NoticeReference::ASN1C_IMP_NoticeReference (
   OSRTMessageBufferIF& msgBuf, ASN1T_IMP_NoticeReference& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_NoticeReference::ASN1C_IMP_NoticeReference (OSRTContext &context
   , ASN1T_IMP_NoticeReference& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_IMP_NoticeReference::ASN1T_IMP_NoticeReference ()
{
}

ASN1T_IMP_NoticeReference::~ASN1T_IMP_NoticeReference ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_IMP_NoticeReference (pctxt, this);
   }
}

int ASN1C_IMP_NoticeReference::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_NoticeReference (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_NoticeReference::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_NoticeReference;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_NoticeReference (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_NoticeReference (ASN1T_IMP_NoticeReference* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_NoticeReference;
}

void asn1Free_IMP_NoticeReference (OSCTXT *pctxt, 
   ASN1T_IMP_NoticeReference* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_IMP_DisplayText (pctxt, &pvalue->organization);
   asn1Free_IMP_NoticeReference_noticeNumbers (pctxt, &pvalue->noticeNumbers);
}

void ASN1C_IMP_NoticeReference::MemFree ()
{
   asn1Free_IMP_NoticeReference (getCtxtPtr(), &msgData);
}

ASN1T_IMP_UserNotice* new_ASN1T_IMP_UserNotice (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_UserNotice));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_UserNotice;
}

ASN1C_IMP_UserNotice::ASN1C_IMP_UserNotice (ASN1T_IMP_UserNotice& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_UserNotice::ASN1C_IMP_UserNotice (OSRTMessageBufferIF& msgBuf
   , ASN1T_IMP_UserNotice& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_UserNotice::ASN1C_IMP_UserNotice (OSRTContext &context
   , ASN1T_IMP_UserNotice& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_IMP_UserNotice::ASN1T_IMP_UserNotice ()
{
   m.noticeRefPresent = 0;
   m.explicitTextPresent = 0;
}

ASN1T_IMP_UserNotice::~ASN1T_IMP_UserNotice ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_IMP_UserNotice (pctxt, this);
   }
}

int ASN1C_IMP_UserNotice::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_UserNotice (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_UserNotice::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_UserNotice;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_UserNotice (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_UserNotice (ASN1T_IMP_UserNotice* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_UserNotice;
}

void asn1Free_IMP_UserNotice (OSCTXT *pctxt, ASN1T_IMP_UserNotice* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.noticeRefPresent) {
      asn1Free_IMP_NoticeReference (pctxt, &pvalue->noticeRef);
   }
   if (pvalue->m.explicitTextPresent) {
      asn1Free_IMP_DisplayText (pctxt, &pvalue->explicitText);
   }
}

void ASN1C_IMP_UserNotice::MemFree ()
{
   asn1Free_IMP_UserNotice (getCtxtPtr(), &msgData);
}

ASN1T_IMP_Qualifier* new_ASN1T_IMP_Qualifier (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_Qualifier));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_Qualifier;
}

ASN1C_IMP_Qualifier::ASN1C_IMP_Qualifier (ASN1T_IMP_Qualifier& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_Qualifier::ASN1C_IMP_Qualifier (OSRTMessageBufferIF& msgBuf
   , ASN1T_IMP_Qualifier& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_Qualifier::ASN1C_IMP_Qualifier (OSRTContext &context
   , ASN1T_IMP_Qualifier& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_IMP_Qualifier::~ASN1T_IMP_Qualifier ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_IMP_Qualifier (pctxt, this);
   }
}

int ASN1C_IMP_Qualifier::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_Qualifier (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_Qualifier::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_Qualifier;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_Qualifier (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_Qualifier (ASN1T_IMP_Qualifier* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_Qualifier;
}

void asn1Free_IMP_Qualifier (OSCTXT *pctxt, ASN1T_IMP_Qualifier* pvalue)
{
   if (0 == pvalue) return;
   switch (pvalue->t) {
      case 0: break; /* no choice; nothing to free */
      case 1:
         if (0 != pvalue->u.userNotice) {
            asn1Free_IMP_UserNotice (pctxt, pvalue->u.userNotice);
            rtxMemFreePtr (pctxt, (void*)pvalue->u.userNotice);
         }
         break;

      case 2:
         if (0 != &pvalue->u.cPSuri) {
            asn1Free_IMP_CPSuri (pctxt, pvalue->u.cPSuri);
         }
         break;

   }
}

void ASN1C_IMP_Qualifier::MemFree ()
{
   asn1Free_IMP_Qualifier (getCtxtPtr(), &msgData);
}

ASN1T_IMP_PolicyMappings_element* 
   new_ASN1T_IMP_PolicyMappings_element (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_PolicyMappings_element));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_PolicyMappings_element;
}

ASN1C_IMP_PolicyMappings_element::ASN1C_IMP_PolicyMappings_element
    (ASN1T_IMP_PolicyMappings_element& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_PolicyMappings_element::ASN1C_IMP_PolicyMappings_element (
   OSRTMessageBufferIF& msgBuf, ASN1T_IMP_PolicyMappings_element& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_PolicyMappings_element::ASN1C_IMP_PolicyMappings_element (
   OSRTContext &context, ASN1T_IMP_PolicyMappings_element& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_IMP_PolicyMappings_element::ASN1T_IMP_PolicyMappings_element ()
{
}

int ASN1C_IMP_PolicyMappings_element::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_PolicyMappings_element (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_PolicyMappings_element::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_PolicyMappings_element;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_PolicyMappings_element (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_PolicyMappings_element (
   ASN1T_IMP_PolicyMappings_element* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_PolicyMappings_element;
}

ASN1C_IMP_PolicyMappings::ASN1C_IMP_PolicyMappings
    (ASN1T_IMP_PolicyMappings& data) : ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_PolicyMappings::ASN1C_IMP_PolicyMappings (OSRTMessageBufferIF& msgBuf
   , ASN1T_IMP_PolicyMappings& data) : ASN1CSeqOfList(msgBuf, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_PolicyMappings::ASN1C_IMP_PolicyMappings (OSRTContext &context
   , ASN1T_IMP_PolicyMappings& data) : ASN1CSeqOfList(context, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_IMP_PolicyMappings::ASN1C_IMP_PolicyMappings (ASN1CType& ccobj
   , ASN1T_IMP_PolicyMappings& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_IMP_PolicyMappings::Append (ASN1T_IMP_PolicyMappings_element* elem)
{
   append ((void*)elem);
}

ASN1T_IMP_PolicyMappings_element* ASN1C_IMP_PolicyMappings::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_IMP_PolicyMappings_element));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_PolicyMappings_element;
}

ASN1T_IMP_PolicyMappings_element* ASN1C_IMP_PolicyMappings::AppendNewElement ()
{
   ASN1T_IMP_PolicyMappings_element* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_IMP_PolicyMappings::~ASN1T_IMP_PolicyMappings ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_IMP_PolicyMappings (pctxt, this);
   }
}

int ASN1C_IMP_PolicyMappings::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_PolicyMappings (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_PolicyMappings::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_PolicyMappings;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_PolicyMappings (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_PolicyMappings (ASN1T_IMP_PolicyMappings* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_PolicyMappings;
   rtxDListFastInit (pvalue);
}

void asn1Free_IMP_PolicyMappings (OSCTXT *pctxt, 
   ASN1T_IMP_PolicyMappings* pvalue)
{
   if (0 == pvalue) return;
   rtxDListFreeAll (pctxt, pvalue);
}

void ASN1C_IMP_PolicyMappings::MemFree ()
{
   asn1Free_IMP_PolicyMappings (getCtxtPtr(), &msgData);
}

ASN1T_IMP_BasicConstraints* new_ASN1T_IMP_BasicConstraints (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_BasicConstraints));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_BasicConstraints;
}

ASN1C_IMP_BasicConstraints::ASN1C_IMP_BasicConstraints
    (ASN1T_IMP_BasicConstraints& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_BasicConstraints::ASN1C_IMP_BasicConstraints (
   OSRTMessageBufferIF& msgBuf, ASN1T_IMP_BasicConstraints& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_BasicConstraints::ASN1C_IMP_BasicConstraints (OSRTContext &context
   , ASN1T_IMP_BasicConstraints& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_IMP_BasicConstraints::ASN1T_IMP_BasicConstraints ()
{
   cA = FALSE;
   m.pathLenConstraintPresent = 0;
}

int ASN1C_IMP_BasicConstraints::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_BasicConstraints (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_BasicConstraints::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_BasicConstraints;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_BasicConstraints (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_BasicConstraints (ASN1T_IMP_BasicConstraints* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_BasicConstraints;
}

ASN1C_IMP_ExtKeyUsageSyntax::ASN1C_IMP_ExtKeyUsageSyntax
    (ASN1T_IMP_ExtKeyUsageSyntax& data) : ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_ExtKeyUsageSyntax::ASN1C_IMP_ExtKeyUsageSyntax (
   OSRTMessageBufferIF& msgBuf, ASN1T_IMP_ExtKeyUsageSyntax& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_ExtKeyUsageSyntax::ASN1C_IMP_ExtKeyUsageSyntax (OSRTContext &context
   , ASN1T_IMP_ExtKeyUsageSyntax& data) : ASN1CSeqOfList(context, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_IMP_ExtKeyUsageSyntax::ASN1C_IMP_ExtKeyUsageSyntax (ASN1CType& ccobj
   , ASN1T_IMP_ExtKeyUsageSyntax& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_IMP_ExtKeyUsageSyntax::Append (ASN1T_IMP_KeyPurposeId* elem)
{
   append ((void*)elem);
}

ASN1T_IMP_KeyPurposeId* ASN1C_IMP_ExtKeyUsageSyntax::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_IMP_KeyPurposeId));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_KeyPurposeId;
}

ASN1T_IMP_KeyPurposeId* ASN1C_IMP_ExtKeyUsageSyntax::AppendNewElement ()
{
   ASN1T_IMP_KeyPurposeId* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_IMP_ExtKeyUsageSyntax::~ASN1T_IMP_ExtKeyUsageSyntax ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_IMP_ExtKeyUsageSyntax (pctxt, this);
   }
}

int ASN1C_IMP_ExtKeyUsageSyntax::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_ExtKeyUsageSyntax (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_ExtKeyUsageSyntax::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_ExtKeyUsageSyntax;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_ExtKeyUsageSyntax (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_ExtKeyUsageSyntax (ASN1T_IMP_ExtKeyUsageSyntax* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_ExtKeyUsageSyntax;
   rtxDListFastInit (pvalue);
}

void asn1Free_IMP_ExtKeyUsageSyntax (OSCTXT *pctxt, 
   ASN1T_IMP_ExtKeyUsageSyntax* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_IMP_KeyPurposeId* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_IMP_KeyPurposeId*)pnode->data;
      OS_UNUSED_ARG(pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_IMP_ExtKeyUsageSyntax::MemFree ()
{
   asn1Free_IMP_ExtKeyUsageSyntax (getCtxtPtr(), &msgData);
}

ASN1T_IMP_AccessDescription* new_ASN1T_IMP_AccessDescription (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_AccessDescription));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_AccessDescription;
}

ASN1C_IMP_AccessDescription::ASN1C_IMP_AccessDescription
    (ASN1T_IMP_AccessDescription& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_AccessDescription::ASN1C_IMP_AccessDescription (
   OSRTMessageBufferIF& msgBuf, ASN1T_IMP_AccessDescription& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_AccessDescription::ASN1C_IMP_AccessDescription (OSRTContext &context
   , ASN1T_IMP_AccessDescription& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_IMP_AccessDescription::ASN1T_IMP_AccessDescription ()
{
}

ASN1T_IMP_AccessDescription::~ASN1T_IMP_AccessDescription ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_IMP_AccessDescription (pctxt, this);
   }
}

int ASN1C_IMP_AccessDescription::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_AccessDescription (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_AccessDescription::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_AccessDescription;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_AccessDescription (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_AccessDescription (ASN1T_IMP_AccessDescription* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_AccessDescription;
}

void asn1Free_IMP_AccessDescription (OSCTXT *pctxt, 
   ASN1T_IMP_AccessDescription* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_IMP_GeneralName (pctxt, &pvalue->accessLocation);
}

void ASN1C_IMP_AccessDescription::MemFree ()
{
   asn1Free_IMP_AccessDescription (getCtxtPtr(), &msgData);
}

ASN1C_IMP_AuthorityInfoAccessSyntax::ASN1C_IMP_AuthorityInfoAccessSyntax
    (ASN1T_IMP_AuthorityInfoAccessSyntax& data) : ASN1CSeqOfList(data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_AuthorityInfoAccessSyntax::ASN1C_IMP_AuthorityInfoAccessSyntax (
   OSRTMessageBufferIF& msgBuf, ASN1T_IMP_AuthorityInfoAccessSyntax& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_AuthorityInfoAccessSyntax::ASN1C_IMP_AuthorityInfoAccessSyntax (
   OSRTContext &context, ASN1T_IMP_AuthorityInfoAccessSyntax& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_IMP_AuthorityInfoAccessSyntax::
   ASN1C_IMP_AuthorityInfoAccessSyntax (ASN1CType& ccobj
   , ASN1T_IMP_AuthorityInfoAccessSyntax& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_IMP_AuthorityInfoAccessSyntax::Append (ASN1T_IMP_AccessDescription* elem)
{
   append ((void*)elem);
}

ASN1T_IMP_AccessDescription* ASN1C_IMP_AuthorityInfoAccessSyntax::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_IMP_AccessDescription));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_AccessDescription;
}

ASN1T_IMP_AccessDescription* ASN1C_IMP_AuthorityInfoAccessSyntax::AppendNewElement ()
{
   ASN1T_IMP_AccessDescription* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_IMP_AuthorityInfoAccessSyntax::~ASN1T_IMP_AuthorityInfoAccessSyntax ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_IMP_AuthorityInfoAccessSyntax (pctxt, this);
   }
}

int ASN1C_IMP_AuthorityInfoAccessSyntax::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_AuthorityInfoAccessSyntax (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_AuthorityInfoAccessSyntax::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_AuthorityInfoAccessSyntax;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_AuthorityInfoAccessSyntax (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_AuthorityInfoAccessSyntax (
   ASN1T_IMP_AuthorityInfoAccessSyntax* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_AuthorityInfoAccessSyntax;
   rtxDListFastInit (pvalue);
}

void asn1Free_IMP_AuthorityInfoAccessSyntax (OSCTXT *pctxt, 
   ASN1T_IMP_AuthorityInfoAccessSyntax* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_IMP_AccessDescription* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_IMP_AccessDescription*)pnode->data;
      asn1Free_IMP_AccessDescription (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_IMP_AuthorityInfoAccessSyntax::MemFree ()
{
   asn1Free_IMP_AuthorityInfoAccessSyntax (getCtxtPtr(), &msgData);
}

ASN1C_IMP_SubjectInfoAccessSyntax::ASN1C_IMP_SubjectInfoAccessSyntax
    (ASN1T_IMP_SubjectInfoAccessSyntax& data) : ASN1CSeqOfList(data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_SubjectInfoAccessSyntax::ASN1C_IMP_SubjectInfoAccessSyntax (
   OSRTMessageBufferIF& msgBuf, ASN1T_IMP_SubjectInfoAccessSyntax& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_SubjectInfoAccessSyntax::ASN1C_IMP_SubjectInfoAccessSyntax (
   OSRTContext &context, ASN1T_IMP_SubjectInfoAccessSyntax& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_IMP_SubjectInfoAccessSyntax::
   ASN1C_IMP_SubjectInfoAccessSyntax (ASN1CType& ccobj
   , ASN1T_IMP_SubjectInfoAccessSyntax& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_IMP_SubjectInfoAccessSyntax::Append (ASN1T_IMP_AccessDescription* elem)
{
   append ((void*)elem);
}

ASN1T_IMP_AccessDescription* ASN1C_IMP_SubjectInfoAccessSyntax::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_IMP_AccessDescription));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_AccessDescription;
}

ASN1T_IMP_AccessDescription* ASN1C_IMP_SubjectInfoAccessSyntax::AppendNewElement ()
{
   ASN1T_IMP_AccessDescription* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_IMP_SubjectInfoAccessSyntax::~ASN1T_IMP_SubjectInfoAccessSyntax ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_IMP_SubjectInfoAccessSyntax (pctxt, this);
   }
}

int ASN1C_IMP_SubjectInfoAccessSyntax::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_SubjectInfoAccessSyntax (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_SubjectInfoAccessSyntax::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_SubjectInfoAccessSyntax;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_SubjectInfoAccessSyntax (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_SubjectInfoAccessSyntax (
   ASN1T_IMP_SubjectInfoAccessSyntax* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_SubjectInfoAccessSyntax;
   rtxDListFastInit (pvalue);
}

void asn1Free_IMP_SubjectInfoAccessSyntax (OSCTXT *pctxt, 
   ASN1T_IMP_SubjectInfoAccessSyntax* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_IMP_AccessDescription* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_IMP_AccessDescription*)pnode->data;
      asn1Free_IMP_AccessDescription (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_IMP_SubjectInfoAccessSyntax::MemFree ()
{
   asn1Free_IMP_SubjectInfoAccessSyntax (getCtxtPtr(), &msgData);
}

ASN1C_IMP_SubjectDirectoryAttributes::ASN1C_IMP_SubjectDirectoryAttributes
    (ASN1T_IMP_SubjectDirectoryAttributes& data) : ASN1CSeqOfList(data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_SubjectDirectoryAttributes::ASN1C_IMP_SubjectDirectoryAttributes (
   OSRTMessageBufferIF& msgBuf, ASN1T_IMP_SubjectDirectoryAttributes& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_SubjectDirectoryAttributes::ASN1C_IMP_SubjectDirectoryAttributes (
   OSRTContext &context, ASN1T_IMP_SubjectDirectoryAttributes& data) : 
   ASN1CSeqOfList(context, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_IMP_SubjectDirectoryAttributes::
   ASN1C_IMP_SubjectDirectoryAttributes (ASN1CType& ccobj
   , ASN1T_IMP_SubjectDirectoryAttributes& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_IMP_SubjectDirectoryAttributes::Append (ASN1T_EXP_Attribute* elem)
{
   append ((void*)elem);
}

ASN1T_EXP_Attribute* ASN1C_IMP_SubjectDirectoryAttributes::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_EXP_Attribute));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_EXP_Attribute;
}

ASN1T_EXP_Attribute* ASN1C_IMP_SubjectDirectoryAttributes::AppendNewElement ()
{
   ASN1T_EXP_Attribute* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_IMP_SubjectDirectoryAttributes::~ASN1T_IMP_SubjectDirectoryAttributes ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_IMP_SubjectDirectoryAttributes (pctxt, this);
   }
}

int ASN1C_IMP_SubjectDirectoryAttributes::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_SubjectDirectoryAttributes (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_SubjectDirectoryAttributes::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_SubjectDirectoryAttributes;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_SubjectDirectoryAttributes (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_SubjectDirectoryAttributes (
   ASN1T_IMP_SubjectDirectoryAttributes* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_SubjectDirectoryAttributes;
   rtxDListFastInit (pvalue);
}

void asn1Free_IMP_SubjectDirectoryAttributes (OSCTXT *pctxt, 
   ASN1T_IMP_SubjectDirectoryAttributes* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_EXP_Attribute* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_EXP_Attribute*)pnode->data;
      asn1Free_EXP_Attribute (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_IMP_SubjectDirectoryAttributes::MemFree ()
{
   asn1Free_IMP_SubjectDirectoryAttributes (getCtxtPtr(), &msgData);
}

ASN1T_IMP_RoleSyntax* new_ASN1T_IMP_RoleSyntax (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_RoleSyntax));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_RoleSyntax;
}

ASN1C_IMP_RoleSyntax::ASN1C_IMP_RoleSyntax (ASN1T_IMP_RoleSyntax& data) : 
   ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_RoleSyntax::ASN1C_IMP_RoleSyntax (OSRTMessageBufferIF& msgBuf
   , ASN1T_IMP_RoleSyntax& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_RoleSyntax::ASN1C_IMP_RoleSyntax (OSRTContext &context
   , ASN1T_IMP_RoleSyntax& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_IMP_RoleSyntax::ASN1T_IMP_RoleSyntax ()
{
   m.roleAuthorityPresent = 0;
}

ASN1T_IMP_RoleSyntax::~ASN1T_IMP_RoleSyntax ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_IMP_RoleSyntax (pctxt, this);
   }
}

int ASN1C_IMP_RoleSyntax::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_RoleSyntax (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_RoleSyntax::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_RoleSyntax;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_RoleSyntax (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_RoleSyntax (ASN1T_IMP_RoleSyntax* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_RoleSyntax;
}

void asn1Free_IMP_RoleSyntax (OSCTXT *pctxt, ASN1T_IMP_RoleSyntax* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.roleAuthorityPresent) {
      asn1Free_IMP_GeneralNames (pctxt, &pvalue->roleAuthority);
   }
   asn1Free_IMP_GeneralName (pctxt, &pvalue->roleName);
}

void ASN1C_IMP_RoleSyntax::MemFree ()
{
   asn1Free_IMP_RoleSyntax (getCtxtPtr(), &msgData);
}

ASN1T_IMP_GeneralSubtree* new_ASN1T_IMP_GeneralSubtree (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_GeneralSubtree));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_GeneralSubtree;
}

ASN1C_IMP_GeneralSubtree::ASN1C_IMP_GeneralSubtree
    (ASN1T_IMP_GeneralSubtree& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_GeneralSubtree::ASN1C_IMP_GeneralSubtree (OSRTMessageBufferIF& msgBuf
   , ASN1T_IMP_GeneralSubtree& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_GeneralSubtree::ASN1C_IMP_GeneralSubtree (OSRTContext &context
   , ASN1T_IMP_GeneralSubtree& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_IMP_GeneralSubtree::ASN1T_IMP_GeneralSubtree ()
{
   minimum = 0;
   m.maximumPresent = 0;
}

ASN1T_IMP_GeneralSubtree::~ASN1T_IMP_GeneralSubtree ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_IMP_GeneralSubtree (pctxt, this);
   }
}

int ASN1C_IMP_GeneralSubtree::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_GeneralSubtree (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_GeneralSubtree::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_GeneralSubtree;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_GeneralSubtree (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_GeneralSubtree (ASN1T_IMP_GeneralSubtree* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_GeneralSubtree;
}

void asn1Free_IMP_GeneralSubtree (OSCTXT *pctxt, 
   ASN1T_IMP_GeneralSubtree* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_IMP_GeneralName (pctxt, &pvalue->base);
}

void ASN1C_IMP_GeneralSubtree::MemFree ()
{
   asn1Free_IMP_GeneralSubtree (getCtxtPtr(), &msgData);
}

ASN1C_IMP_GeneralSubtrees::ASN1C_IMP_GeneralSubtrees
    (ASN1T_IMP_GeneralSubtrees& data) : ASN1CSeqOfList(data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_GeneralSubtrees::ASN1C_IMP_GeneralSubtrees (
   OSRTMessageBufferIF& msgBuf, ASN1T_IMP_GeneralSubtrees& data) : 
   ASN1CSeqOfList(msgBuf, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_GeneralSubtrees::ASN1C_IMP_GeneralSubtrees (OSRTContext &context
   , ASN1T_IMP_GeneralSubtrees& data) : ASN1CSeqOfList(context, data)
   , msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1C_IMP_GeneralSubtrees::ASN1C_IMP_GeneralSubtrees (ASN1CType& ccobj
   , ASN1T_IMP_GeneralSubtrees& data) :
   ASN1CSeqOfList(ccobj, data), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

void ASN1C_IMP_GeneralSubtrees::Append (ASN1T_IMP_GeneralSubtree* elem)
{
   append ((void*)elem);
}

ASN1T_IMP_GeneralSubtree* ASN1C_IMP_GeneralSubtrees::NewElement ()
{
   void* pdata = memAlloc (sizeof(ASN1T_IMP_GeneralSubtree));

   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_GeneralSubtree;
}

ASN1T_IMP_GeneralSubtree* ASN1C_IMP_GeneralSubtrees::AppendNewElement ()
{
   ASN1T_IMP_GeneralSubtree* pdata = NewElement();
   if (0 != pdata) {
      Append (pdata);
   }
   return pdata;
}

ASN1T_IMP_GeneralSubtrees::~ASN1T_IMP_GeneralSubtrees ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_IMP_GeneralSubtrees (pctxt, this);
   }
}

int ASN1C_IMP_GeneralSubtrees::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_GeneralSubtrees (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_GeneralSubtrees::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_GeneralSubtrees;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_GeneralSubtrees (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_GeneralSubtrees (ASN1T_IMP_GeneralSubtrees* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_GeneralSubtrees;
   rtxDListFastInit (pvalue);
}

void asn1Free_IMP_GeneralSubtrees (OSCTXT *pctxt, 
   ASN1T_IMP_GeneralSubtrees* pvalue)
{
   if (0 == pvalue) return;
   { ASN1T_IMP_GeneralSubtree* pdata;
   OSRTDListNode* pnode = pvalue->head;
   while (0 != pnode) {
      pdata = (ASN1T_IMP_GeneralSubtree*)pnode->data;
      asn1Free_IMP_GeneralSubtree (pctxt, pdata);
      pnode = pnode->next;
   }
   rtxDListFreeAll (pctxt, pvalue);
   }
}

void ASN1C_IMP_GeneralSubtrees::MemFree ()
{
   asn1Free_IMP_GeneralSubtrees (getCtxtPtr(), &msgData);
}

ASN1T_IMP_NameConstraints* new_ASN1T_IMP_NameConstraints (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_NameConstraints));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_NameConstraints;
}

ASN1C_IMP_NameConstraints::ASN1C_IMP_NameConstraints
    (ASN1T_IMP_NameConstraints& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_NameConstraints::ASN1C_IMP_NameConstraints (
   OSRTMessageBufferIF& msgBuf, ASN1T_IMP_NameConstraints& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_NameConstraints::ASN1C_IMP_NameConstraints (OSRTContext &context
   , ASN1T_IMP_NameConstraints& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_IMP_NameConstraints::ASN1T_IMP_NameConstraints ()
{
   m.permittedSubtreesPresent = 0;
   m.excludedSubtreesPresent = 0;
}

ASN1T_IMP_NameConstraints::~ASN1T_IMP_NameConstraints ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_IMP_NameConstraints (pctxt, this);
   }
}

int ASN1C_IMP_NameConstraints::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_NameConstraints (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_NameConstraints::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_NameConstraints;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_NameConstraints (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_NameConstraints (ASN1T_IMP_NameConstraints* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_NameConstraints;
}

void asn1Free_IMP_NameConstraints (OSCTXT *pctxt, 
   ASN1T_IMP_NameConstraints* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.permittedSubtreesPresent) {
      asn1Free_IMP_GeneralSubtrees (pctxt, &pvalue->permittedSubtrees);
   }
   if (pvalue->m.excludedSubtreesPresent) {
      asn1Free_IMP_GeneralSubtrees (pctxt, &pvalue->excludedSubtrees);
   }
}

void ASN1C_IMP_NameConstraints::MemFree ()
{
   asn1Free_IMP_NameConstraints (getCtxtPtr(), &msgData);
}

ASN1T_IMP_PolicyConstraints* new_ASN1T_IMP_PolicyConstraints (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_PolicyConstraints));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_PolicyConstraints;
}

ASN1C_IMP_PolicyConstraints::ASN1C_IMP_PolicyConstraints
    (ASN1T_IMP_PolicyConstraints& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_PolicyConstraints::ASN1C_IMP_PolicyConstraints (
   OSRTMessageBufferIF& msgBuf, ASN1T_IMP_PolicyConstraints& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_PolicyConstraints::ASN1C_IMP_PolicyConstraints (OSRTContext &context
   , ASN1T_IMP_PolicyConstraints& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_IMP_PolicyConstraints::ASN1T_IMP_PolicyConstraints ()
{
   m.requireExplicitPolicyPresent = 0;
   m.inhibitPolicyMappingPresent = 0;
}

int ASN1C_IMP_PolicyConstraints::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_PolicyConstraints (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_PolicyConstraints::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_PolicyConstraints;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_PolicyConstraints (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_PolicyConstraints (ASN1T_IMP_PolicyConstraints* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_PolicyConstraints;
}

ASN1T_IMP_IssuingDistributionPoint* 
   new_ASN1T_IMP_IssuingDistributionPoint (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_IMP_IssuingDistributionPoint));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_IMP_IssuingDistributionPoint;
}

ASN1C_IMP_IssuingDistributionPoint::ASN1C_IMP_IssuingDistributionPoint
    (ASN1T_IMP_IssuingDistributionPoint& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_IMP_IssuingDistributionPoint::ASN1C_IMP_IssuingDistributionPoint (
   OSRTMessageBufferIF& msgBuf, ASN1T_IMP_IssuingDistributionPoint& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_IMP_IssuingDistributionPoint::ASN1C_IMP_IssuingDistributionPoint (
   OSRTContext &context, ASN1T_IMP_IssuingDistributionPoint& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_IMP_IssuingDistributionPoint::ASN1T_IMP_IssuingDistributionPoint ()
{
   m.distributionPointPresent = 0;
   onlyContainsUserCerts = FALSE;
   onlyContainsCACerts = FALSE;
   m.onlySomeReasonsPresent = 0;
   indirectCRL = FALSE;
   onlyContainsAttributeCerts = FALSE;
}

ASN1T_IMP_IssuingDistributionPoint::~ASN1T_IMP_IssuingDistributionPoint ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_IMP_IssuingDistributionPoint (pctxt, this);
   }
}

int ASN1C_IMP_IssuingDistributionPoint::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_IMP_IssuingDistributionPoint (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_IMP_IssuingDistributionPoint::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_IMP_IssuingDistributionPoint;
   msgData.setContext (msgBuf.getContext());
   return asn1D_IMP_IssuingDistributionPoint (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_IMP_IssuingDistributionPoint (
   ASN1T_IMP_IssuingDistributionPoint* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_IMP_IssuingDistributionPoint;
}

void asn1Free_IMP_IssuingDistributionPoint (OSCTXT *pctxt, 
   ASN1T_IMP_IssuingDistributionPoint* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->m.distributionPointPresent) {
      asn1Free_IMP_DistributionPointName (pctxt, &pvalue->distributionPoint);
   }
}

void ASN1C_IMP_IssuingDistributionPoint::MemFree ()
{
   asn1Free_IMP_IssuingDistributionPoint (getCtxtPtr(), &msgData);
}

