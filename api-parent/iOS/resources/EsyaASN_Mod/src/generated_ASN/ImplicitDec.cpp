/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.6, Date: 28-Feb-2014.
 */
#include "Implicit.h"
#include "UsefulDefinitions.h"
#include "rtxsrc/rtxCommon.h"

EXTERN int asn1D_IMP_AnotherName (OSCTXT* pctxt, 
   ASN1T_IMP_AnotherName* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "AnotherName");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode type_id */
         RTXCTXTPUSHELEMNAME (pctxt, "type-id");

         stat = xd_objid (pctxt, (ASN1OBJID*)&pvalue->type_id, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode value */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "value");

            stat = xd_OpenType (pctxt, &pvalue->value.data, &pvalue->value.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            reqcnt++;
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_EDIPartyName (OSCTXT* pctxt, 
   ASN1T_IMP_EDIPartyName* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "EDIPartyName");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode nameAssigner */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "nameAssigner");

            stat = asn1D_EXP_DirectoryString (pctxt, &pvalue->nameAssigner, 
               ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.nameAssignerPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 1:
         /* decode partyName */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "partyName");

            stat = asn1D_EXP_DirectoryString (pctxt, &pvalue->partyName, 
               ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            reqcnt++;
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_GeneralName (OSCTXT* pctxt, 
   ASN1T_IMP_GeneralName* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "GeneralName");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         RTXCTXTPUSHELEMNAME (pctxt, "otherName");

         pvalue->u.otherName = rtxMemAllocType (pctxt, ASN1T_IMP_AnotherName);

         if (pvalue->u.otherName == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_IMP_AnotherName (pvalue->u.otherName);
         stat = asn1D_IMP_AnotherName (pctxt, pvalue->u.otherName, 
            ASN1IMPL, length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_PRIM|1):
         RTXCTXTPUSHELEMNAME (pctxt, "rfc822Name");

         stat = xd_charstr (pctxt, &pvalue->u.rfc822Name, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|22), length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_PRIM|2):
         RTXCTXTPUSHELEMNAME (pctxt, "dNSName");

         stat = xd_charstr (pctxt, &pvalue->u.dNSName, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|22), length);
         pvalue->t = 3;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|3):
         RTXCTXTPUSHELEMNAME (pctxt, "x400Address");

         pvalue->u.x400Address = rtxMemAllocType (pctxt, ASN1T_EXP_ORAddress);

         if (pvalue->u.x400Address == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_EXP_ORAddress (pvalue->u.x400Address);
         stat = asn1D_EXP_ORAddress (pctxt, pvalue->u.x400Address, 
            ASN1IMPL, length);
         pvalue->t = 4;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|4):
         RTXCTXTPUSHELEMNAME (pctxt, "directoryName");

         pvalue->u.directoryName = rtxMemAllocType (pctxt, ASN1T_EXP_Name);

         if (pvalue->u.directoryName == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_EXP_Name (pvalue->u.directoryName);
         stat = asn1D_EXP_Name (pctxt, pvalue->u.directoryName, 
            ASN1IMPL, length);
         pvalue->t = 5;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|5):
         RTXCTXTPUSHELEMNAME (pctxt, "ediPartyName");

         pvalue->u.ediPartyName = rtxMemAllocType (pctxt, 
            ASN1T_IMP_EDIPartyName);

         if (pvalue->u.ediPartyName == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_IMP_EDIPartyName (pvalue->u.ediPartyName);
         stat = asn1D_IMP_EDIPartyName (pctxt, pvalue->u.ediPartyName, 
            ASN1IMPL, length);
         pvalue->t = 6;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_PRIM|6):
         RTXCTXTPUSHELEMNAME (pctxt, "uniformResourceIdentifier");

         stat = xd_charstr (pctxt, &pvalue->u.uniformResourceIdentifier
            , ASN1IMPL, (TM_UNIV|TM_PRIM|22), length);
         pvalue->t = 7;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_PRIM|7):
         RTXCTXTPUSHELEMNAME (pctxt, "iPAddress");

         pvalue->u.iPAddress = rtxMemAllocType (pctxt, ASN1TDynOctStr);

         if (pvalue->u.iPAddress == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.iPAddress->numocts = 0;
         pvalue->u.iPAddress->data = 0;
         stat = xd_octstr (pctxt, &pvalue->u.iPAddress->data, &pvalue->u.iPAddress->numocts, ASN1IMPL, length);
         pvalue->t = 8;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_PRIM|8):
         RTXCTXTPUSHELEMNAME (pctxt, "registeredID");

         pvalue->u.registeredID = rtxMemAllocType (pctxt, ASN1TObjId);

         if (pvalue->u.registeredID == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.registeredID->numids = 0;
         stat = xd_objid (pctxt, (ASN1OBJID*)pvalue->u.registeredID, ASN1IMPL, length);
         pvalue->t = 9;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_GeneralNames (OSCTXT* pctxt, 
   ASN1T_IMP_GeneralNames* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_IMP_GeneralName* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "GeneralNames");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "GeneralName", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_IMP_GeneralName, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_IMP_GeneralName (pdata1);

      stat = asn1D_IMP_GeneralName (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_SubjectAltName (OSCTXT* pctxt, 
   ASN1T_IMP_SubjectAltName* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SubjectAltName");

   stat = asn1D_IMP_GeneralNames (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_KeyIdentifier (OSCTXT* pctxt, 
   ASN1T_IMP_KeyIdentifier* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "KeyIdentifier");

   stat = xd_octstr (pctxt, &pvalue->data, &pvalue->numocts, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_SubjectKeyIdentifier (OSCTXT* pctxt, 
   ASN1T_IMP_SubjectKeyIdentifier* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SubjectKeyIdentifier");

   stat = xd_octstr (pctxt, &pvalue->data, &pvalue->numocts, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_KeyUsage (OSCTXT* pctxt, ASN1T_IMP_KeyUsage* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "KeyUsage");

   pvalue->numbits = 9;
   stat = xd_bitstr_s (pctxt, pvalue->data, &pvalue->numbits, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_CertPolicyId (OSCTXT* pctxt, 
   ASN1T_IMP_CertPolicyId* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CertPolicyId");

   stat = xd_objid (pctxt, (ASN1OBJID*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_PolicyQualifierId (OSCTXT* pctxt, 
   ASN1T_IMP_PolicyQualifierId* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PolicyQualifierId");

   stat = xd_objid (pctxt, (ASN1OBJID*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_CPSuri (OSCTXT* pctxt, ASN1T_IMP_CPSuri* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CPSuri");

   stat = xd_charstr (pctxt, pvalue, tagging, (TM_UNIV|TM_PRIM|22), length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_KeyPurposeId (OSCTXT* pctxt, 
   ASN1T_IMP_KeyPurposeId* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "KeyPurposeId");

   stat = xd_objid (pctxt, (ASN1OBJID*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_ReasonFlags (OSCTXT* pctxt, 
   ASN1T_IMP_ReasonFlags* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ReasonFlags");

   pvalue->numbits = 9;
   stat = xd_bitstr_s (pctxt, pvalue->data, &pvalue->numbits, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_CRLNumber (OSCTXT* pctxt, ASN1T_IMP_CRLNumber* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CRLNumber");

   stat = xd_bigint (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_CRLReason (OSCTXT* pctxt, ASN1T_IMP_CRLReason* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CRLReason");

   stat = xd_enumUnsigned (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if(*pvalue > 10)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_BaseDistance (OSCTXT* pctxt, 
   ASN1T_IMP_BaseDistance* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BaseDistance");

   stat = xd_unsigned (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!(*pvalue >= 0)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, *pvalue);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_SkipCerts (OSCTXT* pctxt, ASN1T_IMP_SkipCerts* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SkipCerts");

   stat = xd_unsigned (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!(*pvalue >= 0)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddUIntParm (pctxt, *pvalue);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_InhibitAnyPolicy (OSCTXT* pctxt, 
   ASN1T_IMP_InhibitAnyPolicy* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "InhibitAnyPolicy");

   stat = asn1D_IMP_SkipCerts (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_DistributionPointName (OSCTXT* pctxt, 
   ASN1T_IMP_DistributionPointName* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "DistributionPointName");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_CTXT|TM_CONS|0):
         RTXCTXTPUSHELEMNAME (pctxt, "fullName");

         pvalue->u.fullName = rtxMemAllocType (pctxt, ASN1T_IMP_GeneralNames);

         if (pvalue->u.fullName == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_IMP_GeneralNames (pvalue->u.fullName);
         stat = asn1D_IMP_GeneralNames (pctxt, pvalue->u.fullName, 
            ASN1IMPL, length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|1):
         RTXCTXTPUSHELEMNAME (pctxt, "nameRelativeToCRLIssuer");

         pvalue->u.nameRelativeToCRLIssuer = rtxMemAllocType (pctxt, 
            ASN1T_EXP_RelativeDistinguishedName);

         if (pvalue->u.nameRelativeToCRLIssuer == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_EXP_RelativeDistinguishedName (pvalue->u.nameRelativeToCRLIssuer);
         stat = asn1D_EXP_RelativeDistinguishedName (pctxt, pvalue->
            u.nameRelativeToCRLIssuer, ASN1IMPL, length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_DistributionPoint (OSCTXT* pctxt, 
   ASN1T_IMP_DistributionPoint* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "DistributionPoint");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode distributionPoint */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "distributionPoint");

            stat = asn1D_IMP_DistributionPointName (pctxt, &pvalue->
               distributionPoint, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.distributionPointPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 1:
         /* decode reasons */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "reasons");

            stat = asn1D_IMP_ReasonFlags (pctxt, &pvalue->reasons, 
               ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.reasonsPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 2:
         /* decode cRLIssuer */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "cRLIssuer");

            stat = asn1D_IMP_GeneralNames (pctxt, &pvalue->cRLIssuer, 
               ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.cRLIssuerPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_CRLDistributionPoints (OSCTXT* pctxt, 
   ASN1T_IMP_CRLDistributionPoints* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_IMP_DistributionPoint* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "CRLDistributionPoints");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "DistributionPoint", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_IMP_DistributionPoint, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_IMP_DistributionPoint (pdata1);

      stat = asn1D_IMP_DistributionPoint (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_FreshestCRL (OSCTXT* pctxt, 
   ASN1T_IMP_FreshestCRL* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "FreshestCRL");

   stat = asn1D_IMP_CRLDistributionPoints (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_BaseCRLNumber (OSCTXT* pctxt, 
   ASN1T_IMP_BaseCRLNumber* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "BaseCRLNumber");

   stat = asn1D_IMP_CRLNumber (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_IssuerAltName (OSCTXT* pctxt, 
   ASN1T_IMP_IssuerAltName* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IssuerAltName");

   stat = asn1D_IMP_GeneralNames (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_HoldInstructionCode (OSCTXT* pctxt, 
   ASN1T_IMP_HoldInstructionCode* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "HoldInstructionCode");

   stat = xd_objid (pctxt, (ASN1OBJID*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_InvalidityDate (OSCTXT* pctxt, 
   ASN1T_IMP_InvalidityDate* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "InvalidityDate");

   stat = xd_charstr (pctxt, pvalue, tagging, (TM_UNIV|TM_PRIM|24), length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_CertificateIssuer (OSCTXT* pctxt, 
   ASN1T_IMP_CertificateIssuer* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CertificateIssuer");

   stat = asn1D_IMP_GeneralNames (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_AuthorityKeyIdentifier (OSCTXT* pctxt, 
   ASN1T_IMP_AuthorityKeyIdentifier* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "AuthorityKeyIdentifier");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode keyIdentifier */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "keyIdentifier");

            stat = asn1D_IMP_KeyIdentifier (pctxt, &pvalue->keyIdentifier, 
               ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.keyIdentifierPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 1:
         /* decode authorityCertIssuer */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "authorityCertIssuer");

            stat = asn1D_IMP_GeneralNames (pctxt, &pvalue->authorityCertIssuer
               , ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.authorityCertIssuerPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 2:
         /* decode authorityCertSerialNumber */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "authorityCertSerialNumber");

            stat = asn1D_EXP_CertificateSerialNumber (pctxt, &pvalue->
               authorityCertSerialNumber, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.authorityCertSerialNumberPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_PolicyQualifierInfo (OSCTXT* pctxt, 
   ASN1T_IMP_PolicyQualifierInfo* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "PolicyQualifierInfo");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode policyQualifierId */
         RTXCTXTPUSHELEMNAME (pctxt, "policyQualifierId");

         stat = asn1D_IMP_PolicyQualifierId (pctxt, &pvalue->policyQualifierId
            , ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode qualifier */
         RTXCTXTPUSHELEMNAME (pctxt, "qualifier");

         stat = xd_OpenType (pctxt, &pvalue->qualifier.data, &pvalue->qualifier.numocts);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_PolicyInformation_policyQualifiers (OSCTXT* pctxt, 
   ASN1T_IMP_PolicyInformation_policyQualifiers* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1T_IMP_PolicyQualifierInfo* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PolicyQualifierInfo", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_IMP_PolicyQualifierInfo, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_IMP_PolicyQualifierInfo (pdata1);

      stat = asn1D_IMP_PolicyQualifierInfo (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

EXTERN int asn1D_IMP_PolicyInformation (OSCTXT* pctxt, 
   ASN1T_IMP_PolicyInformation* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "PolicyInformation");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode policyIdentifier */
         RTXCTXTPUSHELEMNAME (pctxt, "policyIdentifier");

         stat = asn1D_IMP_CertPolicyId (pctxt, &pvalue->policyIdentifier, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode policyQualifiers */
         if (XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "policyQualifiers");

            stat = asn1D_IMP_PolicyInformation_policyQualifiers (pctxt, &pvalue
               ->policyQualifiers, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.policyQualifiersPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|6):
         case (TM_UNIV|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_CertificatePolicies (OSCTXT* pctxt, 
   ASN1T_IMP_CertificatePolicies* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_IMP_PolicyInformation* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "CertificatePolicies");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PolicyInformation", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_IMP_PolicyInformation, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_IMP_PolicyInformation (pdata1);

      stat = asn1D_IMP_PolicyInformation (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_DisplayText (OSCTXT* pctxt, 
   ASN1T_IMP_DisplayText* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "DisplayText");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_UNIV|TM_PRIM|12):
         RTXCTXTPUSHELEMNAME (pctxt, "utf8String");

         stat = xd_utf8str (pctxt, &pvalue->u.utf8String, ASN1IMPL, length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { int nchars = rtxUTF8Len (pvalue->u.utf8String);
         if (!((nchars >= 1 && nchars <= 200))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|22):
         RTXCTXTPUSHELEMNAME (pctxt, "ia5String");

         stat = xd_charstr (pctxt, &pvalue->u.ia5String, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|22), length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.ia5String);
         if (!((nchars >= 1 && nchars <= 200))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|26):
         RTXCTXTPUSHELEMNAME (pctxt, "visibleString");

         stat = xd_charstr (pctxt, &pvalue->u.visibleString, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|26), length);
         pvalue->t = 3;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.visibleString);
         if (!((nchars >= 1 && nchars <= 200))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|30):
         RTXCTXTPUSHELEMNAME (pctxt, "bmpString");

         pvalue->u.bmpString = rtxMemAllocType (pctxt, ASN1TBMPString);

         if (pvalue->u.bmpString == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.bmpString->nchars = 0;
         stat = xd_16BitCharStr (pctxt,
            pvalue->u.bmpString,
            ASN1IMPL, (TM_UNIV|TM_PRIM|30), length);
         pvalue->t = 4;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         if (!((pvalue->u.bmpString->nchars >= 1 && pvalue->u.bmpString->nchars <= 200
            ))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)pvalue->u.bmpString->nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_NoticeReference_noticeNumbers (OSCTXT* pctxt, 
   ASN1T_IMP_NoticeReference_noticeNumbers* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   OSINT32* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "INTEGER", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, OSINT32, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_integer (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1D_IMP_NoticeReference (OSCTXT* pctxt, 
   ASN1T_IMP_NoticeReference* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "NoticeReference");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode organization */
         RTXCTXTPUSHELEMNAME (pctxt, "organization");

         stat = asn1D_IMP_DisplayText (pctxt, &pvalue->organization, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode noticeNumbers */
         RTXCTXTPUSHELEMNAME (pctxt, "noticeNumbers");

         stat = asn1D_IMP_NoticeReference_noticeNumbers (pctxt, &pvalue->
            noticeNumbers, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|12):
         case (TM_UNIV|TM_PRIM|22):
         case (TM_UNIV|TM_PRIM|26):
         case (TM_UNIV|TM_PRIM|30):
         case (TM_UNIV|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_UserNotice (OSCTXT* pctxt, ASN1T_IMP_UserNotice* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "UserNotice");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode noticeRef */
         if (XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "noticeRef");

            stat = asn1D_IMP_NoticeReference (pctxt, &pvalue->noticeRef, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.noticeRefPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 1:
         /* decode explicitText */
         if (XD_PEEKTAG (pctxt, 0xc)
         || XD_PEEKTAG (pctxt, 0x16)
         || XD_PEEKTAG (pctxt, 0x1a)
         || XD_PEEKTAG (pctxt, 0x1e)) {
            RTXCTXTPUSHELEMNAME (pctxt, "explicitText");

            stat = asn1D_IMP_DisplayText (pctxt, &pvalue->explicitText, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.explicitTextPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_CONS|16):
         case (TM_UNIV|TM_PRIM|12):
         case (TM_UNIV|TM_PRIM|22):
         case (TM_UNIV|TM_PRIM|26):
         case (TM_UNIV|TM_PRIM|30):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_Qualifier (OSCTXT* pctxt, ASN1T_IMP_Qualifier* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "Qualifier");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_UNIV|TM_CONS|16):
         RTXCTXTPUSHELEMNAME (pctxt, "userNotice");

         pvalue->u.userNotice = rtxMemAllocType (pctxt, ASN1T_IMP_UserNotice);

         if (pvalue->u.userNotice == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_IMP_UserNotice (pvalue->u.userNotice);
         stat = asn1D_IMP_UserNotice (pctxt, pvalue->u.userNotice, 
            ASN1IMPL, length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|22):
         RTXCTXTPUSHELEMNAME (pctxt, "cPSuri");

         stat = asn1D_IMP_CPSuri (pctxt, &pvalue->u.cPSuri, ASN1IMPL, length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_PolicyMappings_element (OSCTXT* pctxt, 
   ASN1T_IMP_PolicyMappings_element* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode issuerDomainPolicy */
         RTXCTXTPUSHELEMNAME (pctxt, "issuerDomainPolicy");

         stat = asn1D_IMP_CertPolicyId (pctxt, &pvalue->issuerDomainPolicy, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode subjectDomainPolicy */
         RTXCTXTPUSHELEMNAME (pctxt, "subjectDomainPolicy");

         stat = asn1D_IMP_CertPolicyId (pctxt, &pvalue->subjectDomainPolicy, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   return (stat);
}

EXTERN int asn1D_IMP_PolicyMappings (OSCTXT* pctxt, 
   ASN1T_IMP_PolicyMappings* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_IMP_PolicyMappings_element* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "PolicyMappings");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_IMP_PolicyMappings_element, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_IMP_PolicyMappings_element (pdata1);

      stat = asn1D_IMP_PolicyMappings_element (pctxt, pdata1, 
         ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_BasicConstraints (OSCTXT* pctxt, 
   ASN1T_IMP_BasicConstraints* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "BasicConstraints");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
      pvalue->cA = FALSE;
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode cA */
         if (XD_PEEKTAG (pctxt, 0x1)) {
            RTXCTXTPUSHELEMNAME (pctxt, "cA");

            stat = xd_boolean (pctxt, &pvalue->cA, ASN1EXPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 1:
         /* decode pathLenConstraint */
         if (XD_PEEKTAG (pctxt, 0x2)) {
            RTXCTXTPUSHELEMNAME (pctxt, "pathLenConstraint");

            stat = xd_unsigned (pctxt, &pvalue->pathLenConstraint, ASN1EXPL, length);
            if (stat == 0) {
               if (!(pvalue->pathLenConstraint >= 0)) {
                  rtxErrAddElemNameParm (pctxt);
                  rtxErrAddUIntParm (pctxt, pvalue->pathLenConstraint);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

               pvalue->m.pathLenConstraintPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|1):
         case (TM_UNIV|TM_PRIM|2):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_ExtKeyUsageSyntax (OSCTXT* pctxt, 
   ASN1T_IMP_ExtKeyUsageSyntax* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_IMP_KeyPurposeId* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "ExtKeyUsageSyntax");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "KeyPurposeId", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_IMP_KeyPurposeId, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_IMP_KeyPurposeId (pdata1);

      stat = asn1D_IMP_KeyPurposeId (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_AccessDescription (OSCTXT* pctxt, 
   ASN1T_IMP_AccessDescription* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "AccessDescription");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode accessMethod */
         RTXCTXTPUSHELEMNAME (pctxt, "accessMethod");

         stat = xd_objid (pctxt, (ASN1OBJID*)&pvalue->accessMethod, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode accessLocation */
         RTXCTXTPUSHELEMNAME (pctxt, "accessLocation");

         stat = asn1D_IMP_GeneralName (pctxt, &pvalue->accessLocation, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|6):
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_AuthorityInfoAccessSyntax (OSCTXT* pctxt, 
   ASN1T_IMP_AuthorityInfoAccessSyntax* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1T_IMP_AccessDescription* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "AuthorityInfoAccessSyntax");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "AccessDescription", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_IMP_AccessDescription, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_IMP_AccessDescription (pdata1);

      stat = asn1D_IMP_AccessDescription (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_SubjectInfoAccessSyntax (OSCTXT* pctxt, 
   ASN1T_IMP_SubjectInfoAccessSyntax* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_IMP_AccessDescription* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "SubjectInfoAccessSyntax");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "AccessDescription", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_IMP_AccessDescription, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_IMP_AccessDescription (pdata1);

      stat = asn1D_IMP_AccessDescription (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_SubjectDirectoryAttributes (OSCTXT* pctxt, 
   ASN1T_IMP_SubjectDirectoryAttributes* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1T_EXP_Attribute* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "SubjectDirectoryAttributes");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "Attribute", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_EXP_Attribute, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EXP_Attribute (pdata1);

      stat = asn1D_EXP_Attribute (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_RoleSyntax (OSCTXT* pctxt, ASN1T_IMP_RoleSyntax* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "RoleSyntax");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode roleAuthority */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "roleAuthority");

            stat = asn1D_IMP_GeneralNames (pctxt, &pvalue->roleAuthority, 
               ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.roleAuthorityPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 1:
         /* decode roleName */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "roleName");

            stat = asn1D_IMP_GeneralName (pctxt, &pvalue->roleName, 
               ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            reqcnt++;
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_GeneralSubtree (OSCTXT* pctxt, 
   ASN1T_IMP_GeneralSubtree* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "GeneralSubtree");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
      pvalue->minimum = 0;
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode base */
         RTXCTXTPUSHELEMNAME (pctxt, "base");

         stat = asn1D_IMP_GeneralName (pctxt, &pvalue->base, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode minimum */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "minimum");

            stat = asn1D_IMP_BaseDistance (pctxt, &pvalue->minimum, 
               ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 2:
         /* decode maximum */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "maximum");

            stat = asn1D_IMP_BaseDistance (pctxt, &pvalue->maximum, 
               ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.maximumPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
         case (TM_CTXT|TM_CONS|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_PRIM|6):
         case (TM_CTXT|TM_PRIM|7):
         case (TM_CTXT|TM_PRIM|8):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_GeneralSubtrees (OSCTXT* pctxt, 
   ASN1T_IMP_GeneralSubtrees* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_IMP_GeneralSubtree* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "GeneralSubtrees");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "GeneralSubtree", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_IMP_GeneralSubtree, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_IMP_GeneralSubtree (pdata1);

      stat = asn1D_IMP_GeneralSubtree (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_NameConstraints (OSCTXT* pctxt, 
   ASN1T_IMP_NameConstraints* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "NameConstraints");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode permittedSubtrees */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "permittedSubtrees");

            stat = asn1D_IMP_GeneralSubtrees (pctxt, &pvalue->permittedSubtrees
               , ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.permittedSubtreesPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 1:
         /* decode excludedSubtrees */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "excludedSubtrees");

            stat = asn1D_IMP_GeneralSubtrees (pctxt, &pvalue->excludedSubtrees
               , ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.excludedSubtreesPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_PolicyConstraints (OSCTXT* pctxt, 
   ASN1T_IMP_PolicyConstraints* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "PolicyConstraints");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode requireExplicitPolicy */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "requireExplicitPolicy");

            stat = asn1D_IMP_SkipCerts (pctxt, &pvalue->requireExplicitPolicy, 
               ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.requireExplicitPolicyPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 1:
         /* decode inhibitPolicyMapping */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "inhibitPolicyMapping");

            stat = asn1D_IMP_SkipCerts (pctxt, &pvalue->inhibitPolicyMapping, 
               ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.inhibitPolicyMappingPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_IMP_IssuingDistributionPoint (OSCTXT* pctxt, 
   ASN1T_IMP_IssuingDistributionPoint* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "IssuingDistributionPoint");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
      pvalue->onlyContainsUserCerts = FALSE;
      pvalue->onlyContainsCACerts = FALSE;
      pvalue->indirectCRL = FALSE;
      pvalue->onlyContainsAttributeCerts = FALSE;
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode distributionPoint */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "distributionPoint");

            stat = asn1D_IMP_DistributionPointName (pctxt, &pvalue->
               distributionPoint, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.distributionPointPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 1:
         /* decode onlyContainsUserCerts */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "onlyContainsUserCerts");

            stat = xd_boolean (pctxt, &pvalue->onlyContainsUserCerts, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 2:
         /* decode onlyContainsCACerts */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "onlyContainsCACerts");

            stat = xd_boolean (pctxt, &pvalue->onlyContainsCACerts, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 3:
         /* decode onlySomeReasons */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "onlySomeReasons");

            stat = asn1D_IMP_ReasonFlags (pctxt, &pvalue->onlySomeReasons, 
               ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.onlySomeReasonsPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 4:
         /* decode indirectCRL */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "indirectCRL");

            stat = xd_boolean (pctxt, &pvalue->indirectCRL, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 5:
         /* decode onlyContainsAttributeCerts */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "onlyContainsAttributeCerts");

            stat = xd_boolean (pctxt, &pvalue->onlyContainsAttributeCerts, ASN1IMPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_PRIM|5):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

