/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.6, Date: 28-Feb-2014.
 */
#include "attrcert.h"
#include "rtxsrc/rtxCommon.h"

EXTERN int asn1E_ATTRCERT_AttCertVersion (OSCTXT* pctxt,
   ASN1T_ATTRCERT_AttCertVersion *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AttCertVersion");

   ll = xe_integer (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_ATTRCERT_ClassList (OSCTXT* pctxt,
   ASN1T_ATTRCERT_ClassList *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ClassList");

   ll = derEncBitString (pctxt, pvalue->data, pvalue->numbits, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_ATTRCERT_AttCertVersionV1 (OSCTXT* pctxt,
   ASN1T_ATTRCERT_AttCertVersionV1 *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AttCertVersionV1");

   ll = xe_integer (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_ATTRCERT_ObjectDigestInfo_digestedObjectType (OSCTXT* pctxt,
   ASN1T_ATTRCERT_ObjectDigestInfo_digestedObjectType *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;

   if(*pvalue > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = xe_enumUnsigned (pctxt, pvalue, tagging);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll0 += ll;

   return (ll0);
}

EXTERN int asn1E_ATTRCERT_IssuerSerial (OSCTXT* pctxt,
   ASN1T_ATTRCERT_IssuerSerial *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IssuerSerial");

   /* encode issuerUID */

   if (pvalue->m.issuerUIDPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "issuerUID");

      ll = asn1E_EXP_UniqueIdentifier (pctxt, &pvalue->issuerUID, ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode serial */

   RTXCTXTPUSHELEMNAME (pctxt, "serial");

   ll = asn1E_EXP_CertificateSerialNumber (pctxt, &pvalue->serial, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode issuer */

   RTXCTXTPUSHELEMNAME (pctxt, "issuer");

   ll = asn1E_IMP_GeneralNames (pctxt, &pvalue->issuer, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_ATTRCERT_ObjectDigestInfo (OSCTXT* pctxt,
   ASN1T_ATTRCERT_ObjectDigestInfo *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ObjectDigestInfo");

   /* encode objectDigest */

   RTXCTXTPUSHELEMNAME (pctxt, "objectDigest");

   ll = xe_bitstr (pctxt, pvalue->objectDigest.data, pvalue->objectDigest.numbits, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode digestAlgorithm */

   RTXCTXTPUSHELEMNAME (pctxt, "digestAlgorithm");

   ll = asn1E_EXP_AlgorithmIdentifier (pctxt, &pvalue->digestAlgorithm, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode otherObjectTypeID */

   if (pvalue->m.otherObjectTypeIDPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "otherObjectTypeID");

      ll = xe_objid (pctxt, (ASN1OBJID*)&pvalue->otherObjectTypeID, ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode digestedObjectType */

   RTXCTXTPUSHELEMNAME (pctxt, "digestedObjectType");

   if(pvalue->digestedObjectType > 2)
      return LOG_RTERR (pctxt, RTERR_INVENUM);

   ll = asn1E_ATTRCERT_ObjectDigestInfo_digestedObjectType (pctxt, &pvalue->digestedObjectType, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_ATTRCERT_Holder (OSCTXT* pctxt,
   ASN1T_ATTRCERT_Holder *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Holder");

   /* encode objectDigestInfo */

   if (pvalue->m.objectDigestInfoPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "objectDigestInfo");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_ATTRCERT_ObjectDigestInfo (pctxt, &pvalue->objectDigestInfo, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode entityName */

   if (pvalue->m.entityNamePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "entityName");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_IMP_GeneralNames (pctxt, &pvalue->entityName, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode baseCertificateID */

   if (pvalue->m.baseCertificateIDPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "baseCertificateID");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_ATTRCERT_IssuerSerial (pctxt, &pvalue->baseCertificateID, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_ATTRCERT_V2Form (OSCTXT* pctxt,
   ASN1T_ATTRCERT_V2Form *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "V2Form");

   /* encode objectDigestInfo */

   if (pvalue->m.objectDigestInfoPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "objectDigestInfo");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ATTRCERT_ObjectDigestInfo (pctxt, &pvalue->objectDigestInfo, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode baseCertificateID */

   if (pvalue->m.baseCertificateIDPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "baseCertificateID");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_ATTRCERT_IssuerSerial (pctxt, &pvalue->baseCertificateID, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode issuerName */

   if (pvalue->m.issuerNamePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "issuerName");

      ll = asn1E_IMP_GeneralNames (pctxt, &pvalue->issuerName, ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_ATTRCERT_AttCertIssuer (OSCTXT* pctxt,
   ASN1T_ATTRCERT_AttCertIssuer *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AttCertIssuer");

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "v1Form");

         ll = asn1E_IMP_GeneralNames (pctxt, pvalue->u.v1Form, ASN1EXPL);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "v2Form");

         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_ATTRCERT_V2Form (pctxt, pvalue->u.v2Form, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         rtxErrAddIntParm (pctxt, pvalue->t);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_ATTRCERT_AttCertValidityPeriod (OSCTXT* pctxt,
   ASN1T_ATTRCERT_AttCertValidityPeriod *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AttCertValidityPeriod");

   /* encode notAfterTime */

   RTXCTXTPUSHELEMNAME (pctxt, "notAfterTime");

   ll = xe_charstr (pctxt, pvalue->notAfterTime, ASN1EXPL, TM_UNIV|TM_PRIM|24);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode notBeforeTime */

   RTXCTXTPUSHELEMNAME (pctxt, "notBeforeTime");

   ll = xe_charstr (pctxt, pvalue->notBeforeTime, ASN1EXPL, TM_UNIV|TM_PRIM|24);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_ATTRCERT__SeqOfATTRCERT_Attribute (OSCTXT* pctxt,
   ASN1T_ATTRCERT__SeqOfATTRCERT_Attribute *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode;
   int xx1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   xx1 = (int)pvalue->count;
   pnode = pvalue->tail;
   while (0 != pnode) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "Attribute", xx1);

      ll = asn1E_EXP_Attribute (pctxt, ((ASN1T_EXP_Attribute*)pnode->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      xx1--;

      pnode = pnode->prev;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

EXTERN int asn1E_ATTRCERT_AttributeCertificateInfo (OSCTXT* pctxt,
   ASN1T_ATTRCERT_AttributeCertificateInfo *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AttributeCertificateInfo");

   /* encode extensions */

   if (pvalue->m.extensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "extensions");

      ll = asn1E_EXP_Extensions (pctxt, &pvalue->extensions, ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode issuerUniqueID */

   if (pvalue->m.issuerUniqueIDPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "issuerUniqueID");

      ll = asn1E_EXP_UniqueIdentifier (pctxt, &pvalue->issuerUniqueID, ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode attributes */

   RTXCTXTPUSHELEMNAME (pctxt, "attributes");

   ll = asn1E_ATTRCERT__SeqOfATTRCERT_Attribute (pctxt, &pvalue->attributes, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode attrCertValidityPeriod */

   RTXCTXTPUSHELEMNAME (pctxt, "attrCertValidityPeriod");

   ll = asn1E_ATTRCERT_AttCertValidityPeriod (pctxt, &pvalue->attrCertValidityPeriod, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode serialNumber */

   RTXCTXTPUSHELEMNAME (pctxt, "serialNumber");

   ll = asn1E_EXP_CertificateSerialNumber (pctxt, &pvalue->serialNumber, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode signature_ */

   RTXCTXTPUSHELEMNAME (pctxt, "signature");

   ll = asn1E_EXP_AlgorithmIdentifier (pctxt, &pvalue->signature_, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode issuer */

   RTXCTXTPUSHELEMNAME (pctxt, "issuer");

   ll = asn1E_ATTRCERT_AttCertIssuer (pctxt, &pvalue->issuer, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode holder */

   RTXCTXTPUSHELEMNAME (pctxt, "holder");

   ll = asn1E_ATTRCERT_Holder (pctxt, &pvalue->holder, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode version */

   RTXCTXTPUSHELEMNAME (pctxt, "version");

   ll = asn1E_ATTRCERT_AttCertVersion (pctxt, &pvalue->version, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_ATTRCERT_AttributeCertificate (OSCTXT* pctxt,
   ASN1T_ATTRCERT_AttributeCertificate *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AttributeCertificate");

   /* encode signatureValue */

   RTXCTXTPUSHELEMNAME (pctxt, "signatureValue");

   ll = xe_bitstr (pctxt, pvalue->signatureValue.data, pvalue->signatureValue.numbits, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode signatureAlgorithm */

   RTXCTXTPUSHELEMNAME (pctxt, "signatureAlgorithm");

   ll = asn1E_EXP_AlgorithmIdentifier (pctxt, &pvalue->signatureAlgorithm, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode acinfo */

   RTXCTXTPUSHELEMNAME (pctxt, "acinfo");

   ll = asn1E_ATTRCERT_AttributeCertificateInfo (pctxt, &pvalue->acinfo, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_ATTRCERT_TargetCert (OSCTXT* pctxt,
   ASN1T_ATTRCERT_TargetCert *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TargetCert");

   /* encode certDigestInfo */

   if (pvalue->m.certDigestInfoPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "certDigestInfo");

      ll = asn1E_ATTRCERT_ObjectDigestInfo (pctxt, &pvalue->certDigestInfo, ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode targetName */

   if (pvalue->m.targetNamePresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "targetName");

      ll = asn1E_IMP_GeneralName (pctxt, &pvalue->targetName, ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode targetCertificate */

   RTXCTXTPUSHELEMNAME (pctxt, "targetCertificate");

   ll = asn1E_ATTRCERT_IssuerSerial (pctxt, &pvalue->targetCertificate, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_ATTRCERT_Target (OSCTXT* pctxt,
   ASN1T_ATTRCERT_Target *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Target");

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "targetName");

         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_IMP_GeneralName (pctxt, pvalue->u.targetName, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "targetGroup");

         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_IMP_GeneralName (pctxt, pvalue->u.targetGroup, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "targetCert");

         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
            asn1E_ATTRCERT_TargetCert (pctxt, pvalue->u.targetCert, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         rtxErrAddIntParm (pctxt, pvalue->t);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_ATTRCERT_Targets (OSCTXT* pctxt,
   ASN1T_ATTRCERT_Targets *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode;
   int xx1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Targets");

   xx1 = (int)pvalue->count;
   pnode = pvalue->tail;
   while (0 != pnode) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "Target", xx1);

      ll = asn1E_ATTRCERT_Target (pctxt, ((ASN1T_ATTRCERT_Target*)pnode->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      xx1--;

      pnode = pnode->prev;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_ATTRCERT_IetfAttrSyntax_values_element (OSCTXT* pctxt,
   ASN1T_ATTRCERT_IetfAttrSyntax_values_element *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "octets");

         ll = xe_octstr (pctxt, pvalue->u.octets->data, pvalue->u.octets->numocts, ASN1EXPL);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "oid");

         ll = xe_objid (pctxt, (ASN1OBJID*)pvalue->u.oid, ASN1EXPL);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case 3:
         RTXCTXTPUSHELEMNAME (pctxt, "string");

         ll = xe_utf8str (pctxt, pvalue->u.string, ASN1EXPL);
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         rtxErrAddIntParm (pctxt, pvalue->t);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

EXTERN int asn1E_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element (OSCTXT* pctxt,
   ASN1T_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode;
   int xx1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   xx1 = (int)pvalue->count;
   pnode = pvalue->tail;
   while (0 != pnode) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "CHOICE", xx1);

      ll = asn1E_ATTRCERT_IetfAttrSyntax_values_element (pctxt, ((ASN1T_ATTRCERT_IetfAttrSyntax_values_element*)pnode->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      xx1--;

      pnode = pnode->prev;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   return (ll0);
}

EXTERN int asn1E_ATTRCERT_IetfAttrSyntax (OSCTXT* pctxt,
   ASN1T_ATTRCERT_IetfAttrSyntax *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "IetfAttrSyntax");

   /* encode values */

   RTXCTXTPUSHELEMNAME (pctxt, "values");

   ll = asn1E_ATTRCERT__SeqOfATTRCERT_IetfAttrSyntax_values_element (pctxt, &pvalue->values, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode policyAuthority */

   if (pvalue->m.policyAuthorityPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "policyAuthority");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_IMP_GeneralNames (pctxt, &pvalue->policyAuthority, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_ATTRCERT_SvceAuthInfo (OSCTXT* pctxt,
   ASN1T_ATTRCERT_SvceAuthInfo *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SvceAuthInfo");

   /* encode authInfo */

   if (pvalue->m.authInfoPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "authInfo");

      ll = xe_octstr (pctxt, pvalue->authInfo.data, pvalue->authInfo.numocts, ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode ident */

   RTXCTXTPUSHELEMNAME (pctxt, "ident");

   ll = asn1E_IMP_GeneralName (pctxt, &pvalue->ident, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode service */

   RTXCTXTPUSHELEMNAME (pctxt, "service");

   ll = asn1E_IMP_GeneralName (pctxt, &pvalue->service, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_ATTRCERT_RoleSyntax (OSCTXT* pctxt,
   ASN1T_ATTRCERT_RoleSyntax *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "RoleSyntax");

   /* encode roleName */

   RTXCTXTPUSHELEMNAME (pctxt, "roleName");

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      asn1E_IMP_GeneralName (pctxt, &pvalue->roleName, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode roleAuthority */

   if (pvalue->m.roleAuthorityPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "roleAuthority");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_IMP_GeneralNames (pctxt, &pvalue->roleAuthority, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_ATTRCERT_SecurityCategory (OSCTXT* pctxt,
   ASN1T_ATTRCERT_SecurityCategory *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "SecurityCategory");

   /* encode value */

   RTXCTXTPUSHELEMNAME (pctxt, "value");

   ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
      xe_OpenType (pctxt, pvalue->value.data, pvalue->value.numocts));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode type */

   RTXCTXTPUSHELEMNAME (pctxt, "type");

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_objid (pctxt, (ASN1OBJID*)&pvalue->type, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_ATTRCERT__SetOfATTRCERT_SecurityCategory (OSCTXT* pctxt,
   ASN1T_ATTRCERT__SetOfATTRCERT_SecurityCategory *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode;
   int xx1;
   Asn1BufLocDescr* pbuf;
   OSRTSList elemList;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   rtxSListInitEx (pctxt, &elemList);

   xx1 = (int)pvalue->count;
   pnode = pvalue->tail;
   while (0 != pnode) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SecurityCategory", xx1);

      ll = asn1E_ATTRCERT_SecurityCategory (pctxt, ((ASN1T_ATTRCERT_SecurityCategory*)pnode->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      xx1--;

      pbuf = rtxMemAllocType (pctxt, Asn1BufLocDescr);
      xe_getBufLocDescr (pctxt, ll, pbuf);
      rtxSListAppend (&elemList, pbuf);

      pnode = pnode->prev;
   }

   ll1 = xe_derCanonicalSort (pctxt, &elemList);
   if (ll1 < 0) return LOG_RTERR (pctxt, ll1);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|17, ll0);

   return (ll0);
}

EXTERN int asn1E_ATTRCERT_Clearance (OSCTXT* pctxt,
   ASN1T_ATTRCERT_Clearance *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Clearance");

   /* encode securityCategories */

   if (pvalue->m.securityCategoriesPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "securityCategories");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|2,
         asn1E_ATTRCERT__SetOfATTRCERT_SecurityCategory (pctxt, &pvalue->securityCategories, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode classList */

   if (pvalue->m.classListPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "classList");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|1,
         asn1E_ATTRCERT_ClassList (pctxt, &pvalue->classList, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode policyId */

   RTXCTXTPUSHELEMNAME (pctxt, "policyId");

   ll = xe_tag_len (pctxt, TM_CTXT|TM_PRIM|0,
      xe_objid (pctxt, (ASN1OBJID*)&pvalue->policyId, ASN1IMPL));
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_ATTRCERT_AttrSpec (OSCTXT* pctxt,
   ASN1T_ATTRCERT_AttrSpec *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode;
   int xx1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AttrSpec");

   xx1 = (int)pvalue->count;
   pnode = pvalue->tail;
   while (0 != pnode) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "OBJECT_IDENTIFIER", xx1);

      ll = xe_objid (pctxt, (ASN1OBJID*)((ASN1TObjId*)pnode->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      xx1--;

      pnode = pnode->prev;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_ATTRCERT_AAControls (OSCTXT* pctxt,
   ASN1T_ATTRCERT_AAControls *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AAControls");

   /* encode permitUnSpecified */

   if (pvalue->permitUnSpecified != TRUE) {
      RTXCTXTPUSHELEMNAME (pctxt, "permitUnSpecified");

      ll = xe_boolean (pctxt, &pvalue->permitUnSpecified, ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode excludedAttrs */

   if (pvalue->m.excludedAttrsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "excludedAttrs");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
         asn1E_ATTRCERT_AttrSpec (pctxt, &pvalue->excludedAttrs, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode permittedAttrs */

   if (pvalue->m.permittedAttrsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "permittedAttrs");

      ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
         asn1E_ATTRCERT_AttrSpec (pctxt, &pvalue->permittedAttrs, ASN1IMPL));
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode pathLenConstraint */

   if (pvalue->m.pathLenConstraintPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "pathLenConstraint");

      if (!(pvalue->pathLenConstraint >= 0)) {
         rtxErrAddElemNameParm (pctxt);
         rtxErrAddUIntParm (pctxt, pvalue->pathLenConstraint);
         return LOG_RTERR (pctxt, RTERR_CONSVIO);
      }

      ll = xe_unsigned (pctxt, &pvalue->pathLenConstraint, ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_ATTRCERT_ACClearAttrs (OSCTXT* pctxt,
   ASN1T_ATTRCERT_ACClearAttrs *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ACClearAttrs");

   /* encode attrs */

   RTXCTXTPUSHELEMNAME (pctxt, "attrs");

   ll = asn1E_ATTRCERT__SeqOfATTRCERT_Attribute (pctxt, &pvalue->attrs, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode acSerial */

   RTXCTXTPUSHELEMNAME (pctxt, "acSerial");

   ll = xe_integer (pctxt, &pvalue->acSerial, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode acIssuer */

   RTXCTXTPUSHELEMNAME (pctxt, "acIssuer");

   ll = asn1E_IMP_GeneralName (pctxt, &pvalue->acIssuer, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_ATTRCERT_ProxyInfo (OSCTXT* pctxt,
   ASN1T_ATTRCERT_ProxyInfo *pvalue, ASN1TagType tagging)
{
   OSRTDListNode* pnode;
   int xx1;
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ProxyInfo");

   xx1 = (int)pvalue->count;
   pnode = pvalue->tail;
   while (0 != pnode) {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "Targets", xx1);

      ll = asn1E_ATTRCERT_Targets (pctxt, ((ASN1T_ATTRCERT_Targets*)pnode->data), ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      xx1--;

      pnode = pnode->prev;
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_ATTRCERT_AttributeCertificateInfoV1_subject (OSCTXT* pctxt,
   ASN1T_ATTRCERT_AttributeCertificateInfoV1_subject *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   ll0 = 0;
   switch (pvalue->t)
   {
      case 1:
         RTXCTXTPUSHELEMNAME (pctxt, "baseCertificateID");

         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|0,
            asn1E_ATTRCERT_IssuerSerial (pctxt, pvalue->u.baseCertificateID, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case 2:
         RTXCTXTPUSHELEMNAME (pctxt, "subjectName");

         ll = xe_tag_len (pctxt, TM_CTXT|TM_CONS|1,
            asn1E_IMP_GeneralNames (pctxt, pvalue->u.subjectName, ASN1IMPL));
         if (ll < 0) return LOG_RTERR (pctxt, ll);
         ll1 += ll;

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         rtxErrAddIntParm (pctxt, pvalue->t);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }
   ll0 += ll1;

   return (ll0);
}

EXTERN int asn1E_ATTRCERT_AttributeCertificateInfoV1 (OSCTXT* pctxt,
   ASN1T_ATTRCERT_AttributeCertificateInfoV1 *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AttributeCertificateInfoV1");

   /* encode extensions */

   if (pvalue->m.extensionsPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "extensions");

      ll = asn1E_EXP_Extensions (pctxt, &pvalue->extensions, ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode issuerUniqueID */

   if (pvalue->m.issuerUniqueIDPresent) {
      RTXCTXTPUSHELEMNAME (pctxt, "issuerUniqueID");

      ll = asn1E_EXP_UniqueIdentifier (pctxt, &pvalue->issuerUniqueID, ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   /* encode attributes */

   RTXCTXTPUSHELEMNAME (pctxt, "attributes");

   ll = asn1E_ATTRCERT__SeqOfATTRCERT_Attribute (pctxt, &pvalue->attributes, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode attCertValidityPeriod */

   RTXCTXTPUSHELEMNAME (pctxt, "attCertValidityPeriod");

   ll = asn1E_ATTRCERT_AttCertValidityPeriod (pctxt, &pvalue->attCertValidityPeriod, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode serialNumber */

   RTXCTXTPUSHELEMNAME (pctxt, "serialNumber");

   ll = asn1E_EXP_CertificateSerialNumber (pctxt, &pvalue->serialNumber, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode signature_ */

   RTXCTXTPUSHELEMNAME (pctxt, "signature");

   ll = asn1E_EXP_AlgorithmIdentifier (pctxt, &pvalue->signature_, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode issuer */

   RTXCTXTPUSHELEMNAME (pctxt, "issuer");

   ll = asn1E_IMP_GeneralNames (pctxt, &pvalue->issuer, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode subject */

   RTXCTXTPUSHELEMNAME (pctxt, "subject");

   ll = asn1E_ATTRCERT_AttributeCertificateInfoV1_subject (pctxt, &pvalue->subject, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode version */

   if (pvalue->version != ATTRCERT_AttCertVersionV1::v1) {
      RTXCTXTPUSHELEMNAME (pctxt, "version");

      ll = asn1E_ATTRCERT_AttCertVersionV1 (pctxt, &pvalue->version, ASN1EXPL);
      if (ll < 0) return LOG_RTERR (pctxt, ll);
      ll1 += ll;

      RTXCTXTPOPELEMNAME (pctxt);
   }
   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

EXTERN int asn1E_ATTRCERT_AttributeCertificateV1 (OSCTXT* pctxt,
   ASN1T_ATTRCERT_AttributeCertificateV1 *pvalue, ASN1TagType tagging)
{
   int ll;
   int ll0 = 0;
   int ll1 = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AttributeCertificateV1");

   /* encode signature_ */

   RTXCTXTPUSHELEMNAME (pctxt, "signature");

   ll = xe_bitstr (pctxt, pvalue->signature_.data, pvalue->signature_.numbits, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode signatureAlgorithm */

   RTXCTXTPUSHELEMNAME (pctxt, "signatureAlgorithm");

   ll = asn1E_EXP_AlgorithmIdentifier (pctxt, &pvalue->signatureAlgorithm, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   /* encode acInfo */

   RTXCTXTPUSHELEMNAME (pctxt, "acInfo");

   ll = asn1E_ATTRCERT_AttributeCertificateInfoV1 (pctxt, &pvalue->acInfo, ASN1EXPL);
   if (ll < 0) return LOG_RTERR (pctxt, ll);
   ll1 += ll;

   RTXCTXTPOPELEMNAME (pctxt);

   ll0 += ll1;

   if (tagging == ASN1EXPL)
      ll0 = xe_tag_len (pctxt, TM_UNIV|TM_CONS|16, ll0);

   RTXCTXTPOPTYPENAME (pctxt);

   return (ll0);
}

