/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.6, Date: 28-Feb-2014.
 */
#include "Explicit.h"
#include "UsefulDefinitions.h"
#include "rtxsrc/rtxCommon.h"

EXTERN int asn1D_EXP_Version (OSCTXT* pctxt, ASN1T_EXP_Version* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "Version");

   stat = xd_integer (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_CertificateSerialNumber (OSCTXT* pctxt, 
   ASN1T_EXP_CertificateSerialNumber* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CertificateSerialNumber");

   stat = xd_bigint (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_AttributeType (OSCTXT* pctxt, 
   ASN1T_EXP_AttributeType* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AttributeType");

   stat = xd_objid (pctxt, (ASN1OBJID*)pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_AttributeValue (OSCTXT* pctxt, 
   ASN1T_EXP_AttributeValue* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "AttributeValue");

   stat = xd_OpenType (pctxt, &pvalue->data, &pvalue->numocts);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_UniqueIdentifier (OSCTXT* pctxt, 
   ASN1T_EXP_UniqueIdentifier* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UniqueIdentifier");

   stat = xd_bitstr (pctxt, &pvalue->data, &pvalue->numbits, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_X121Address (OSCTXT* pctxt, 
   ASN1T_EXP_X121Address* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "X121Address");

   stat = xd_charstr (pctxt, pvalue, tagging, (TM_UNIV|TM_PRIM|18), length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   { size_t nchars = OSCRTLSTRLEN (*pvalue);
   if (!((nchars >= 1 && nchars <= 16))) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)nchars);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   }
   { char c = (char) rtValidateStr (18, *pvalue);
   if (c != 0) {
      char lbuf[2];
      lbuf[0] = c;
      lbuf[1] = 0;

      rtxErrAddElemNameParm (pctxt);
      rtxErrAddStrParm (pctxt, lbuf);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_NetworkAddress (OSCTXT* pctxt, 
   ASN1T_EXP_NetworkAddress* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NetworkAddress");

   stat = asn1D_EXP_X121Address (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   { char c = (char) rtValidateStr (18, *pvalue);
   if (c != 0) {
      char lbuf[2];
      lbuf[0] = c;
      lbuf[1] = 0;

      rtxErrAddElemNameParm (pctxt);
      rtxErrAddStrParm (pctxt, lbuf);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_TerminalIdentifier (OSCTXT* pctxt, 
   ASN1T_EXP_TerminalIdentifier* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TerminalIdentifier");

   stat = xd_charstr (pctxt, pvalue, tagging, (TM_UNIV|TM_PRIM|19), length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   { size_t nchars = OSCRTLSTRLEN (*pvalue);
   if (!((nchars >= 1 && nchars <= 24))) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)nchars);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_OrganizationName (OSCTXT* pctxt, 
   ASN1T_EXP_OrganizationName* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "OrganizationName");

   stat = xd_charstr (pctxt, pvalue, tagging, (TM_UNIV|TM_PRIM|19), length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   { size_t nchars = OSCRTLSTRLEN (*pvalue);
   if (!((nchars >= 1 && nchars <= 128))) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)nchars);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_NumericUserIdentifier (OSCTXT* pctxt, 
   ASN1T_EXP_NumericUserIdentifier* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "NumericUserIdentifier");

   stat = xd_charstr (pctxt, pvalue, tagging, (TM_UNIV|TM_PRIM|18), length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   { size_t nchars = OSCRTLSTRLEN (*pvalue);
   if (!((nchars >= 1 && nchars <= 32))) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)nchars);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   }
   { char c = (char) rtValidateStr (18, *pvalue);
   if (c != 0) {
      char lbuf[2];
      lbuf[0] = c;
      lbuf[1] = 0;

      rtxErrAddElemNameParm (pctxt);
      rtxErrAddStrParm (pctxt, lbuf);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_OrganizationalUnitName (OSCTXT* pctxt, 
   ASN1T_EXP_OrganizationalUnitName* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "OrganizationalUnitName");

   stat = xd_charstr (pctxt, pvalue, tagging, (TM_UNIV|TM_PRIM|19), length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   { size_t nchars = OSCRTLSTRLEN (*pvalue);
   if (!((nchars >= 1 && nchars <= 128))) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)nchars);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_CommonName (OSCTXT* pctxt, ASN1T_EXP_CommonName* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "CommonName");

   stat = xd_charstr (pctxt, pvalue, tagging, (TM_UNIV|TM_PRIM|19), length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   { size_t nchars = OSCRTLSTRLEN (*pvalue);
   if (!((nchars >= 1 && nchars <= 128))) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)nchars);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_TeletexCommonName (OSCTXT* pctxt, 
   ASN1T_EXP_TeletexCommonName* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TeletexCommonName");

   stat = xd_charstr (pctxt, pvalue, tagging, (TM_UNIV|TM_PRIM|20), length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   { size_t nchars = OSCRTLSTRLEN (*pvalue);
   if (!((nchars >= 1 && nchars <= 128))) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)nchars);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_TeletexOrganizationName (OSCTXT* pctxt, 
   ASN1T_EXP_TeletexOrganizationName* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TeletexOrganizationName");

   stat = xd_charstr (pctxt, pvalue, tagging, (TM_UNIV|TM_PRIM|20), length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   { size_t nchars = OSCRTLSTRLEN (*pvalue);
   if (!((nchars >= 1 && nchars <= 128))) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)nchars);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_TeletexOrganizationalUnitName (OSCTXT* pctxt, 
   ASN1T_EXP_TeletexOrganizationalUnitName* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TeletexOrganizationalUnitName");

   stat = xd_charstr (pctxt, pvalue, tagging, (TM_UNIV|TM_PRIM|20), length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   { size_t nchars = OSCRTLSTRLEN (*pvalue);
   if (!((nchars >= 1 && nchars <= 128))) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)nchars);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_PDSName (OSCTXT* pctxt, ASN1T_EXP_PDSName* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PDSName");

   stat = xd_charstr (pctxt, pvalue, tagging, (TM_UNIV|TM_PRIM|19), length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   { size_t nchars = OSCRTLSTRLEN (*pvalue);
   if (!((nchars >= 1 && nchars <= 16))) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)nchars);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_PDSParameter (OSCTXT* pctxt, 
   ASN1T_EXP_PDSParameter* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG tag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "PDSParameter");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x11, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SET */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   OSCRTLMEMSET (ccb.mask, 0, sizeof(ccb.mask));
   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      stat = xd_tag_len (pctxt, &tag, &length, XM_ADVANCE);

      if (stat == 0) switch (tag)
      {
         case (TM_UNIV|TM_PRIM|19):
            RTXCTXTPUSHELEMNAME (pctxt, "printable-string");

            stat = xd_charstr (pctxt, &pvalue->printable_string, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|19), length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            { size_t nchars = OSCRTLSTRLEN (pvalue->printable_string);
            if (!((nchars >= 1 && nchars <= 30))) {
               rtxErrAddElemNameParm (pctxt);
               rtxErrAddIntParm (pctxt, (int)nchars);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

            }

            RTXCTXTPOPELEMNAME (pctxt);
            if ((ccb.mask[0] & 0x1) != 0) {
               return LOG_RTERR (pctxt, RTERR_SETDUPL);
            }
            else {
               ccb.mask[0] |= 0x1;
               pvalue->m.printable_stringPresent = TRUE;
            }

            break;

         case (TM_UNIV|TM_PRIM|20):
            RTXCTXTPUSHELEMNAME (pctxt, "teletex-string");

            stat = xd_charstr (pctxt, &pvalue->teletex_string, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|20), length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            { size_t nchars = OSCRTLSTRLEN (pvalue->teletex_string);
            if (!((nchars >= 1 && nchars <= 30))) {
               rtxErrAddElemNameParm (pctxt);
               rtxErrAddIntParm (pctxt, (int)nchars);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

            }

            RTXCTXTPOPELEMNAME (pctxt);
            if ((ccb.mask[0] & 0x2) != 0) {
               return LOG_RTERR (pctxt, RTERR_SETDUPL);
            }
            else {
               ccb.mask[0] |= 0x2;
               pvalue->m.teletex_stringPresent = TRUE;
            }

            break;

         default:
            berErrAddTagParm (pctxt, tag);
            stat = LOG_RTERR (pctxt, RTERR_NOTINSET);
            break;
      }
      else stat = LOG_RTERR (pctxt, stat);

      if (stat != 0) {
         return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_PhysicalDeliveryOfficeName (OSCTXT* pctxt, 
   ASN1T_EXP_PhysicalDeliveryOfficeName* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PhysicalDeliveryOfficeName");

   stat = asn1D_EXP_PDSParameter (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_PhysicalDeliveryOfficeNumber (OSCTXT* pctxt, 
   ASN1T_EXP_PhysicalDeliveryOfficeNumber* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PhysicalDeliveryOfficeNumber");

   stat = asn1D_EXP_PDSParameter (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_ExtensionORAddressComponents (OSCTXT* pctxt, 
   ASN1T_EXP_ExtensionORAddressComponents* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ExtensionORAddressComponents");

   stat = asn1D_EXP_PDSParameter (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_PhysicalDeliveryPersonalName (OSCTXT* pctxt, 
   ASN1T_EXP_PhysicalDeliveryPersonalName* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PhysicalDeliveryPersonalName");

   stat = asn1D_EXP_PDSParameter (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_PhysicalDeliveryOrganizationName (OSCTXT* pctxt, 
   ASN1T_EXP_PhysicalDeliveryOrganizationName* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PhysicalDeliveryOrganizationName");

   stat = asn1D_EXP_PDSParameter (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_ExtensionPhysicalDeliveryAddressComponents (
   OSCTXT* pctxt, 
   ASN1T_EXP_ExtensionPhysicalDeliveryAddressComponents* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "ExtensionPhysicalDeliveryAddressComponents");

   stat = asn1D_EXP_PDSParameter (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_StreetAddress (OSCTXT* pctxt, 
   ASN1T_EXP_StreetAddress* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "StreetAddress");

   stat = asn1D_EXP_PDSParameter (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_PostOfficeBoxAddress (OSCTXT* pctxt, 
   ASN1T_EXP_PostOfficeBoxAddress* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PostOfficeBoxAddress");

   stat = asn1D_EXP_PDSParameter (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_PosteRestanteAddress (OSCTXT* pctxt, 
   ASN1T_EXP_PosteRestanteAddress* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "PosteRestanteAddress");

   stat = asn1D_EXP_PDSParameter (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_UniquePostalName (OSCTXT* pctxt, 
   ASN1T_EXP_UniquePostalName* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "UniquePostalName");

   stat = asn1D_EXP_PDSParameter (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_LocalPostalAttributes (OSCTXT* pctxt, 
   ASN1T_EXP_LocalPostalAttributes* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "LocalPostalAttributes");

   stat = asn1D_EXP_PDSParameter (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_TerminalType (OSCTXT* pctxt, 
   ASN1T_EXP_TerminalType* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "TerminalType");

   stat = xd_uint16 (pctxt, pvalue, tagging, length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   if (!((*pvalue <= OSUINTCONST(256)))) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)*pvalue);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_X520countryName (OSCTXT* pctxt, 
   ASN1T_EXP_X520countryName* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "X520countryName");

   stat = xd_charstr (pctxt, pvalue, tagging, (TM_UNIV|TM_PRIM|19), length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   { size_t nchars = OSCRTLSTRLEN (*pvalue);
   if (!(nchars == 2)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)nchars);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_X520SerialNumber (OSCTXT* pctxt, 
   ASN1T_EXP_X520SerialNumber* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "X520SerialNumber");

   stat = xd_charstr (pctxt, pvalue, tagging, (TM_UNIV|TM_PRIM|19), length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   { size_t nchars = OSCRTLSTRLEN (*pvalue);
   if (!((nchars >= 1 && nchars <= 64))) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)nchars);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_DomainComponent (OSCTXT* pctxt, 
   ASN1T_EXP_DomainComponent* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "DomainComponent");

   stat = xd_charstr (pctxt, pvalue, tagging, (TM_UNIV|TM_PRIM|22), length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_EmailAddress (OSCTXT* pctxt, 
   ASN1T_EXP_EmailAddress* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;

   RTXCTXTPUSHTYPENAME (pctxt, "EmailAddress");

   stat = xd_charstr (pctxt, pvalue, tagging, (TM_UNIV|TM_PRIM|22), length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   { size_t nchars = OSCRTLSTRLEN (*pvalue);
   if (!((nchars >= 1 && nchars <= 128))) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)nchars);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_AlgorithmIdentifier (OSCTXT* pctxt, 
   ASN1T_EXP_AlgorithmIdentifier* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "AlgorithmIdentifier");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode algorithm */
         RTXCTXTPUSHELEMNAME (pctxt, "algorithm");

         stat = xd_objid (pctxt, (ASN1OBJID*)&pvalue->algorithm, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode parameters */
         RTXCTXTPUSHELEMNAME (pctxt, "parameters");

         stat = xd_OpenType (pctxt, &pvalue->parameters.data, &pvalue->parameters.numocts);
         if (stat == 0) {
            pvalue->m.parametersPresent = TRUE;
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_AttributeTypeAndValue (OSCTXT* pctxt, 
   ASN1T_EXP_AttributeTypeAndValue* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "AttributeTypeAndValue");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode type */
         RTXCTXTPUSHELEMNAME (pctxt, "type");

         stat = asn1D_EXP_AttributeType (pctxt, &pvalue->type, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode value */
         RTXCTXTPUSHELEMNAME (pctxt, "value");

         stat = asn1D_EXP_AttributeValue (pctxt, &pvalue->value, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_RelativeDistinguishedName (OSCTXT* pctxt, 
   ASN1T_EXP_RelativeDistinguishedName* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1T_EXP_AttributeTypeAndValue* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "RelativeDistinguishedName");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x11, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "AttributeTypeAndValue", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_EXP_AttributeTypeAndValue, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EXP_AttributeTypeAndValue (pdata1);

      stat = asn1D_EXP_AttributeTypeAndValue (pctxt, pdata1, 
         ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_RDNSequence (OSCTXT* pctxt, 
   ASN1T_EXP_RDNSequence* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_EXP_RelativeDistinguishedName* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "RDNSequence");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "RelativeDistinguishedName", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_EXP_RelativeDistinguishedName, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EXP_RelativeDistinguishedName (pdata1);

      stat = asn1D_EXP_RelativeDistinguishedName (pctxt, pdata1, 
         ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_Name (OSCTXT* pctxt, ASN1T_EXP_Name* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "Name");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_UNIV|TM_CONS|16):
         RTXCTXTPUSHELEMNAME (pctxt, "rdnSequence");

         pvalue->u.rdnSequence = rtxMemAllocType (pctxt, 
            ASN1T_EXP_RDNSequence);

         if (pvalue->u.rdnSequence == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_EXP_RDNSequence (pvalue->u.rdnSequence);
         stat = asn1D_EXP_RDNSequence (pctxt, pvalue->u.rdnSequence, 
            ASN1IMPL, length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_Time (OSCTXT* pctxt, ASN1T_EXP_Time* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "Time");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_UNIV|TM_PRIM|23):
         RTXCTXTPUSHELEMNAME (pctxt, "utcTime");

         stat = xd_charstr (pctxt, &pvalue->u.utcTime, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|23), length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|24):
         RTXCTXTPUSHELEMNAME (pctxt, "generalTime");

         stat = xd_charstr (pctxt, &pvalue->u.generalTime, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|24), length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_Validity (OSCTXT* pctxt, ASN1T_EXP_Validity* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "Validity");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode notBefore */
         RTXCTXTPUSHELEMNAME (pctxt, "notBefore");

         stat = asn1D_EXP_Time (pctxt, &pvalue->notBefore, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode notAfter */
         RTXCTXTPUSHELEMNAME (pctxt, "notAfter");

         stat = asn1D_EXP_Time (pctxt, &pvalue->notAfter, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|23):
         case (TM_UNIV|TM_PRIM|24):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_SubjectPublicKeyInfo (OSCTXT* pctxt, 
   ASN1T_EXP_SubjectPublicKeyInfo* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "SubjectPublicKeyInfo");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode algorithm */
         RTXCTXTPUSHELEMNAME (pctxt, "algorithm");

         stat = asn1D_EXP_AlgorithmIdentifier (pctxt, &pvalue->algorithm, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode subjectPublicKey */
         RTXCTXTPUSHELEMNAME (pctxt, "subjectPublicKey");

         stat = xd_bitstr (pctxt, &pvalue->subjectPublicKey.data, &pvalue->subjectPublicKey.numbits, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_CONS|16):
         case (TM_UNIV|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_Extension (OSCTXT* pctxt, ASN1T_EXP_Extension* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "Extension");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
      pvalue->critical = FALSE;
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode extnID */
         RTXCTXTPUSHELEMNAME (pctxt, "extnID");

         stat = xd_objid (pctxt, (ASN1OBJID*)&pvalue->extnID, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode critical */
         if (XD_PEEKTAG (pctxt, 0x1)) {
            RTXCTXTPUSHELEMNAME (pctxt, "critical");

            stat = xd_boolean (pctxt, &pvalue->critical, ASN1EXPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 2:
         /* decode extnValue */
         RTXCTXTPUSHELEMNAME (pctxt, "extnValue");

         stat = xd_octstr (pctxt, &pvalue->extnValue.data, &pvalue->extnValue.numocts, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|6):
         case (TM_UNIV|TM_PRIM|1):
         case (TM_UNIV|TM_PRIM|4):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_Extensions (OSCTXT* pctxt, ASN1T_EXP_Extensions* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_EXP_Extension* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "Extensions");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "Extension", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_EXP_Extension, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EXP_Extension (pdata1);

      stat = asn1D_EXP_Extension (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_TBSCertificate (OSCTXT* pctxt, 
   ASN1T_EXP_TBSCertificate* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "TBSCertificate");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
      pvalue->version = EXP_Version::v1;
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode version */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "version");

            stat = asn1D_EXP_Version (pctxt, &pvalue->version, 
               ASN1EXPL, length);
            if (stat == 0) {
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 1:
         /* decode serialNumber */
         RTXCTXTPUSHELEMNAME (pctxt, "serialNumber");

         stat = asn1D_EXP_CertificateSerialNumber (pctxt, &pvalue->serialNumber
            , ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode signature_ */
         RTXCTXTPUSHELEMNAME (pctxt, "signature");

         stat = asn1D_EXP_AlgorithmIdentifier (pctxt, &pvalue->signature_, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 3:
         /* decode issuer */
         RTXCTXTPUSHELEMNAME (pctxt, "issuer");

         stat = asn1D_EXP_Name (pctxt, &pvalue->issuer, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 4:
         /* decode validity */
         RTXCTXTPUSHELEMNAME (pctxt, "validity");

         stat = asn1D_EXP_Validity (pctxt, &pvalue->validity, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 5:
         /* decode subject */
         RTXCTXTPUSHELEMNAME (pctxt, "subject");

         stat = asn1D_EXP_Name (pctxt, &pvalue->subject, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 6:
         /* decode subjectPublicKeyInfo */
         RTXCTXTPUSHELEMNAME (pctxt, "subjectPublicKeyInfo");

         stat = asn1D_EXP_SubjectPublicKeyInfo (pctxt, &pvalue->
            subjectPublicKeyInfo, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 7:
         /* decode issuerUniqueID */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "issuerUniqueID");

            stat = asn1D_EXP_UniqueIdentifier (pctxt, &pvalue->issuerUniqueID, 
               ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.issuerUniqueIDPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 8:
         /* decode subjectUniqueID */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "subjectUniqueID");

            stat = asn1D_EXP_UniqueIdentifier (pctxt, &pvalue->subjectUniqueID
               , ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.subjectUniqueIDPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 9:
         /* decode extensions */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "extensions");

            stat = asn1D_EXP_Extensions (pctxt, &pvalue->extensions, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.extensionsPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_UNIV|TM_PRIM|2):
         case (TM_UNIV|TM_CONS|16):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_PRIM|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 6) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_Certificate (OSCTXT* pctxt, 
   ASN1T_EXP_Certificate* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "Certificate");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode tbsCertificate */
         RTXCTXTPUSHELEMNAME (pctxt, "tbsCertificate");

         stat = asn1D_EXP_TBSCertificate (pctxt, &pvalue->tbsCertificate, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode signatureAlgorithm */
         RTXCTXTPUSHELEMNAME (pctxt, "signatureAlgorithm");

         stat = asn1D_EXP_AlgorithmIdentifier (pctxt, &pvalue->
            signatureAlgorithm, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode signature_ */
         RTXCTXTPUSHELEMNAME (pctxt, "signature");

         stat = xd_bitstr (pctxt, &pvalue->signature_.data, &pvalue->signature_.numbits, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_CONS|16):
         case (TM_UNIV|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP__SetOfEXP_AttributeValue (OSCTXT* pctxt, 
   ASN1T_EXP__SetOfEXP_AttributeValue* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_EXP_AttributeValue* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x11, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "AttributeValue", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_EXP_AttributeValue, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EXP_AttributeValue (pdata1);

      stat = asn1D_EXP_AttributeValue (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1D_EXP_Attribute (OSCTXT* pctxt, ASN1T_EXP_Attribute* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "Attribute");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode type */
         RTXCTXTPUSHELEMNAME (pctxt, "type");

         stat = asn1D_EXP_AttributeType (pctxt, &pvalue->type, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode values */
         RTXCTXTPUSHELEMNAME (pctxt, "values");

         stat = asn1D_EXP__SetOfEXP_AttributeValue (pctxt, &pvalue->values, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|6):
         case (TM_UNIV|TM_CONS|17):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_TBSCertList_revokedCertificates_element (OSCTXT* pctxt, 
   ASN1T_EXP_TBSCertList_revokedCertificates_element* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode userCertificate */
         RTXCTXTPUSHELEMNAME (pctxt, "userCertificate");

         stat = asn1D_EXP_CertificateSerialNumber (pctxt, &pvalue->
            userCertificate, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode revocationDate */
         RTXCTXTPUSHELEMNAME (pctxt, "revocationDate");

         stat = asn1D_EXP_Time (pctxt, &pvalue->revocationDate, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode crlEntryExtensions */
         if (XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "crlEntryExtensions");

            stat = asn1D_EXP_Extensions (pctxt, &pvalue->crlEntryExtensions, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.crlEntryExtensionsPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|2):
         case (TM_UNIV|TM_PRIM|23):
         case (TM_UNIV|TM_PRIM|24):
         case (TM_UNIV|TM_CONS|16):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   return (stat);
}

EXTERN int asn1D_EXP__SeqOfEXP_TBSCertList_revokedCertificates_element (
   OSCTXT* pctxt, 
   ASN1T_EXP__SeqOfEXP_TBSCertList_revokedCertificates_element* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_EXP_TBSCertList_revokedCertificates_element* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "SEQUENCE", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_EXP_TBSCertList_revokedCertificates_element, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EXP_TBSCertList_revokedCertificates_element (pdata1);

      stat = asn1D_EXP_TBSCertList_revokedCertificates_element (pctxt, pdata1, 
         ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   return (stat);
}

EXTERN int asn1D_EXP_TBSCertList (OSCTXT* pctxt, 
   ASN1T_EXP_TBSCertList* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "TBSCertList");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode version */
         if (XD_PEEKTAG (pctxt, 0x2)) {
            RTXCTXTPUSHELEMNAME (pctxt, "version");

            stat = asn1D_EXP_Version (pctxt, &pvalue->version, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.versionPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 1:
         /* decode signature_ */
         RTXCTXTPUSHELEMNAME (pctxt, "signature");

         stat = asn1D_EXP_AlgorithmIdentifier (pctxt, &pvalue->signature_, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode issuer */
         RTXCTXTPUSHELEMNAME (pctxt, "issuer");

         stat = asn1D_EXP_Name (pctxt, &pvalue->issuer, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 3:
         /* decode thisUpdate */
         RTXCTXTPUSHELEMNAME (pctxt, "thisUpdate");

         stat = asn1D_EXP_Time (pctxt, &pvalue->thisUpdate, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 4:
         /* decode nextUpdate */
         if (XD_PEEKTAG (pctxt, 0x17)
         || XD_PEEKTAG (pctxt, 0x18)) {
            RTXCTXTPUSHELEMNAME (pctxt, "nextUpdate");

            stat = asn1D_EXP_Time (pctxt, &pvalue->nextUpdate, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.nextUpdatePresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 5:
         /* decode revokedCertificates */
         if (XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "revokedCertificates");

            stat = asn1D_EXP__SeqOfEXP_TBSCertList_revokedCertificates_element (pctxt, 
               &pvalue->revokedCertificates, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.revokedCertificatesPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 6:
         /* decode crlExtensions */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "crlExtensions");

            stat = asn1D_EXP_Extensions (pctxt, &pvalue->crlExtensions, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.crlExtensionsPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|2):
         case (TM_UNIV|TM_CONS|16):
         case (TM_UNIV|TM_PRIM|23):
         case (TM_UNIV|TM_PRIM|24):
         case (TM_CTXT|TM_CONS|0):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_CertificateList (OSCTXT* pctxt, 
   ASN1T_EXP_CertificateList* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "CertificateList");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode tbsCertList */
         RTXCTXTPUSHELEMNAME (pctxt, "tbsCertList");

         stat = asn1D_EXP_TBSCertList (pctxt, &pvalue->tbsCertList, 
            ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode signatureAlgorithm */
         RTXCTXTPUSHELEMNAME (pctxt, "signatureAlgorithm");

         stat = asn1D_EXP_AlgorithmIdentifier (pctxt, &pvalue->
            signatureAlgorithm, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 2:
         /* decode signature_ */
         RTXCTXTPUSHELEMNAME (pctxt, "signature");

         stat = xd_bitstr (pctxt, &pvalue->signature_.data, &pvalue->signature_.numbits, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_CONS|16):
         case (TM_UNIV|TM_PRIM|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 3) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_CountryName (OSCTXT* pctxt, 
   ASN1T_EXP_CountryName* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   int len = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "CountryName");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x41, &len);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_UNIV|TM_PRIM|18):
         RTXCTXTPUSHELEMNAME (pctxt, "x121-dcc-code");

         stat = xd_charstr (pctxt, &pvalue->u.x121_dcc_code, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|18), length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.x121_dcc_code);
         if (!(nchars == 3)) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }
         { char c = (char) rtValidateStr (18, pvalue->u.x121_dcc_code);
         if (c != 0) {
            char lbuf[2];
            lbuf[0] = c;
            lbuf[1] = 0;

            rtxErrAddElemNameParm (pctxt);
            rtxErrAddStrParm (pctxt, lbuf);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|19):
         RTXCTXTPUSHELEMNAME (pctxt, "iso-3166-alpha2-code");

         stat = xd_charstr (pctxt, &pvalue->u.iso_3166_alpha2_code, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|19), length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.iso_3166_alpha2_code);
         if (!(nchars == 2)) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_AdministrationDomainName (OSCTXT* pctxt, 
   ASN1T_EXP_AdministrationDomainName* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   int len = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "AdministrationDomainName");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x42, &len);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_UNIV|TM_PRIM|18):
         RTXCTXTPUSHELEMNAME (pctxt, "numeric");

         stat = xd_charstr (pctxt, &pvalue->u.numeric, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|18), length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.numeric);
         if (!(nchars <= 16)) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }
         { char c = (char) rtValidateStr (18, pvalue->u.numeric);
         if (c != 0) {
            char lbuf[2];
            lbuf[0] = c;
            lbuf[1] = 0;

            rtxErrAddElemNameParm (pctxt);
            rtxErrAddStrParm (pctxt, lbuf);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|19):
         RTXCTXTPUSHELEMNAME (pctxt, "printable");

         stat = xd_charstr (pctxt, &pvalue->u.printable, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|19), length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.printable);
         if (!(nchars <= 16)) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_PrivateDomainName (OSCTXT* pctxt, 
   ASN1T_EXP_PrivateDomainName* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "PrivateDomainName");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_UNIV|TM_PRIM|18):
         RTXCTXTPUSHELEMNAME (pctxt, "numeric");

         stat = xd_charstr (pctxt, &pvalue->u.numeric, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|18), length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.numeric);
         if (!((nchars >= 1 && nchars <= 16))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }
         { char c = (char) rtValidateStr (18, pvalue->u.numeric);
         if (c != 0) {
            char lbuf[2];
            lbuf[0] = c;
            lbuf[1] = 0;

            rtxErrAddElemNameParm (pctxt);
            rtxErrAddStrParm (pctxt, lbuf);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|19):
         RTXCTXTPUSHELEMNAME (pctxt, "printable");

         stat = xd_charstr (pctxt, &pvalue->u.printable, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|19), length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.printable);
         if (!((nchars >= 1 && nchars <= 16))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_PersonalName (OSCTXT* pctxt, 
   ASN1T_EXP_PersonalName* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG tag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "PersonalName");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x11, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SET */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   OSCRTLMEMSET (ccb.mask, 0, sizeof(ccb.mask));
   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      stat = xd_tag_len (pctxt, &tag, &length, XM_ADVANCE);

      if (stat == 0) switch (tag)
      {
         case (TM_CTXT|TM_PRIM|0):
            RTXCTXTPUSHELEMNAME (pctxt, "surname");

            stat = xd_charstr (pctxt, &pvalue->surname, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|19), length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            { size_t nchars = OSCRTLSTRLEN (pvalue->surname);
            if (!((nchars >= 1 && nchars <= 40))) {
               rtxErrAddElemNameParm (pctxt);
               rtxErrAddIntParm (pctxt, (int)nchars);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

            }

            RTXCTXTPOPELEMNAME (pctxt);
            if ((ccb.mask[0] & 0x1) != 0) {
               return LOG_RTERR (pctxt, RTERR_SETDUPL);
            }
            else {
               ccb.mask[0] |= 0x1;
            }

            break;

         case (TM_CTXT|TM_PRIM|1):
            RTXCTXTPUSHELEMNAME (pctxt, "given-name");

            stat = xd_charstr (pctxt, &pvalue->given_name, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|19), length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            { size_t nchars = OSCRTLSTRLEN (pvalue->given_name);
            if (!((nchars >= 1 && nchars <= 16))) {
               rtxErrAddElemNameParm (pctxt);
               rtxErrAddIntParm (pctxt, (int)nchars);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

            }

            RTXCTXTPOPELEMNAME (pctxt);
            if ((ccb.mask[0] & 0x2) != 0) {
               return LOG_RTERR (pctxt, RTERR_SETDUPL);
            }
            else {
               ccb.mask[0] |= 0x2;
               pvalue->m.given_namePresent = TRUE;
            }

            break;

         case (TM_CTXT|TM_PRIM|2):
            RTXCTXTPUSHELEMNAME (pctxt, "initials");

            stat = xd_charstr (pctxt, &pvalue->initials, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|19), length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            { size_t nchars = OSCRTLSTRLEN (pvalue->initials);
            if (!((nchars >= 1 && nchars <= 5))) {
               rtxErrAddElemNameParm (pctxt);
               rtxErrAddIntParm (pctxt, (int)nchars);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

            }

            RTXCTXTPOPELEMNAME (pctxt);
            if ((ccb.mask[0] & 0x4) != 0) {
               return LOG_RTERR (pctxt, RTERR_SETDUPL);
            }
            else {
               ccb.mask[0] |= 0x4;
               pvalue->m.initialsPresent = TRUE;
            }

            break;

         case (TM_CTXT|TM_PRIM|3):
            RTXCTXTPUSHELEMNAME (pctxt, "generation-qualifier");

            stat = xd_charstr (pctxt, &pvalue->generation_qualifier, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|19), length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            { size_t nchars = OSCRTLSTRLEN (pvalue->generation_qualifier);
            if (!((nchars >= 1 && nchars <= 3))) {
               rtxErrAddElemNameParm (pctxt);
               rtxErrAddIntParm (pctxt, (int)nchars);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

            }

            RTXCTXTPOPELEMNAME (pctxt);
            if ((ccb.mask[0] & 0x8) != 0) {
               return LOG_RTERR (pctxt, RTERR_SETDUPL);
            }
            else {
               ccb.mask[0] |= 0x8;
               pvalue->m.generation_qualifierPresent = TRUE;
            }

            break;

         default:
            berErrAddTagParm (pctxt, tag);
            stat = LOG_RTERR (pctxt, RTERR_NOTINSET);
            break;
      }
      else stat = LOG_RTERR (pctxt, stat);

      if (stat != 0) {
         return LOG_RTERR (pctxt, stat);
      }
   }

   if ((~ccb.mask[0] & 0x1)) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_OrganizationalUnitNames (OSCTXT* pctxt, 
   ASN1T_EXP_OrganizationalUnitNames* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_EXP_OrganizationalUnitName pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "OrganizationalUnitNames");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      if (pvalue->count >= 4) return LOG_RTERR (pctxt, RTERR_SEQOVFLW);

      RTXCTXTPUSHARRAYELEMNAME (pctxt, "OrganizationalUnitName", pvalue->count);

      pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1D_EXP_OrganizationalUnitName (pctxt, &pdata1, 
         ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      pnode->data = (void*)pdata1;
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!((pvalue->count >= OSUINTCONST(1) && pvalue->count <= OSUINTCONST(4)))) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_BuiltInStandardAttributes (OSCTXT* pctxt, 
   ASN1T_EXP_BuiltInStandardAttributes* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "BuiltInStandardAttributes");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode country_name */
         if (XD_PEEKTAG (pctxt, 0x41)) {
            RTXCTXTPUSHELEMNAME (pctxt, "country-name");

            stat = asn1D_EXP_CountryName (pctxt, &pvalue->country_name, 
               ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.country_namePresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 1:
         /* decode administration_domain_name */
         if (XD_PEEKTAG (pctxt, 0x42)) {
            RTXCTXTPUSHELEMNAME (pctxt, "administration-domain-name");

            stat = asn1D_EXP_AdministrationDomainName (pctxt, &pvalue->
               administration_domain_name, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.administration_domain_namePresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 2:
         /* decode network_address */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "network-address");

            stat = asn1D_EXP_NetworkAddress (pctxt, &pvalue->network_address, 
               ASN1IMPL, length);
            if (stat == 0) {
               { char c = (char) rtValidateStr (18, pvalue->network_address);
               if (c != 0) {
                  char lbuf[2];
                  lbuf[0] = c;
                  lbuf[1] = 0;

                  rtxErrAddElemNameParm (pctxt);
                  rtxErrAddStrParm (pctxt, lbuf);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }
               }
               pvalue->m.network_addressPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 3:
         /* decode terminal_identifier */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "terminal-identifier");

            stat = asn1D_EXP_TerminalIdentifier (pctxt, &pvalue->
               terminal_identifier, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.terminal_identifierPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 4:
         /* decode private_domain_name */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "private-domain-name");

            stat = asn1D_EXP_PrivateDomainName (pctxt, &pvalue->
               private_domain_name, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.private_domain_namePresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 5:
         /* decode organization_name */
         if (XD_PEEKTAG (pctxt, 0x83)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "organization-name");

            stat = asn1D_EXP_OrganizationName (pctxt, &pvalue->
               organization_name, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.organization_namePresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 6:
         /* decode numeric_user_identifier */
         if (XD_PEEKTAG (pctxt, 0x84)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "numeric-user-identifier");

            stat = asn1D_EXP_NumericUserIdentifier (pctxt, &pvalue->
               numeric_user_identifier, ASN1IMPL, length);
            if (stat == 0) {
               { char c = (char) rtValidateStr (18, pvalue->numeric_user_identifier);
               if (c != 0) {
                  char lbuf[2];
                  lbuf[0] = c;
                  lbuf[1] = 0;

                  rtxErrAddElemNameParm (pctxt);
                  rtxErrAddStrParm (pctxt, lbuf);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }
               }
               pvalue->m.numeric_user_identifierPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 7:
         /* decode personal_name */
         if (XD_PEEKTAG (pctxt, 0x85)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "personal-name");

            stat = asn1D_EXP_PersonalName (pctxt, &pvalue->personal_name, 
               ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.personal_namePresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 8:
         /* decode organizational_unit_names */
         if (XD_PEEKTAG (pctxt, 0x86)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "organizational-unit-names");

            stat = asn1D_EXP_OrganizationalUnitNames (pctxt, &pvalue->
               organizational_unit_names, ASN1IMPL, length);
            if (stat == 0) {
               pvalue->m.organizational_unit_namesPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_APPL|TM_CONS|1):
         case (TM_APPL|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_PRIM|3):
         case (TM_CTXT|TM_PRIM|4):
         case (TM_CTXT|TM_CONS|5):
         case (TM_CTXT|TM_CONS|6):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_BuiltInDomainDefinedAttribute (OSCTXT* pctxt, 
   ASN1T_EXP_BuiltInDomainDefinedAttribute* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "BuiltInDomainDefinedAttribute");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode type */
         RTXCTXTPUSHELEMNAME (pctxt, "type");

         stat = xd_charstr (pctxt, &pvalue->type, ASN1EXPL, 
            (TM_UNIV|TM_PRIM|19), length);
         if (stat == 0) {
            { size_t nchars = OSCRTLSTRLEN (pvalue->type);
            if (!((nchars >= 1 && nchars <= 8))) {
               rtxErrAddElemNameParm (pctxt);
               rtxErrAddIntParm (pctxt, (int)nchars);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

            }
         }
         else return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode value */
         RTXCTXTPUSHELEMNAME (pctxt, "value");

         stat = xd_charstr (pctxt, &pvalue->value, ASN1EXPL, 
            (TM_UNIV|TM_PRIM|19), length);
         if (stat == 0) {
            { size_t nchars = OSCRTLSTRLEN (pvalue->value);
            if (!((nchars >= 1 && nchars <= 128))) {
               rtxErrAddElemNameParm (pctxt);
               rtxErrAddIntParm (pctxt, (int)nchars);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

            }
         }
         else return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|19):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_BuiltInDomainDefinedAttributes (OSCTXT* pctxt, 
   ASN1T_EXP_BuiltInDomainDefinedAttributes* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1T_EXP_BuiltInDomainDefinedAttribute* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "BuiltInDomainDefinedAttributes");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      if (pvalue->count >= 4) return LOG_RTERR (pctxt, RTERR_SEQOVFLW);

      RTXCTXTPUSHARRAYELEMNAME (pctxt, "BuiltInDomainDefinedAttribute", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_EXP_BuiltInDomainDefinedAttribute, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EXP_BuiltInDomainDefinedAttribute (pdata1);

      stat = asn1D_EXP_BuiltInDomainDefinedAttribute (pctxt, pdata1, 
         ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!((pvalue->count >= OSUINTCONST(1) && pvalue->count <= OSUINTCONST(4)))) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_ExtensionAttribute (OSCTXT* pctxt, 
   ASN1T_EXP_ExtensionAttribute* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "ExtensionAttribute");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode extension_attribute_type */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "extension-attribute-type");

            stat = xd_uint16 (pctxt, &pvalue->extension_attribute_type, ASN1IMPL, length);
            if (stat == 0) {
               if (!((pvalue->extension_attribute_type <= OSUINTCONST(256)))) {
                  rtxErrAddElemNameParm (pctxt);
                  rtxErrAddIntParm (pctxt, (int)pvalue->extension_attribute_type);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            reqcnt++;
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 1:
         /* decode extension_attribute_value */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "extension-attribute-value");

            stat = xd_OpenType (pctxt, &pvalue->extension_attribute_value.data, &pvalue->extension_attribute_value.numocts);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            reqcnt++;
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_CONS|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_ExtensionAttributes (OSCTXT* pctxt, 
   ASN1T_EXP_ExtensionAttributes* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1T_EXP_ExtensionAttribute* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "ExtensionAttributes");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x11, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      if (pvalue->count >= 256) return LOG_RTERR (pctxt, RTERR_SEQOVFLW);

      RTXCTXTPUSHARRAYELEMNAME (pctxt, "ExtensionAttribute", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_EXP_ExtensionAttribute, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EXP_ExtensionAttribute (pdata1);

      stat = asn1D_EXP_ExtensionAttribute (pctxt, pdata1, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!((pvalue->count >= 1 && pvalue->count <= 256))) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_ORAddress (OSCTXT* pctxt, ASN1T_EXP_ORAddress* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "ORAddress");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode built_in_standard_attributes */
         RTXCTXTPUSHELEMNAME (pctxt, "built-in-standard-attributes");

         stat = asn1D_EXP_BuiltInStandardAttributes (pctxt, &pvalue->
            built_in_standard_attributes, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode built_in_domain_defined_attributes */
         if (XD_PEEKTAG (pctxt, 0x10)) {
            RTXCTXTPUSHELEMNAME (pctxt, "built-in-domain-defined-attributes");

            stat = asn1D_EXP_BuiltInDomainDefinedAttributes (pctxt, &pvalue->
               built_in_domain_defined_attributes, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.built_in_domain_defined_attributesPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      case 2:
         /* decode extension_attributes */
         if (XD_PEEKTAG (pctxt, 0x11)) {
            RTXCTXTPUSHELEMNAME (pctxt, "extension-attributes");

            stat = asn1D_EXP_ExtensionAttributes (pctxt, &pvalue->
               extension_attributes, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.extension_attributesPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_CONS|16):
         case (TM_UNIV|TM_CONS|17):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_TeletexPersonalName (OSCTXT* pctxt, 
   ASN1T_EXP_TeletexPersonalName* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG tag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "TeletexPersonalName");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x11, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SET */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   OSCRTLMEMSET (ccb.mask, 0, sizeof(ccb.mask));
   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      stat = xd_tag_len (pctxt, &tag, &length, XM_ADVANCE);

      if (stat == 0) switch (tag)
      {
         case (TM_CTXT|TM_PRIM|0):
            RTXCTXTPUSHELEMNAME (pctxt, "surname");

            stat = xd_charstr (pctxt, &pvalue->surname, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|20), length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            { size_t nchars = OSCRTLSTRLEN (pvalue->surname);
            if (!((nchars >= 1 && nchars <= 40))) {
               rtxErrAddElemNameParm (pctxt);
               rtxErrAddIntParm (pctxt, (int)nchars);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

            }

            RTXCTXTPOPELEMNAME (pctxt);
            if ((ccb.mask[0] & 0x1) != 0) {
               return LOG_RTERR (pctxt, RTERR_SETDUPL);
            }
            else {
               ccb.mask[0] |= 0x1;
            }

            break;

         case (TM_CTXT|TM_PRIM|1):
            RTXCTXTPUSHELEMNAME (pctxt, "given-name");

            stat = xd_charstr (pctxt, &pvalue->given_name, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|20), length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            { size_t nchars = OSCRTLSTRLEN (pvalue->given_name);
            if (!((nchars >= 1 && nchars <= 16))) {
               rtxErrAddElemNameParm (pctxt);
               rtxErrAddIntParm (pctxt, (int)nchars);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

            }

            RTXCTXTPOPELEMNAME (pctxt);
            if ((ccb.mask[0] & 0x2) != 0) {
               return LOG_RTERR (pctxt, RTERR_SETDUPL);
            }
            else {
               ccb.mask[0] |= 0x2;
               pvalue->m.given_namePresent = TRUE;
            }

            break;

         case (TM_CTXT|TM_PRIM|2):
            RTXCTXTPUSHELEMNAME (pctxt, "initials");

            stat = xd_charstr (pctxt, &pvalue->initials, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|20), length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            { size_t nchars = OSCRTLSTRLEN (pvalue->initials);
            if (!((nchars >= 1 && nchars <= 5))) {
               rtxErrAddElemNameParm (pctxt);
               rtxErrAddIntParm (pctxt, (int)nchars);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

            }

            RTXCTXTPOPELEMNAME (pctxt);
            if ((ccb.mask[0] & 0x4) != 0) {
               return LOG_RTERR (pctxt, RTERR_SETDUPL);
            }
            else {
               ccb.mask[0] |= 0x4;
               pvalue->m.initialsPresent = TRUE;
            }

            break;

         case (TM_CTXT|TM_PRIM|3):
            RTXCTXTPUSHELEMNAME (pctxt, "generation-qualifier");

            stat = xd_charstr (pctxt, &pvalue->generation_qualifier, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|20), length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            { size_t nchars = OSCRTLSTRLEN (pvalue->generation_qualifier);
            if (!((nchars >= 1 && nchars <= 3))) {
               rtxErrAddElemNameParm (pctxt);
               rtxErrAddIntParm (pctxt, (int)nchars);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

            }

            RTXCTXTPOPELEMNAME (pctxt);
            if ((ccb.mask[0] & 0x8) != 0) {
               return LOG_RTERR (pctxt, RTERR_SETDUPL);
            }
            else {
               ccb.mask[0] |= 0x8;
               pvalue->m.generation_qualifierPresent = TRUE;
            }

            break;

         default:
            berErrAddTagParm (pctxt, tag);
            stat = LOG_RTERR (pctxt, RTERR_NOTINSET);
            break;
      }
      else stat = LOG_RTERR (pctxt, stat);

      if (stat != 0) {
         return LOG_RTERR (pctxt, stat);
      }
   }

   if ((~ccb.mask[0] & 0x1)) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_TeletexOrganizationalUnitNames (OSCTXT* pctxt, 
   ASN1T_EXP_TeletexOrganizationalUnitNames* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1T_EXP_TeletexOrganizationalUnitName pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "TeletexOrganizationalUnitNames");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      if (pvalue->count >= 4) return LOG_RTERR (pctxt, RTERR_SEQOVFLW);

      RTXCTXTPUSHARRAYELEMNAME (pctxt, "TeletexOrganizationalUnitName", pvalue->count);

      pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = asn1D_EXP_TeletexOrganizationalUnitName (pctxt, &pdata1, 
         ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      pnode->data = (void*)pdata1;
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!((pvalue->count >= OSUINTCONST(1) && pvalue->count <= OSUINTCONST(4)))) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_PhysicalDeliveryCountryName (OSCTXT* pctxt, 
   ASN1T_EXP_PhysicalDeliveryCountryName* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "PhysicalDeliveryCountryName");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_UNIV|TM_PRIM|18):
         RTXCTXTPUSHELEMNAME (pctxt, "x121-dcc-code");

         stat = xd_charstr (pctxt, &pvalue->u.x121_dcc_code, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|18), length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.x121_dcc_code);
         if (!(nchars == 3)) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }
         { char c = (char) rtValidateStr (18, pvalue->u.x121_dcc_code);
         if (c != 0) {
            char lbuf[2];
            lbuf[0] = c;
            lbuf[1] = 0;

            rtxErrAddElemNameParm (pctxt);
            rtxErrAddStrParm (pctxt, lbuf);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|19):
         RTXCTXTPUSHELEMNAME (pctxt, "iso-3166-alpha2-code");

         stat = xd_charstr (pctxt, &pvalue->u.iso_3166_alpha2_code, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|19), length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.iso_3166_alpha2_code);
         if (!(nchars == 2)) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_PostalCode (OSCTXT* pctxt, ASN1T_EXP_PostalCode* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "PostalCode");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_UNIV|TM_PRIM|18):
         RTXCTXTPUSHELEMNAME (pctxt, "numeric-code");

         stat = xd_charstr (pctxt, &pvalue->u.numeric_code, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|18), length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.numeric_code);
         if (!((nchars >= 1 && nchars <= 16))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }
         { char c = (char) rtValidateStr (18, pvalue->u.numeric_code);
         if (c != 0) {
            char lbuf[2];
            lbuf[0] = c;
            lbuf[1] = 0;

            rtxErrAddElemNameParm (pctxt);
            rtxErrAddStrParm (pctxt, lbuf);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|19):
         RTXCTXTPUSHELEMNAME (pctxt, "printable-code");

         stat = xd_charstr (pctxt, &pvalue->u.printable_code, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|19), length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.printable_code);
         if (!((nchars >= 1 && nchars <= 16))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_UnformattedPostalAddress_printable_address (
   OSCTXT* pctxt, 
   ASN1T_EXP_UnformattedPostalAddress_printable_address* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   const char* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      if (pvalue->count >= 6) return LOG_RTERR (pctxt, RTERR_SEQOVFLW);

      RTXCTXTPUSHARRAYELEMNAME (pctxt, "PrintableString", pvalue->count);

      pnode = rtxMemAllocTypeZ (pctxt, OSRTDListNode);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      stat = xd_charstr (pctxt, &pdata1, ASN1EXPL, 
         (TM_UNIV|TM_PRIM|19), length);
      if (stat == 0) {
         { size_t nchars = OSCRTLSTRLEN (pdata1);
         if (!((nchars >= 1 && nchars <= 30))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }
      }
      else return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      pnode->data = (void*)pdata1;
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!((pvalue->count >= OSUINTCONST(1) && pvalue->count <= OSUINTCONST(6)))) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

EXTERN int asn1D_EXP_UnformattedPostalAddress (OSCTXT* pctxt, 
   ASN1T_EXP_UnformattedPostalAddress* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG tag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "UnformattedPostalAddress");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x11, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SET */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   OSCRTLMEMSET (ccb.mask, 0, sizeof(ccb.mask));
   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      stat = xd_tag_len (pctxt, &tag, &length, XM_ADVANCE);

      if (stat == 0) switch (tag)
      {
         case (TM_UNIV|TM_CONS|16):
            RTXCTXTPUSHELEMNAME (pctxt, "printable-address");

            stat = asn1D_EXP_UnformattedPostalAddress_printable_address (pctxt, 
               &pvalue->printable_address, ASN1IMPL, length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            if ((ccb.mask[0] & 0x1) != 0) {
               return LOG_RTERR (pctxt, RTERR_SETDUPL);
            }
            else {
               ccb.mask[0] |= 0x1;
               pvalue->m.printable_addressPresent = TRUE;
            }

            break;

         case (TM_UNIV|TM_PRIM|20):
            RTXCTXTPUSHELEMNAME (pctxt, "teletex-string");

            stat = xd_charstr (pctxt, &pvalue->teletex_string, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|20), length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            { size_t nchars = OSCRTLSTRLEN (pvalue->teletex_string);
            if (!((nchars >= 1 && nchars <= 180))) {
               rtxErrAddElemNameParm (pctxt);
               rtxErrAddIntParm (pctxt, (int)nchars);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

            }

            RTXCTXTPOPELEMNAME (pctxt);
            if ((ccb.mask[0] & 0x2) != 0) {
               return LOG_RTERR (pctxt, RTERR_SETDUPL);
            }
            else {
               ccb.mask[0] |= 0x2;
               pvalue->m.teletex_stringPresent = TRUE;
            }

            break;

         default:
            berErrAddTagParm (pctxt, tag);
            stat = LOG_RTERR (pctxt, RTERR_NOTINSET);
            break;
      }
      else stat = LOG_RTERR (pctxt, stat);

      if (stat != 0) {
         return LOG_RTERR (pctxt, stat);
      }
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_ExtendedNetworkAddress_e163_4_address (OSCTXT* pctxt, 
   ASN1T_EXP_ExtendedNetworkAddress_e163_4_address* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode number */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "number");

            stat = xd_charstr (pctxt, &pvalue->number, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|18), length);
            if (stat == 0) {
               { size_t nchars = OSCRTLSTRLEN (pvalue->number);
               if (!((nchars >= 1 && nchars <= 15))) {
                  rtxErrAddElemNameParm (pctxt);
                  rtxErrAddIntParm (pctxt, (int)nchars);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

               }
               { char c = (char) rtValidateStr (18, pvalue->number);
               if (c != 0) {
                  char lbuf[2];
                  lbuf[0] = c;
                  lbuf[1] = 0;

                  rtxErrAddElemNameParm (pctxt);
                  rtxErrAddStrParm (pctxt, lbuf);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }
               }
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);

            reqcnt++;
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 1:
         /* decode sub_address */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "sub-address");

            stat = xd_charstr (pctxt, &pvalue->sub_address, ASN1IMPL, 
               (TM_UNIV|TM_PRIM|18), length);
            if (stat == 0) {
               { size_t nchars = OSCRTLSTRLEN (pvalue->sub_address);
               if (!((nchars >= 1 && nchars <= 40))) {
                  rtxErrAddElemNameParm (pctxt);
                  rtxErrAddIntParm (pctxt, (int)nchars);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }

               }
               { char c = (char) rtValidateStr (18, pvalue->sub_address);
               if (c != 0) {
                  char lbuf[2];
                  lbuf[0] = c;
                  lbuf[1] = 0;

                  rtxErrAddElemNameParm (pctxt);
                  rtxErrAddStrParm (pctxt, lbuf);
                  return LOG_RTERR (pctxt, RTERR_CONSVIO);
               }
               }
               pvalue->m.sub_addressPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_PRIM|0):
         case (TM_CTXT|TM_PRIM|1):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   return (stat);
}

EXTERN int asn1D_EXP_PresentationAddress_nAddresses (OSCTXT* pctxt, 
   ASN1T_EXP_PresentationAddress_nAddresses* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TDynOctStr* pdata1;
   OSRTDListNode* pnode;
   int len = 0;
   ASN1CCB ccb;

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x83, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   len = length;

   stat = xd_match1 (pctxt, ASN_SET_TAG, &length);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      RTXCTXTPUSHARRAYELEMNAME (pctxt, "OCTET_STRING", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1TDynOctStr, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      pdata1->numocts = 0;
      pdata1->data = 0;

      stat = xd_octstr (pctxt, &pdata1->data, &pdata1->numocts, ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!(pvalue->count >= 1)) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   return (stat);
}

EXTERN int asn1D_EXP_PresentationAddress (OSCTXT* pctxt, 
   ASN1T_EXP_PresentationAddress* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "PresentationAddress");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   OSCRTLMEMSET (&pvalue->m, 0, sizeof(pvalue->m));

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode pSelector */
         if (XD_PEEKTAG (pctxt, 0x80)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "pSelector");

            stat = xd_octstr (pctxt, &pvalue->pSelector.data, &pvalue->pSelector.numocts, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.pSelectorPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 1:
         /* decode sSelector */
         if (XD_PEEKTAG (pctxt, 0x81)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "sSelector");

            stat = xd_octstr (pctxt, &pvalue->sSelector.data, &pvalue->sSelector.numocts, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.sSelectorPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 2:
         /* decode tSelector */
         if (XD_PEEKTAG (pctxt, 0x82)) {
            int offset, declen, explen;
            stat = xd_Tag1AndLen (pctxt, &length);
            if (stat != 0) return LOG_RTERR (pctxt, stat);

            offset = (int) pctxt->buffer.byteIndex;
            explen = length;

            RTXCTXTPUSHELEMNAME (pctxt, "tSelector");

            stat = xd_octstr (pctxt, &pvalue->tSelector.data, &pvalue->tSelector.numocts, ASN1EXPL, length);
            if (stat == 0) {
               pvalue->m.tSelectorPresent = TRUE;
            }
            else return LOG_RTERR (pctxt, stat);

            RTXCTXTPOPELEMNAME (pctxt);
            declen = (int)pctxt->buffer.byteIndex - offset;
            if (declen != explen && explen != ASN_K_INDEFLEN)
               return LOG_RTERR (pctxt, ASN_E_INVLEN);
         }
         break;

      case 3:
         /* decode nAddresses */
         RTXCTXTPUSHELEMNAME (pctxt, "nAddresses");

         stat = asn1D_EXP_PresentationAddress_nAddresses (pctxt, &pvalue->
            nAddresses, ASN1EXPL, length);
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_CTXT|TM_CONS|0):
         case (TM_CTXT|TM_CONS|1):
         case (TM_CTXT|TM_CONS|2):
         case (TM_CTXT|TM_CONS|3):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 1) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_ExtendedNetworkAddress (OSCTXT* pctxt, 
   ASN1T_EXP_ExtendedNetworkAddress* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "ExtendedNetworkAddress");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_UNIV|TM_CONS|16):
         RTXCTXTPUSHELEMNAME (pctxt, "e163-4-address");

         pvalue->u.e163_4_address = rtxMemAllocType (pctxt, 
            ASN1T_EXP_ExtendedNetworkAddress_e163_4_address);

         if (pvalue->u.e163_4_address == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_EXP_ExtendedNetworkAddress_e163_4_address (pvalue->u.e163_4_address);
         stat = asn1D_EXP_ExtendedNetworkAddress_e163_4_address (pctxt, pvalue
            ->u.e163_4_address, ASN1IMPL, length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_CTXT|TM_CONS|0):
         RTXCTXTPUSHELEMNAME (pctxt, "psap-address");

         pvalue->u.psap_address = rtxMemAllocType (pctxt, 
            ASN1T_EXP_PresentationAddress);

         if (pvalue->u.psap_address == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         asn1Init_EXP_PresentationAddress (pvalue->u.psap_address);
         stat = asn1D_EXP_PresentationAddress (pctxt, pvalue->u.psap_address, 
            ASN1IMPL, length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_TeletexDomainDefinedAttribute (OSCTXT* pctxt, 
   ASN1T_EXP_TeletexDomainDefinedAttribute* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   int reqcnt = 0;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "TeletexDomainDefinedAttribute");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE */

   /* default value initialization */
   {
   }

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);
   ccb.seqx = 0;

   while (!XD_CHKEND (pctxt, &ccb)) {
      switch (ccb.seqx) {
      case 0:
         /* decode type */
         RTXCTXTPUSHELEMNAME (pctxt, "type");

         stat = xd_charstr (pctxt, &pvalue->type, ASN1EXPL, 
            (TM_UNIV|TM_PRIM|20), length);
         if (stat == 0) {
            { size_t nchars = OSCRTLSTRLEN (pvalue->type);
            if (!((nchars >= 1 && nchars <= 8))) {
               rtxErrAddElemNameParm (pctxt);
               rtxErrAddIntParm (pctxt, (int)nchars);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

            }
         }
         else return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      case 1:
         /* decode value */
         RTXCTXTPUSHELEMNAME (pctxt, "value");

         stat = xd_charstr (pctxt, &pvalue->value, ASN1EXPL, 
            (TM_UNIV|TM_PRIM|20), length);
         if (stat == 0) {
            { size_t nchars = OSCRTLSTRLEN (pvalue->value);
            if (!((nchars >= 1 && nchars <= 128))) {
               rtxErrAddElemNameParm (pctxt);
               rtxErrAddIntParm (pctxt, (int)nchars);
               return LOG_RTERR (pctxt, RTERR_CONSVIO);
            }

            }
         }
         else return LOG_RTERR (pctxt, stat);

         RTXCTXTPOPELEMNAME (pctxt);

         reqcnt++;
         break;

      default:
         { ASN1TAG tag;
         int __len;
         stat = xd_tag_len (pctxt, &tag, &__len, 0);
         if (stat != 0) return LOG_RTERR (pctxt, stat);
         switch (tag) {
         case (TM_UNIV|TM_PRIM|20):
            stat = RTERR_SEQORDER;
            break;
         default:
            berErrAddTagParm (pctxt, tag);
            stat = ASN_E_NOTINSEQ;
            break;
         }}
      }
      if (stat != 0) return LOG_RTERR (pctxt, stat);
      else ccb.seqx++;
   }

   if (reqcnt < 2) {
      return LOG_RTERR (pctxt, RTERR_SETMISRQ);
   }
   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_TeletexDomainDefinedAttributes (OSCTXT* pctxt, 
   ASN1T_EXP_TeletexDomainDefinedAttributes* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1T_EXP_TeletexDomainDefinedAttribute* pdata1;
   OSRTDListNode* pnode;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "TeletexDomainDefinedAttributes");

   if (tagging == ASN1EXPL) {
      stat = xd_match1 (pctxt, 0x10, &length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);
   }

   /* decode SEQUENCE OF or SET OF */

   rtxDListInit (pvalue);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   while (!XD_CHKEND (pctxt, &ccb))
   {
      if (pvalue->count >= 4) return LOG_RTERR (pctxt, RTERR_SEQOVFLW);

      RTXCTXTPUSHARRAYELEMNAME (pctxt, "TeletexDomainDefinedAttribute", pvalue->count);

      rtxDListAllocNodeAndData (pctxt, ASN1T_EXP_TeletexDomainDefinedAttribute, &pnode, &pdata1);

      if (pnode == NULL)
         return LOG_RTERR (pctxt, RTERR_NOMEM);

      asn1Init_EXP_TeletexDomainDefinedAttribute (pdata1);

      stat = asn1D_EXP_TeletexDomainDefinedAttribute (pctxt, pdata1, 
         ASN1EXPL, length);
      if (stat != 0) return LOG_RTERR (pctxt, stat);

      RTXCTXTPOPARRAYELEMNAME (pctxt);
      rtxDListAppendNode (pvalue, pnode);
   }

   if (!((pvalue->count >= OSUINTCONST(1) && pvalue->count <= OSUINTCONST(4)))) {
      rtxErrAddElemNameParm (pctxt);
      rtxErrAddIntParm (pctxt, (int)pvalue->count);
      return LOG_RTERR (pctxt, RTERR_CONSVIO);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_DirectoryString (OSCTXT* pctxt, 
   ASN1T_EXP_DirectoryString* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "DirectoryString");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_UNIV|TM_PRIM|12):
         RTXCTXTPUSHELEMNAME (pctxt, "utf8String");

         stat = xd_utf8str (pctxt, &pvalue->u.utf8String, ASN1IMPL, length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { int nchars = rtxUTF8Len (pvalue->u.utf8String);
         if (!(nchars >= 1)) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|19):
         RTXCTXTPUSHELEMNAME (pctxt, "printableString");

         stat = xd_charstr (pctxt, &pvalue->u.printableString, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|19), length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.printableString);
         if (!(nchars >= 1)) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|20):
         RTXCTXTPUSHELEMNAME (pctxt, "teletexString");

         stat = xd_charstr (pctxt, &pvalue->u.teletexString, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|20), length);
         pvalue->t = 3;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.teletexString);
         if (!(nchars >= 1)) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|28):
         RTXCTXTPUSHELEMNAME (pctxt, "universalString");

         pvalue->u.universalString = rtxMemAllocType (pctxt, 
            ASN1TUniversalString);

         if (pvalue->u.universalString == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.universalString->nchars = 0;
         stat = xd_32BitCharStr (pctxt,
            pvalue->u.universalString,
            ASN1IMPL, (TM_UNIV|TM_PRIM|28), length);
         pvalue->t = 4;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         if (!(pvalue->u.universalString->nchars >= 1)) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)pvalue->u.universalString->nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|30):
         RTXCTXTPUSHELEMNAME (pctxt, "bmpString");

         pvalue->u.bmpString = rtxMemAllocType (pctxt, ASN1TBMPString);

         if (pvalue->u.bmpString == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.bmpString->nchars = 0;
         stat = xd_16BitCharStr (pctxt,
            pvalue->u.bmpString,
            ASN1IMPL, (TM_UNIV|TM_PRIM|30), length);
         pvalue->t = 5;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         if (!(pvalue->u.bmpString->nchars >= 1)) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)pvalue->u.bmpString->nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_X520name (OSCTXT* pctxt, ASN1T_EXP_X520name* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "X520name");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_UNIV|TM_PRIM|12):
         RTXCTXTPUSHELEMNAME (pctxt, "utf8String");

         stat = xd_utf8str (pctxt, &pvalue->u.utf8String, ASN1IMPL, length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { int nchars = rtxUTF8Len (pvalue->u.utf8String);
         if (!((nchars >= 1 && nchars <= 32768))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|19):
         RTXCTXTPUSHELEMNAME (pctxt, "printableString");

         stat = xd_charstr (pctxt, &pvalue->u.printableString, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|19), length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.printableString);
         if (!((nchars >= 1 && nchars <= 32768))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|20):
         RTXCTXTPUSHELEMNAME (pctxt, "teletexString");

         stat = xd_charstr (pctxt, &pvalue->u.teletexString, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|20), length);
         pvalue->t = 3;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.teletexString);
         if (!((nchars >= 1 && nchars <= 32768))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|28):
         RTXCTXTPUSHELEMNAME (pctxt, "universalString");

         pvalue->u.universalString = rtxMemAllocType (pctxt, 
            ASN1TUniversalString);

         if (pvalue->u.universalString == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.universalString->nchars = 0;
         stat = xd_32BitCharStr (pctxt,
            pvalue->u.universalString,
            ASN1IMPL, (TM_UNIV|TM_PRIM|28), length);
         pvalue->t = 4;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         if (!((pvalue->u.universalString->nchars >= 1 && pvalue->u.universalString->
            nchars <= 32768))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)pvalue->u.universalString->nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|30):
         RTXCTXTPUSHELEMNAME (pctxt, "bmpString");

         pvalue->u.bmpString = rtxMemAllocType (pctxt, ASN1TBMPString);

         if (pvalue->u.bmpString == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.bmpString->nchars = 0;
         stat = xd_16BitCharStr (pctxt,
            pvalue->u.bmpString,
            ASN1IMPL, (TM_UNIV|TM_PRIM|30), length);
         pvalue->t = 5;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         if (!((pvalue->u.bmpString->nchars >= 1 && pvalue->u.bmpString->nchars
             <= 32768))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)pvalue->u.bmpString->nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_X520CommonName (OSCTXT* pctxt, 
   ASN1T_EXP_X520CommonName* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "X520CommonName");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_UNIV|TM_PRIM|12):
         RTXCTXTPUSHELEMNAME (pctxt, "utf8String");

         stat = xd_utf8str (pctxt, &pvalue->u.utf8String, ASN1IMPL, length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { int nchars = rtxUTF8Len (pvalue->u.utf8String);
         if (!((nchars >= 1 && nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|19):
         RTXCTXTPUSHELEMNAME (pctxt, "printableString");

         stat = xd_charstr (pctxt, &pvalue->u.printableString, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|19), length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.printableString);
         if (!((nchars >= 1 && nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|20):
         RTXCTXTPUSHELEMNAME (pctxt, "teletexString");

         stat = xd_charstr (pctxt, &pvalue->u.teletexString, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|20), length);
         pvalue->t = 3;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.teletexString);
         if (!((nchars >= 1 && nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|28):
         RTXCTXTPUSHELEMNAME (pctxt, "universalString");

         pvalue->u.universalString = rtxMemAllocType (pctxt, 
            ASN1TUniversalString);

         if (pvalue->u.universalString == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.universalString->nchars = 0;
         stat = xd_32BitCharStr (pctxt,
            pvalue->u.universalString,
            ASN1IMPL, (TM_UNIV|TM_PRIM|28), length);
         pvalue->t = 4;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         if (!((pvalue->u.universalString->nchars >= 1 && pvalue->u.universalString->
            nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)pvalue->u.universalString->nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|30):
         RTXCTXTPUSHELEMNAME (pctxt, "bmpString");

         pvalue->u.bmpString = rtxMemAllocType (pctxt, ASN1TBMPString);

         if (pvalue->u.bmpString == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.bmpString->nchars = 0;
         stat = xd_16BitCharStr (pctxt,
            pvalue->u.bmpString,
            ASN1IMPL, (TM_UNIV|TM_PRIM|30), length);
         pvalue->t = 5;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         if (!((pvalue->u.bmpString->nchars >= 1 && pvalue->u.bmpString->nchars <= 128
            ))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)pvalue->u.bmpString->nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_X520LocalityName (OSCTXT* pctxt, 
   ASN1T_EXP_X520LocalityName* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "X520LocalityName");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_UNIV|TM_PRIM|12):
         RTXCTXTPUSHELEMNAME (pctxt, "utf8String");

         stat = xd_utf8str (pctxt, &pvalue->u.utf8String, ASN1IMPL, length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { int nchars = rtxUTF8Len (pvalue->u.utf8String);
         if (!((nchars >= 1 && nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|19):
         RTXCTXTPUSHELEMNAME (pctxt, "printableString");

         stat = xd_charstr (pctxt, &pvalue->u.printableString, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|19), length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.printableString);
         if (!((nchars >= 1 && nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|20):
         RTXCTXTPUSHELEMNAME (pctxt, "teletexString");

         stat = xd_charstr (pctxt, &pvalue->u.teletexString, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|20), length);
         pvalue->t = 3;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.teletexString);
         if (!((nchars >= 1 && nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|28):
         RTXCTXTPUSHELEMNAME (pctxt, "universalString");

         pvalue->u.universalString = rtxMemAllocType (pctxt, 
            ASN1TUniversalString);

         if (pvalue->u.universalString == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.universalString->nchars = 0;
         stat = xd_32BitCharStr (pctxt,
            pvalue->u.universalString,
            ASN1IMPL, (TM_UNIV|TM_PRIM|28), length);
         pvalue->t = 4;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         if (!((pvalue->u.universalString->nchars >= 1 && pvalue->u.universalString->
            nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)pvalue->u.universalString->nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|30):
         RTXCTXTPUSHELEMNAME (pctxt, "bmpString");

         pvalue->u.bmpString = rtxMemAllocType (pctxt, ASN1TBMPString);

         if (pvalue->u.bmpString == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.bmpString->nchars = 0;
         stat = xd_16BitCharStr (pctxt,
            pvalue->u.bmpString,
            ASN1IMPL, (TM_UNIV|TM_PRIM|30), length);
         pvalue->t = 5;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         if (!((pvalue->u.bmpString->nchars >= 1 && pvalue->u.bmpString->nchars <= 128
            ))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)pvalue->u.bmpString->nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_X520StateOrProvinceName (OSCTXT* pctxt, 
   ASN1T_EXP_X520StateOrProvinceName* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "X520StateOrProvinceName");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_UNIV|TM_PRIM|12):
         RTXCTXTPUSHELEMNAME (pctxt, "utf8String");

         stat = xd_utf8str (pctxt, &pvalue->u.utf8String, ASN1IMPL, length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { int nchars = rtxUTF8Len (pvalue->u.utf8String);
         if (!((nchars >= 1 && nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|19):
         RTXCTXTPUSHELEMNAME (pctxt, "printableString");

         stat = xd_charstr (pctxt, &pvalue->u.printableString, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|19), length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.printableString);
         if (!((nchars >= 1 && nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|20):
         RTXCTXTPUSHELEMNAME (pctxt, "teletexString");

         stat = xd_charstr (pctxt, &pvalue->u.teletexString, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|20), length);
         pvalue->t = 3;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.teletexString);
         if (!((nchars >= 1 && nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|28):
         RTXCTXTPUSHELEMNAME (pctxt, "universalString");

         pvalue->u.universalString = rtxMemAllocType (pctxt, 
            ASN1TUniversalString);

         if (pvalue->u.universalString == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.universalString->nchars = 0;
         stat = xd_32BitCharStr (pctxt,
            pvalue->u.universalString,
            ASN1IMPL, (TM_UNIV|TM_PRIM|28), length);
         pvalue->t = 4;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         if (!((pvalue->u.universalString->nchars >= 1 && pvalue->u.universalString->
            nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)pvalue->u.universalString->nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|30):
         RTXCTXTPUSHELEMNAME (pctxt, "bmpString");

         pvalue->u.bmpString = rtxMemAllocType (pctxt, ASN1TBMPString);

         if (pvalue->u.bmpString == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.bmpString->nchars = 0;
         stat = xd_16BitCharStr (pctxt,
            pvalue->u.bmpString,
            ASN1IMPL, (TM_UNIV|TM_PRIM|30), length);
         pvalue->t = 5;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         if (!((pvalue->u.bmpString->nchars >= 1 && pvalue->u.bmpString->nchars <= 128
            ))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)pvalue->u.bmpString->nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_X520OrganizationName (OSCTXT* pctxt, 
   ASN1T_EXP_X520OrganizationName* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "X520OrganizationName");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_UNIV|TM_PRIM|12):
         RTXCTXTPUSHELEMNAME (pctxt, "utf8String");

         stat = xd_utf8str (pctxt, &pvalue->u.utf8String, ASN1IMPL, length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { int nchars = rtxUTF8Len (pvalue->u.utf8String);
         if (!((nchars >= 1 && nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|19):
         RTXCTXTPUSHELEMNAME (pctxt, "printableString");

         stat = xd_charstr (pctxt, &pvalue->u.printableString, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|19), length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.printableString);
         if (!((nchars >= 1 && nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|20):
         RTXCTXTPUSHELEMNAME (pctxt, "teletexString");

         stat = xd_charstr (pctxt, &pvalue->u.teletexString, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|20), length);
         pvalue->t = 3;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.teletexString);
         if (!((nchars >= 1 && nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|28):
         RTXCTXTPUSHELEMNAME (pctxt, "universalString");

         pvalue->u.universalString = rtxMemAllocType (pctxt, 
            ASN1TUniversalString);

         if (pvalue->u.universalString == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.universalString->nchars = 0;
         stat = xd_32BitCharStr (pctxt,
            pvalue->u.universalString,
            ASN1IMPL, (TM_UNIV|TM_PRIM|28), length);
         pvalue->t = 4;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         if (!((pvalue->u.universalString->nchars >= 1 && pvalue->u.universalString->
            nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)pvalue->u.universalString->nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|30):
         RTXCTXTPUSHELEMNAME (pctxt, "bmpString");

         pvalue->u.bmpString = rtxMemAllocType (pctxt, ASN1TBMPString);

         if (pvalue->u.bmpString == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.bmpString->nchars = 0;
         stat = xd_16BitCharStr (pctxt,
            pvalue->u.bmpString,
            ASN1IMPL, (TM_UNIV|TM_PRIM|30), length);
         pvalue->t = 5;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         if (!((pvalue->u.bmpString->nchars >= 1 && pvalue->u.bmpString->nchars <= 128
            ))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)pvalue->u.bmpString->nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_X520OrganizationalUnitName (OSCTXT* pctxt, 
   ASN1T_EXP_X520OrganizationalUnitName* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "X520OrganizationalUnitName");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_UNIV|TM_PRIM|12):
         RTXCTXTPUSHELEMNAME (pctxt, "utf8String");

         stat = xd_utf8str (pctxt, &pvalue->u.utf8String, ASN1IMPL, length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { int nchars = rtxUTF8Len (pvalue->u.utf8String);
         if (!((nchars >= 1 && nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|19):
         RTXCTXTPUSHELEMNAME (pctxt, "printableString");

         stat = xd_charstr (pctxt, &pvalue->u.printableString, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|19), length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.printableString);
         if (!((nchars >= 1 && nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|20):
         RTXCTXTPUSHELEMNAME (pctxt, "teletexString");

         stat = xd_charstr (pctxt, &pvalue->u.teletexString, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|20), length);
         pvalue->t = 3;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.teletexString);
         if (!((nchars >= 1 && nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|28):
         RTXCTXTPUSHELEMNAME (pctxt, "universalString");

         pvalue->u.universalString = rtxMemAllocType (pctxt, 
            ASN1TUniversalString);

         if (pvalue->u.universalString == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.universalString->nchars = 0;
         stat = xd_32BitCharStr (pctxt,
            pvalue->u.universalString,
            ASN1IMPL, (TM_UNIV|TM_PRIM|28), length);
         pvalue->t = 4;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         if (!((pvalue->u.universalString->nchars >= 1 && pvalue->u.universalString->
            nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)pvalue->u.universalString->nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|30):
         RTXCTXTPUSHELEMNAME (pctxt, "bmpString");

         pvalue->u.bmpString = rtxMemAllocType (pctxt, ASN1TBMPString);

         if (pvalue->u.bmpString == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.bmpString->nchars = 0;
         stat = xd_16BitCharStr (pctxt,
            pvalue->u.bmpString,
            ASN1IMPL, (TM_UNIV|TM_PRIM|30), length);
         pvalue->t = 5;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         if (!((pvalue->u.bmpString->nchars >= 1 && pvalue->u.bmpString->nchars <= 128
            ))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)pvalue->u.bmpString->nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_X520Title (OSCTXT* pctxt, ASN1T_EXP_X520Title* pvalue, 
   ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "X520Title");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_UNIV|TM_PRIM|12):
         RTXCTXTPUSHELEMNAME (pctxt, "utf8String");

         stat = xd_utf8str (pctxt, &pvalue->u.utf8String, ASN1IMPL, length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { int nchars = rtxUTF8Len (pvalue->u.utf8String);
         if (!((nchars >= 1 && nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|19):
         RTXCTXTPUSHELEMNAME (pctxt, "printableString");

         stat = xd_charstr (pctxt, &pvalue->u.printableString, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|19), length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.printableString);
         if (!((nchars >= 1 && nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|20):
         RTXCTXTPUSHELEMNAME (pctxt, "teletexString");

         stat = xd_charstr (pctxt, &pvalue->u.teletexString, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|20), length);
         pvalue->t = 3;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.teletexString);
         if (!((nchars >= 1 && nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|28):
         RTXCTXTPUSHELEMNAME (pctxt, "universalString");

         pvalue->u.universalString = rtxMemAllocType (pctxt, 
            ASN1TUniversalString);

         if (pvalue->u.universalString == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.universalString->nchars = 0;
         stat = xd_32BitCharStr (pctxt,
            pvalue->u.universalString,
            ASN1IMPL, (TM_UNIV|TM_PRIM|28), length);
         pvalue->t = 4;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         if (!((pvalue->u.universalString->nchars >= 1 && pvalue->u.universalString->
            nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)pvalue->u.universalString->nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|30):
         RTXCTXTPUSHELEMNAME (pctxt, "bmpString");

         pvalue->u.bmpString = rtxMemAllocType (pctxt, ASN1TBMPString);

         if (pvalue->u.bmpString == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.bmpString->nchars = 0;
         stat = xd_16BitCharStr (pctxt,
            pvalue->u.bmpString,
            ASN1IMPL, (TM_UNIV|TM_PRIM|30), length);
         pvalue->t = 5;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         if (!((pvalue->u.bmpString->nchars >= 1 && pvalue->u.bmpString->nchars <= 128
            ))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)pvalue->u.bmpString->nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_X520CountrySerialUTF8liUcubeName (OSCTXT* pctxt, 
   ASN1T_EXP_X520CountrySerialUTF8liUcubeName* pvalue, ASN1TagType tagging, 
   int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "X520CountrySerialUTF8liUcubeName");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_UNIV|TM_PRIM|12):
         RTXCTXTPUSHELEMNAME (pctxt, "utf8String");

         stat = xd_utf8str (pctxt, &pvalue->u.utf8String, ASN1IMPL, length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { int nchars = rtxUTF8Len (pvalue->u.utf8String);
         if (!((nchars >= 1 && nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|19):
         RTXCTXTPUSHELEMNAME (pctxt, "printableString");

         stat = xd_charstr (pctxt, &pvalue->u.printableString, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|19), length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.printableString);
         if (!((nchars >= 1 && nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|20):
         RTXCTXTPUSHELEMNAME (pctxt, "teletexString");

         stat = xd_charstr (pctxt, &pvalue->u.teletexString, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|20), length);
         pvalue->t = 3;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.teletexString);
         if (!((nchars >= 1 && nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|28):
         RTXCTXTPUSHELEMNAME (pctxt, "universalString");

         pvalue->u.universalString = rtxMemAllocType (pctxt, 
            ASN1TUniversalString);

         if (pvalue->u.universalString == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.universalString->nchars = 0;
         stat = xd_32BitCharStr (pctxt,
            pvalue->u.universalString,
            ASN1IMPL, (TM_UNIV|TM_PRIM|28), length);
         pvalue->t = 4;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         if (!((pvalue->u.universalString->nchars >= 1 && pvalue->u.universalString->
            nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)pvalue->u.universalString->nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|30):
         RTXCTXTPUSHELEMNAME (pctxt, "bmpString");

         pvalue->u.bmpString = rtxMemAllocType (pctxt, ASN1TBMPString);

         if (pvalue->u.bmpString == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.bmpString->nchars = 0;
         stat = xd_16BitCharStr (pctxt,
            pvalue->u.bmpString,
            ASN1IMPL, (TM_UNIV|TM_PRIM|30), length);
         pvalue->t = 5;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         if (!((pvalue->u.bmpString->nchars >= 1 && pvalue->u.bmpString->nchars <= 128
            ))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)pvalue->u.bmpString->nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

EXTERN int asn1D_EXP_X520Pseudonym (OSCTXT* pctxt, 
   ASN1T_EXP_X520Pseudonym* pvalue, ASN1TagType tagging, int length)
{
   int stat = 0;
   ASN1TAG ctag;
   ASN1CCB ccb;

   RTXCTXTPUSHTYPENAME (pctxt, "X520Pseudonym");

   /* decode CHOICE */

   stat = xd_tag_len (pctxt, &ctag, &length, XM_ADVANCE);
   if (stat != 0) return LOG_RTERR (pctxt, stat);

   ccb.len = length;
   ccb.ptr = OSRTBUFPTR(pctxt);

   switch (ctag)
   {
      case (TM_UNIV|TM_PRIM|12):
         RTXCTXTPUSHELEMNAME (pctxt, "utf8String");

         stat = xd_utf8str (pctxt, &pvalue->u.utf8String, ASN1IMPL, length);
         pvalue->t = 1;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { int nchars = rtxUTF8Len (pvalue->u.utf8String);
         if (!((nchars >= 1 && nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|19):
         RTXCTXTPUSHELEMNAME (pctxt, "printableString");

         stat = xd_charstr (pctxt, &pvalue->u.printableString, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|19), length);
         pvalue->t = 2;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.printableString);
         if (!((nchars >= 1 && nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|20):
         RTXCTXTPUSHELEMNAME (pctxt, "teletexString");

         stat = xd_charstr (pctxt, &pvalue->u.teletexString, ASN1IMPL, 
            (TM_UNIV|TM_PRIM|20), length);
         pvalue->t = 3;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         { size_t nchars = OSCRTLSTRLEN (pvalue->u.teletexString);
         if (!((nchars >= 1 && nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|28):
         RTXCTXTPUSHELEMNAME (pctxt, "universalString");

         pvalue->u.universalString = rtxMemAllocType (pctxt, 
            ASN1TUniversalString);

         if (pvalue->u.universalString == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.universalString->nchars = 0;
         stat = xd_32BitCharStr (pctxt,
            pvalue->u.universalString,
            ASN1IMPL, (TM_UNIV|TM_PRIM|28), length);
         pvalue->t = 4;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         if (!((pvalue->u.universalString->nchars >= 1 && pvalue->u.universalString->
            nchars <= 128))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)pvalue->u.universalString->nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      case (TM_UNIV|TM_PRIM|30):
         RTXCTXTPUSHELEMNAME (pctxt, "bmpString");

         pvalue->u.bmpString = rtxMemAllocType (pctxt, ASN1TBMPString);

         if (pvalue->u.bmpString == NULL)
            return LOG_RTERR (pctxt, RTERR_NOMEM);

         pvalue->u.bmpString->nchars = 0;
         stat = xd_16BitCharStr (pctxt,
            pvalue->u.bmpString,
            ASN1IMPL, (TM_UNIV|TM_PRIM|30), length);
         pvalue->t = 5;
         if (stat != 0) return LOG_RTERR (pctxt, stat);

         if (!((pvalue->u.bmpString->nchars >= 1 && pvalue->u.bmpString->nchars <= 128
            ))) {
            rtxErrAddElemNameParm (pctxt);
            rtxErrAddIntParm (pctxt, (int)pvalue->u.bmpString->nchars);
            return LOG_RTERR (pctxt, RTERR_CONSVIO);
         }

         RTXCTXTPOPELEMNAME (pctxt);
         break;

      default:
         berErrAddTagParm (pctxt, ctag);
         return LOG_RTERR (pctxt, RTERR_INVOPT);
   }

   RTXCTXTPOPTYPENAME (pctxt);

   return (stat);
}

