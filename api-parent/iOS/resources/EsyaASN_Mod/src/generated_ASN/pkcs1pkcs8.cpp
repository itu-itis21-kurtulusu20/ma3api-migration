/**
 * This file was generated by the Objective Systems ASN1C Compiler
 * (http://www.obj-sys.com).  Version: 6.6.6, Date: 28-Feb-2014.
 */
#include <new>
#include "pkcs1pkcs8.h"
#include "rtxsrc/rtxCommon.h"

ASN1T_PKCS18_PrivateKey* new_ASN1T_PKCS18_PrivateKey (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_PKCS18_PrivateKey));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_PKCS18_PrivateKey;
}

ASN1C_PKCS18_PrivateKey::ASN1C_PKCS18_PrivateKey
    (ASN1T_PKCS18_PrivateKey& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_PKCS18_PrivateKey::ASN1C_PKCS18_PrivateKey (OSRTMessageBufferIF& msgBuf
   , ASN1T_PKCS18_PrivateKey& data) : ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_PKCS18_PrivateKey::ASN1C_PKCS18_PrivateKey (OSRTContext &context
   , ASN1T_PKCS18_PrivateKey& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_PKCS18_PrivateKey::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_PKCS18_PrivateKey (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_PKCS18_PrivateKey::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_PKCS18_PrivateKey (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_PKCS18_PrivateKey (ASN1T_PKCS18_PrivateKey* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_PKCS18_PrivateKey;
}

void asn1Free_PKCS18_PrivateKey (OSCTXT *pctxt, 
   ASN1T_PKCS18_PrivateKey* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

void ASN1C_PKCS18_PrivateKey::MemFree ()
{
   asn1Free_PKCS18_PrivateKey (getCtxtPtr(), &msgData);
}

ASN1T_PKCS18_EncryptedData* new_ASN1T_PKCS18_EncryptedData (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_PKCS18_EncryptedData));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_PKCS18_EncryptedData;
}

ASN1C_PKCS18_EncryptedData::ASN1C_PKCS18_EncryptedData
    (ASN1T_PKCS18_EncryptedData& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_PKCS18_EncryptedData::ASN1C_PKCS18_EncryptedData (
   OSRTMessageBufferIF& msgBuf, ASN1T_PKCS18_EncryptedData& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_PKCS18_EncryptedData::ASN1C_PKCS18_EncryptedData (OSRTContext &context
   , ASN1T_PKCS18_EncryptedData& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


int ASN1C_PKCS18_EncryptedData::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_PKCS18_EncryptedData (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_PKCS18_EncryptedData::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1D_PKCS18_EncryptedData (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_PKCS18_EncryptedData (ASN1T_PKCS18_EncryptedData* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_PKCS18_EncryptedData;
}

void asn1Free_PKCS18_EncryptedData (OSCTXT *pctxt, 
   ASN1T_PKCS18_EncryptedData* pvalue)
{
   if (0 == pvalue) return;
   if (pvalue->numocts > 0) {
      rtxMemFreePtr (pctxt, (void*)pvalue->data);
      pvalue->numocts = 0;
      pvalue->data = 0;
   }
}

void ASN1C_PKCS18_EncryptedData::MemFree ()
{
   asn1Free_PKCS18_EncryptedData (getCtxtPtr(), &msgData);
}

ASN1T_PKCS18_PrivateKeyInfo* new_ASN1T_PKCS18_PrivateKeyInfo (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_PKCS18_PrivateKeyInfo));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_PKCS18_PrivateKeyInfo;
}

ASN1C_PKCS18_PrivateKeyInfo::ASN1C_PKCS18_PrivateKeyInfo
    (ASN1T_PKCS18_PrivateKeyInfo& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_PKCS18_PrivateKeyInfo::ASN1C_PKCS18_PrivateKeyInfo (
   OSRTMessageBufferIF& msgBuf, ASN1T_PKCS18_PrivateKeyInfo& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_PKCS18_PrivateKeyInfo::ASN1C_PKCS18_PrivateKeyInfo (OSRTContext &context
   , ASN1T_PKCS18_PrivateKeyInfo& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_PKCS18_PrivateKeyInfo::ASN1T_PKCS18_PrivateKeyInfo ()
{
   m.attributesPresent = 0;
}

ASN1T_PKCS18_PrivateKeyInfo::~ASN1T_PKCS18_PrivateKeyInfo ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_PKCS18_PrivateKeyInfo (pctxt, this);
   }
}

int ASN1C_PKCS18_PrivateKeyInfo::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_PKCS18_PrivateKeyInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_PKCS18_PrivateKeyInfo::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_PKCS18_PrivateKeyInfo;
   msgData.setContext (msgBuf.getContext());
   return asn1D_PKCS18_PrivateKeyInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_PKCS18_PrivateKeyInfo (ASN1T_PKCS18_PrivateKeyInfo* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_PKCS18_PrivateKeyInfo;
}

void asn1Free_PKCS18_PrivateKeyInfo (OSCTXT *pctxt, 
   ASN1T_PKCS18_PrivateKeyInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_EXP_AlgorithmIdentifier (pctxt, &pvalue->privateKeyAlgorithm);
   asn1Free_PKCS18_PrivateKey (pctxt, &pvalue->privateKey);
   if (pvalue->m.attributesPresent) {
      asn1Free_PKCS10_Attributes (pctxt, &pvalue->attributes);
   }
}

void ASN1C_PKCS18_PrivateKeyInfo::MemFree ()
{
   asn1Free_PKCS18_PrivateKeyInfo (getCtxtPtr(), &msgData);
}

ASN1T_PKCS18_EncryptedPrivateKeyInfo* 
   new_ASN1T_PKCS18_EncryptedPrivateKeyInfo (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_PKCS18_EncryptedPrivateKeyInfo));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_PKCS18_EncryptedPrivateKeyInfo;
}

ASN1C_PKCS18_EncryptedPrivateKeyInfo::ASN1C_PKCS18_EncryptedPrivateKeyInfo
    (ASN1T_PKCS18_EncryptedPrivateKeyInfo& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_PKCS18_EncryptedPrivateKeyInfo::ASN1C_PKCS18_EncryptedPrivateKeyInfo (
   OSRTMessageBufferIF& msgBuf, ASN1T_PKCS18_EncryptedPrivateKeyInfo& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_PKCS18_EncryptedPrivateKeyInfo::ASN1C_PKCS18_EncryptedPrivateKeyInfo (
   OSRTContext &context, ASN1T_PKCS18_EncryptedPrivateKeyInfo& data) : 
   ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_PKCS18_EncryptedPrivateKeyInfo::ASN1T_PKCS18_EncryptedPrivateKeyInfo ()
{
}

ASN1T_PKCS18_EncryptedPrivateKeyInfo::~ASN1T_PKCS18_EncryptedPrivateKeyInfo ()
{
   OSCTXT* pctxt = mpContext.getCtxtPtr();
   if (pctxt != 0 && !rtxMemHeapIsEmpty (pctxt)) {
      asn1Free_PKCS18_EncryptedPrivateKeyInfo (pctxt, this);
   }
}

int ASN1C_PKCS18_EncryptedPrivateKeyInfo::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_PKCS18_EncryptedPrivateKeyInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_PKCS18_EncryptedPrivateKeyInfo::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   new (&msgData) ASN1T_PKCS18_EncryptedPrivateKeyInfo;
   msgData.setContext (msgBuf.getContext());
   return asn1D_PKCS18_EncryptedPrivateKeyInfo (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

void asn1Init_PKCS18_EncryptedPrivateKeyInfo (
   ASN1T_PKCS18_EncryptedPrivateKeyInfo* pvalue)
{
   if (0 == pvalue) return;
   new (pvalue) ASN1T_PKCS18_EncryptedPrivateKeyInfo;
}

void asn1Free_PKCS18_EncryptedPrivateKeyInfo (OSCTXT *pctxt, 
   ASN1T_PKCS18_EncryptedPrivateKeyInfo* pvalue)
{
   if (0 == pvalue) return;
   asn1Free_EXP_AlgorithmIdentifier (pctxt, &pvalue->encryptionAlgorithm);
   asn1Free_PKCS18_EncryptedData (pctxt, &pvalue->encryptedData);
}

void ASN1C_PKCS18_EncryptedPrivateKeyInfo::MemFree ()
{
   asn1Free_PKCS18_EncryptedPrivateKeyInfo (getCtxtPtr(), &msgData);
}

ASN1T_PKCS18_RSAPublicKey* new_ASN1T_PKCS18_RSAPublicKey (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_PKCS18_RSAPublicKey));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_PKCS18_RSAPublicKey;
}

ASN1C_PKCS18_RSAPublicKey::ASN1C_PKCS18_RSAPublicKey
    (ASN1T_PKCS18_RSAPublicKey& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_PKCS18_RSAPublicKey::ASN1C_PKCS18_RSAPublicKey (
   OSRTMessageBufferIF& msgBuf, ASN1T_PKCS18_RSAPublicKey& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_PKCS18_RSAPublicKey::ASN1C_PKCS18_RSAPublicKey (OSRTContext &context
   , ASN1T_PKCS18_RSAPublicKey& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_PKCS18_RSAPublicKey::ASN1T_PKCS18_RSAPublicKey ()
{
}

int ASN1C_PKCS18_RSAPublicKey::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_PKCS18_RSAPublicKey (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_PKCS18_RSAPublicKey::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   msgData.setContext (msgBuf.getContext());
   return asn1D_PKCS18_RSAPublicKey (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

ASN1T_PKCS18_RSAPrivateKey* new_ASN1T_PKCS18_RSAPrivateKey (ASN1CType& ccobj)
{
   void* pdata = ccobj.memAlloc (sizeof(ASN1T_PKCS18_RSAPrivateKey));
   if (0 == pdata) return 0;
   else return new (pdata) ASN1T_PKCS18_RSAPrivateKey;
}

ASN1C_PKCS18_RSAPrivateKey::ASN1C_PKCS18_RSAPrivateKey
    (ASN1T_PKCS18_RSAPrivateKey& data) : ASN1CType(), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}

ASN1C_PKCS18_RSAPrivateKey::ASN1C_PKCS18_RSAPrivateKey (
   OSRTMessageBufferIF& msgBuf, ASN1T_PKCS18_RSAPrivateKey& data) : 
   ASN1CType(msgBuf), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}
ASN1C_PKCS18_RSAPrivateKey::ASN1C_PKCS18_RSAPrivateKey (OSRTContext &context
   , ASN1T_PKCS18_RSAPrivateKey& data) : ASN1CType(context), msgData(data)
{
   setRunTimeKey (_rtkey, sizeof(_rtkey));
}


ASN1T_PKCS18_RSAPrivateKey::ASN1T_PKCS18_RSAPrivateKey ()
{
}

int ASN1C_PKCS18_RSAPrivateKey::EncodeTo (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   return asn1E_PKCS18_RSAPrivateKey (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL);
}

int ASN1C_PKCS18_RSAPrivateKey::DecodeFrom (OSRTMessageBufferIF& msgBuf)
{
   int stat = setMsgBuf (msgBuf, TRUE);
   if (stat != 0) return (stat);

   msgData.setContext (msgBuf.getContext());
   return asn1D_PKCS18_RSAPrivateKey (msgBuf.getCtxtPtr(), &msgData, ASN1EXPL, 0);
}

